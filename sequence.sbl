*       Copyright 2017, David Shields
*       Licensed under the MIT license.

*       This file extends SPITBOL by adding support for creating and operating
*       on sequences.


*       Sequences.
*       ----------

*       A sequence is a map defined on the positive integers: 1,2, ... ,n.

        data('sequence(sequence.table,sequence.next,sequence.size)

*               _sequence.size_ is the length of the sequence.

*               _sequence.table_ is the map representing the sequence.

*               _sequence.next_ is used to iterate over the sequence.



        define('sequence.add(sequence,val)entry')                 :(sequence.add.end)

sequence.add

	entry = (sequence.size(sequence) = sequence.size(sequence) + 1,val)
	sequence.put(sequence,sequence.size(sequence), val))		
	sequence.add = entry					:(return)

sequence.add.end

	define('sequence.apply(sequence,f)entry,entry.new')	:(sequence.apply.end)

*	_sequence.apply_ returns the sequence obtained by applying _f- to each entry in _sequence_.
*       If _f_ is a string, it is evaluated using _eval_; otherwise _f_is called
*       as a function.

sequence.apply

	sequence.apply = sequence.sequence(sequence.size(sequence))
	sequence.loop(sequence)

sequence.apply.next

	entry = sequence.next(sequence)				:f(return)
        entry.new = ident(datatype(f,'string)  apply(f,entry)
        entry.new = ident(datatype(f,'code')  apply(f,entry)
	sequence.put(sequence.apply,key(entry.new), value(entry.new)):(sequence.apply.next)

sequence.apply.end

        define(‘sequence.forall(sequence’)                    :(sequence.forall.end)

*        Returns sequence defined as follows:
*        Iterare over _sequence_. For each entry _ent_, invoke f(ent) and use the
*        result to define a new entry in the result.

sequence.forall

        sequence.forall = sequence()
        sequence.loop(sequence)

sequence.forall.next

sequence.forall = apply(f,sequence.forall,sequence.next(sequence))          :f(return)s(sequence.forall.next)


sequence.forall.end

        define(‘sequence.foreach(sequence,f)entry’)               :(sequence.foreach.end)

*        Returns a sequence defined by iterating over the entries in _sequence_, and applying
*        f to the entry to define a new entry in the result.

sequence.foreach

        sequence.foreach = sequence()

sequence.foreach.next

        entry = apply(f,sequence.next(sequence))                    :f(return)
        sequence.put(sequence.foreach, entry.key(ent), entry.value(ent)):(sequence.foreach.next)

sequence.foreach.end

        define('sequence.get(i)')                                  :(sequence.get.end)

*       Gets the value of element _i_ in the sequence _sequence_

sequence.get

        sequence.get = sequence.table(sequence)[i]                   :(return)

sequence.get.end

        define('sequence.loop(sequence,kind)')                    :(sequence.loop.end)

*       Returns an iterator for _sequence_. Use _sequence.next_ to retrieve
*       the next entry in sequence. _sequence.next_ fails when no more entries remain.

*       _kind_ gives the kind of loop:

*               '+order'        iterate in order in which entries added. (default)
*               '-order'        iterate in reverse order in which entries added.
*               '+key'          iterate in incresing values of keys.
*               '-key'          iterate in decceasing values of keys.
*               '+val'          iterate in incresing values of values.
*               '-key'          iterate in decreasing values of keys.

*       Otherwise iterate over the keys in the order in which they were added to the sequence.

sequence.loop

        sequence.index(sequence) = 0
        ident(kind)                                     :s(sequence.loop.order)
        ident(kind, '+order')                           :s(sequence.loop.key.order.inc)
        ident(kind, '-order')                           :s(sequence.loop.key.order.dec)
        ident(kind, '+key')                             :s(sequence.loop.key.inc)
        ident(kind, '-key')                             :s(sequence.loop.key.dec)
        ident(kind, '+val')                             :s(sequence.loop.value.inc)
        ident(kind, '-val')                             :s(sequence.loop.value.dec)

sequence.loop.order.inc

        sequence.array(sequence) = convert(sequence.table(sequence),'array'):(sequence.done)

sequence.loop.rorder.inc

        output = 'loop rorder not implemented '         :(nosuchlabel)
        sequence.array(sequence) = convert(sequence.table(sequence),'array'):(sequence.done)

sequence.loop.key.inc

        sequence.array(sequence) = rsort(sequence.table(sequence),1)        :(return)

sequence.loop.key.dec

        sequence.array(sequence) = sort(sequence.table(sequence),1)         :(return)

sequence.loop.value.inc

        sequence.array(sequence) = rsort(sequence.table(sequence),2)        :(return)

sequence.loop.value.dec

        sequence.array(sequence) = sort(sequence.table(sequence),-2)        :(return)

sequence.loop.end

        define('sequence.new(init,n)i,key,str,valr')         :(sequence.new.end)

*       Create a new sequence.

*       A sequence is a list of values *  separated by spaces.

*               sequence       _init_ is a list consisting of a list of key/value pairs,
*                               with a colon (:) between the key and value.

sequence.new

        sequence.new = ident(init) sequence(table(128))           :s(return)
        kind = ident(kind) 'sequence'
        kind
        output = 'enter sequence.new [' init ']'
        init break(':')                                	:s(sequence.new.keyval)
        sequence.new = sequence(table(i))                         :(return)

sequence.new.keyval
        
        sequence.new = sequence(table(128))

sequence.new.keyval.next

        init break(':') . key ':' break(' ') . val ' ' =	:f(return)
        sequence.put(sequence.new,key,val)                        :(sequence.new.keyval.next)

sequence.new.end

        define('sequence.next(sequence)')                         :(sequence.next.end)

*       _sequence.next_ returns the next entry in a sequence, or fails if no entries remain.

sequence.next

        le(sequence.index(sequence) = sequence.index(sequence) + 1, sequence.size(sequence)):f(freturn)
        sequence.next = entry(sequence.array[sequence.index(sequence),1],sequence.array[sequence.index(sequence),2]):(return)

sequence.next.end

        define(‘sequence.range(sequence)’)                    :(sequence.range.sequence)


*        Return map with the values in _sequence_ as its members.


sequence.range

        sequence.range = sequence.sequence()
        sequence.loop(sequence)

sequence.range.next

        sequence.range.add(entry.value(sequence.next(sequence))        :f(return)s(sequence.range.next)

sequence.range.end

	define('sequence.reduce(sequence,test')entry')		:(sequence.reduce.end)

*	_sequence.reduce_ returns a new sequence by iterating over the elements in
*	_sequence_ and appling the function _test_ on each entry.
*	If _test_ succeeds, then the entry is added to the new sequence,
*	otherwise it is ignored.
*	_test_ must be the name of the functiono to be used for the test.

sequence.range

	sequence.range = sequence(sequence.size(sequence))
	sequence.loop(sequence)

sequence.range.next

	entry = sequence.next(sequence)
	apply(test,entry)				:f(sequence.range.next)
	sequence.put(sequence.range,key(entry),value(entry)) :(sequence.range.next)

sequence.range.end


        define('sequence.put(sequence,i,val)v')                 :(sequence.put.end)

*       Sets the value of element _i_ in the sequence _sequence_ to be _val_.

sequence.put

        output = 'enter sequence.put dt ' datatype(sequence) ' i [' i '] val [' val ']'
        v = sequence.table(sequence)[i]
        differ(v)                                       :s(sequence.put.value)

*       Here to create new entry in sequence.

        sequence.size(sequence) = sequence.size(sequence) + 1

sequence.put.value

        sequence.table(sequence)[i] = val                       :(return)

sequence.put.end
