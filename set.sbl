
*       Sets
*       ____
        

*       A set is a collection of values, in no particular order.
*       PLAYBOL implements a set as a map for which the value
*       of the elements of the set is "true."


set.add

	entry = (set.size(set) = set.size(set) + 1,val)
	set.put(set,set.size(set), val))		
	set.add = entry					:(return)

set.add.end

	define('set.apply(set,f)entry,entry.new')	:(set.apply.end)

*	_set.apply_ returns the set obtained by applying _f- to each entry in _set_.
*       If _f_ is a string, it is evaluated using _eval_; otherwise _f_is called
*       as a function.

set.apply

	set.apply = set.set(set.size(set))
	set.loop(set)

set.apply.next

	entry = set.next(set)				:f(return)
        entry.new = ident(datatype(f,'string)  apply(f,entry)
        entry.new = ident(datatype(f,'code')  apply(f,entry)
	set.put(set.apply,key(entry.new), value(entry.new)):(set.apply.next)

set.apply.end


        define('set.array(aray)i,key')                  :(set.array.end)

*	Create a set defined by an array.
*	If the array has one dimension then create a set
*	from the array values.
*	If the array has two dimensions, create a set using the
*	array indice as the keys, and the correspong value as the
*	values.

set.array

        set.array = set()
        i = prototype(aray)
        integer(i)                                      :s(set.array.one)

*       Here to initialize from two-dimensional array

set.array.next

        key = aray[i = i + 1,1]                         :f(return)
        set.put(set.aray,i,aray[i,2]                    :(set.array.next

set.array.one

*        Here to initialize set from one-dimensional array

set.array.next

        key = aray[i = i + 1]				:f(return)
        set.add(set.array,key)                          :(set.array.next)


set.array.end

        define(‘set.domain(entry’)			:(set.domain.end)

*       Return set with the keys in _set_.

        set.loop(set)

set.domain

        entry = set.next(set)                           :f(return)
        set.add(set.domain,ent)                         :(set.domain)

set.domain.end

        define(‘set.forall(set’)                    :(set.forall.end)

*        Returns set defined as follows:
*        Iterare over _set_. For each entry _ent_, invoke f(ent) and use the
*        result to define a new entry in the result.

set.forall

        set.forall = set()
        set.loop(set)

set.forall.next

set.forall = apply(f,set.forall,set.next(set))          :f(return)s(set.forall.next)


set.forall.end

        define(‘set.foreach(set,f)entry’)               :(set.foreach.end)

*        Returns a set defined by iterating over the entries in _set_, and applying
*        f to the entry to define a new entry in the result.

set.foreach

        set.foreach = set()

set.foreach.next

        entry = apply(f,set.next(set))                    :f(return)
        set.put(set.foreach, entry.key(ent), entry.value(ent)):(set.foreach.next)

set.foreach.end

        define('set.get(key,val)')                  :(set.get.end)

*       Gets the value of the key _key_ in the set _set_.

set.get

        set.get = set.table(set)[key]                   :(return)

set.get.end

	define('set.inverse)entry')			:(set.inverse.end)

*	_set.inverse_ returns the inverse of a set. The inverse is
*	a set with the keys and values of _set_ reversed. 
*	_set.inverse_ fails if there are two instances of the same
*	value in the range of the set.

set.inverse

	set.inverse = set.set(set.size(set))
	set.loop(set)

set.inverse.next

	entry = set.next(set)				:f(return)
	differ(set.get(set.inverse,value(entry)))	:f(freturn)
	set.put(set.inverse,value(entry), key(entry))  :(set.inverse.next)

set.inverse.end

        define('set.loop(set,kind)')                    :(set.loop.end)

*       Returns an iterator for _set_. Use _set.next_ to retrieve
*       the next entry in set. _set.next_ fails when no more entries remain.

*       _kind_ gives the kind of loop:

*               '+order'        iterate in order in which entries added. (default)
*               '-order'        iterate in reverse order in which entries added.
*               '+key'          iterate in incresing values of keys.
*               '-key'          iterate in decceasing values of keys.
*               '+val'          iterate in incresing values of values.
*               '-key'          iterate in decreasing values of keys.

*       Otherwise iterate over the keys in the order in which they were added to the set.

set.loop

        set.index(set) = 0
        ident(kind)                                     :s(set.loop.order)
        ident(kind, '+order')                           :s(set.loop.key.order.inc)
        ident(kind, '-order')                           :s(set.loop.key.order.dec)
        ident(kind, '+key')                             :s(set.loop.key.inc)
        ident(kind, '-key')                             :s(set.loop.key.dec)
        ident(kind, '+val')                             :s(set.loop.value.inc)
        ident(kind, '-val')                             :s(set.loop.value.dec)

set.loop.order.inc

        set.array(set) = convert(set.table(set),'array'):(set.done)

set.loop.rorder.inc

        output = 'loop rorder not implemented '         :(nosuchlabel)
        set.array(set) = convert(set.table(set),'array'):(set.done)

set.loop.key.inc

        set.array(set) = rsort(set.table(set),1)        :(return)

set.loop.key.dec

        set.array(set) = sort(set.table(set),1)         :(return)

set.loop.value.inc

        set.array(set) = rsort(set.table(set),2)        :(return)

set.loop.value.dec

        set.array(set) = sort(set.table(set),-2)        :(return)

set.loop.end

        define('set.new(init,n)i,key,str,valr')         :(set.new.end)

*       Create a new set.

*       A set is a list of values *  separated by spaces.

*               set       _init_ is a list consisting of a list of key/value pairs,
*                               with a colon (:) between the key and value.

set.new

        set.new = ident(init) set(table(128))           :s(return)
        kind = ident(kind) 'set'
        kind
        output = 'enter set.new [' init ']'
        init break(':')                                	:s(set.new.keyval)
        set.new = set(table(i))                         :(return)

set.new.keyval
        
        set.new = set(table(128))

set.new.keyval.next

        init break(':') . key ':' break(' ') . val ' ' =	:f(return)
        set.put(set.new,key,val)                        :(set.new.keyval.next)

set.new.end

        define('set.next(set)')                         :(set.next.end)

*       _set.next_ returns the next entry in a set, or fails if no entries remain.

set.next

        le(set.index(set) = set.index(set) + 1, set.size(set)):f(freturn)
        set.next = entry(set.array[set.index(set),1],set.array[set.index(set),2]):(return)

set.next.end

        define(‘set.range(set)’)                    :(set.range.set)


*        Return set with the values in _set_.


set.range

        set.range = set.set()
        set.loop(set)

set.range.next

        set.range.add(entry.value(set.next(set))        :f(return)s(set.range.next)

set.range.end

	define('set.reduce(set,test')entry')		:(set.reduce.end)

*	_set.reduce_ returns a new set by iterating over the elements in
*	_set_ and appling the function _test_ on each entry.
*	If _test_ succeeds, then the entry is added to the new set,
*	otherwise it is ignored.
*	_test_ must be the name of the functiono to be used for the test.

set.range

	set.range = set(set.size(set))
	set.loop(set)

set.range.next

	entry = set.next(set)
	apply(test,entry)				:f(set.range.next)
	set.put(set.range,key(entry),value(entry)) :(set.range.next)

set.range.end


        define('set.put(key,val)v')                 :(set.put.end)

*       Sets the value of the entry for key _key_ in set _set_ to be _val_, 
*       creating a new entry if there is no current entry for _key_.

set.put

        output = 'enter set.put dt ' datatype(set) ' key [' key '] val [' val ']'
        v = set.table(set)[key]
        differ(v)                                       :s(set.put.value)

*       Here to create new entry in set.

        set.size(set) = set.size(set) + 1

set.put.value

        set.table(set)[key] = val                       :(return)

set.put.end

        define('set.test(key)')                     :(set.test.end)

*       Tests if the set _set_ has an entry for _key_.

set.test

        differ(set.table(set)[key])                     :s(return)f(freturn)

set.test.end


smet.in

        set.in = (differ(set.table[x]) true, false)             :(return)

set.in.end

        define('set.notin(x,s)')                               :(set.notin.end)

*       Returns _true_ iff _x_ is is not element in _s_.

set.notin

        set.notin = (ident(set.table[x]) true, false)             :(return)

set.notin.end

        define('set.size(set)')                                 :(set.size.end)

set.size

        set.size = set.num(set)                                 :(return)

set.size.end

        define('set.union(a,b)')                                   :(set.or.end)

*       Returns union of sets _a_ and _b_.

set.union

        gt(set.size(b),set.size(a))                             :s(set.union.b)

*       Here if _a_ is the larget set, so copy it and then add
*       in the elements of _b_.

        set.union = set.apply(f,a)
        set.loop(b)

set.union.a

        set.add(set.union,set.next(b))                          :freturn)f(return)

set.union.b

*       Here if _b_ is the larget set, so copy it and then add in
*       the elements of _a_.

        set.union = set.apply(f,b)
        set.loop(b)

set.union.end
