
*       Sets
*       ____
        

*       A set is a collection of values, in no particular order.
*       SETL4  implements a set as a map for which the value
*       of the elements of the set is "true."


	data('set(set.table,set.size,set.next)')

	define('set.add(set,elem')			:(set.add.end)

*	Add _elem_ to set, unless already present.


set.add

	elem = (set.size(set) = set.size(set) + 1,val)
	set.add(set,set.size(set), val))		
	set.add = elem					:(return)

set.add.end

	define('set.apply(set,f)elem,elem.new')	:(set.apply.end)

*	_set.apply_ returns the set obtained by applying _f- to each elem in _set_.
*       If _f_ is a string, it is evaluated using _eval_; otherwise _f_is called
*       as a function.

set.apply

	set.apply = set.set(set.size(set))
	set.loop(set)

set.apply.next

	elem = set.next(set)				:f(return)
        elem.new = ident(datatype(f,'string)  apply(f,elem)
        elem.new = ident(datatype(f,'code')  apply(f,elem)
	set.put(set.apply,key(elem.new), value(elem.new)):(set.apply.next)

set.apply.end


        define('set.array(aray)i,key')                  :(set.array.end)

*	Create a set defined by an array.
*	If the array has one dimension then create a set
*	from the array values.
*	If the array has two dimensions, create a set using the
*	array indice as the keys, and the correspong value as the
*	values.

set.array

        set.array = set()
        i = prototype(aray)
        integer(i)                                      :s(set.array.one)

*       Here to initialize from two-dimensional array

set.array.next

        key = aray[i = i + 1,1]                         :f(return)
        set.put(set.aray,i,aray[i,2]                    :(set.array.next

set.array.one

*        Here to initialize set from one-dimensional array

set.array.next

        key = aray[i = i + 1]				:f(return)
        set.add(set.array,key)                          :(set.array.next)


set.array.end

        define(‘set.domain(entry’)			:(set.domain.end)

*       Return set with the keys in _set_.

        set.loop(set)

set.domain

        entry = set.next(set)                           :f(return)
        set.add(set.domain,ent)                         :(set.domain)

set.domain.end

	define('set.equal(set,oset)x')			:(set.equal.end)

*	Tests if two sets are equal.

set.equal

	set.equal = false
	ne(set.size(set),set.size(oset))		:s(return)

*	Here if same size, so test if all elements in one
*	set are in the other.

	set.loop(set)

seq.equal.next

	x = set.next(set)				:f(set.equal.done)
	seq.equal = set.member(oset,x)			:s(set.equal.next)f(return)

set.equal.done

	set.equal = true				:(return)

set.equal.end

        define(‘set.forall(set’)                    :(set.forall.end)

*       Returns set defined as follows:
*       Iterare over _set_. For each entry _ent_, invoke f(ent) and use the
*       result to define a new entry in the result.

set.forall

        set.forall = set()
        set.loop(set)

set.forall.next

set.forall = apply(f,set.forall,set.next(set))          :f(return)s(set.forall.next)


set.forall.end

        define(‘set.foreach(set,f)entry’)               :(set.foreach.end)

*        Returns a set defined by iterating over the entries in _set_, and applying
*        f to the entry to define a new entry in the result.

set.foreach

        set.foreach = set()

set.foreach.next

        entry = apply(f,set.next(set))                    :f(return)
        set.put(set.foreach, entry.key(ent), entry.value(ent)):(set.foreach.next)

set.foreach.end

        define('set.in(set,,ele)')                  :(set.in.end)

*       Tests if _elem_ is a member of set _set_.

set.in

        set.in = (differ(set.table(set)[key]) true ,false)                  :(return)

set.in.end

	define('set.in(set,elem)')				:(set.in.end)

*	Test if _elem_ is a member of set _set_.

set.in

        set.in = (differ(set.table[elem) true, false)             :(return)

set.in.end

        define('set.intersection(a,b)elem')                                   :(set.or.end)

*       Returns intersection of sets _a_ and _b_.

set.intersection

*	Arrange so set a is the smaller set.

	le(set.size(a),set.size(b))				:s(set.intersection.a)
	set.intersection = a 
	a = b
	b = set.intersection

set.intersection.a

*	Make copy of set _a_ by making copy of _a_'s table.

	set.intersection = set.new(,set.size(a))
	set.table(set.intersection) = copy(set.table(a))

	set.loop(b)

set.intersection.b

	elem = set.next(b)					:f(return)

*	Skip this entry if not in set _a_.
	
	set.notin(a,elem)					:s(set.intersection.b)
	set.add(set.intersection,elem)				:(set.intersection.b)
	
set.intersection.end

	define('set.less(a,b)elem')			:(set.less.end)

*	Returns set define by set of elements of _a_ that are not in _b_.

set.less

	set.less = set.new()
	set.loop(a)

set.less.a

	elem = set.next(a)				:f(return) notin(b,elem)						
	set.add(set.less,elem)				:s(set.less.a)

set.less.end

        define('set.loop(set)')                    :(set.loop.end)

*       Returns an iterator for _set_. Use _set.next_ to retrieve
*       the next entry in set. _set.next_ fails when no more entries remain.

set.loop

        set.index(set) = 0

set.loop.order.inc

        set.array(set) = convert(set.table(set),'array'):(set.done)

set.loop.end

        define('set.notin(set,,ele)')                  :(set.notin.end)

*       Tests if _elem_ is not a member of set _set_.

set.notin

        set.notin = (differ(set.table(set)[key]) false ,true)                  :(return)

set.notin.end

        define('set.new(init,n)i,key,str,valr')         :(set.new.end)

*       Create a new set.

*       A set is a list of values *  separated by spaces.

*               set       _init_ is a list consisting of a list of key/value pairs,
*                               with a colon (:) between the key and value.

set.new

        set.new = ident(init) set(table(128))           :s(return)
        kind = ident(kind) 'set'
        kind
        output = 'enter set.new [' init ']'
        init break(':')                                	:s(set.new.keyval)
        set.new = set(table(i))                         :(return)

set.new.keyval
        
        set.new = set(table(128))

set.new.keyval.next

        init break(':') . key ':' break(' ') . val ' ' =	:f(return)
        set.put(set.new,key,val)                        :(set.new.keyval.next)

set.new.end

        define('set.next(set)')                         :(set.next.end)

*       _set.next_ returns the next entry in a set, or fails if no entries remain.

set.next

        le(set.index(set) = set.index(set) + 1, set.size(set)):f(freturn)
        set.next = entry(set.array[set.index(set),1],set.array[set.index(set),2]):(return)

set.next.end

        define('set.notin(x,s)')                               :(set.notin.end)

*       Returns _true_ iff _x_ is is not element in _s_.

set.notin

        set.notin = (ident(set.table[x]) true, false)             :(return)

set.notin.end

        define('set.size(set)')                                 :(set.size.end)

set.size

        set.size = set.num(set)                                 :(return)

set.size.end

        define('set.union(a,b)elem')                                   :(set.or.end)

*       Returns union of sets _a_ and _b_.

set.union

*	Arrange so set a is the larger set.

	ge(set.size(a),set.size(b))				:s(set.union.a)
	set.union = a 
	a = b
	b = set.union

set.union.a

*	Make copy of a by making copy of a's table.

	set.union = set.new(,set.size(a))
	set.table(set.union) = copy(set.table(a))

	set.loop(b)

set.union.b

	elem = set.next(b)					:f(return)
	set.add(set.union,elem)					:(set.union.b)
	
set.union.end

