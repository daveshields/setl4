* 	Utilities
*	---------

*	Various utility funtions that have proven useful.


	define('chars(word)m,c')	:(chars.end)

*	Returns all the characters in word in sorted order:
*	The a's before the b's, b's before c's, and so forth.

chars
	
	m = map.new(size(word))

chars.next

	word len(1) . c =			:f(chars.done)
	map.add(m,c)				:(chars.next)

chars.done

	map.loop(m,'+val')

chars.done.loop

	chars = chars value(map.next(m))	:f(return)s(chars.done.loop)

chars.end

        :(error.end)
error
        output = 'error lastno ' &lastno
        output = 'ERROR'
        output = 'Fatal error: stopping the madness.'
*       &dump = 3
                                                        :(end)
error.end
        
        define('datename(date)s')                       :(datename.end)

*       Convert date to form with no spaces, just dashes, to be
*       suitable for use as part of a file name.

datename

        datename = replace(date,' :/','---')
        datename = substr(datename,12,8) '-' substr(datename,1,10)
                                                        :(return)
datename.end

        define('log(text)')                             :(log.end)

*       Write text to logfile if making a log.

*LOG*
log
        eq(g.log)                                       :s(return)

        g.logfile = text                                :(return)

log.end


        define('out(text1,text2,text3)type1,type2')     :(out.end)

*       Output a line conisting of TEXT1, TEXT2 enclosed
*       in brackets, followed by TEXT3.

*OUT*
out
        output = text1 (differ(text2) '[' text2 ']', '')  (differ(text3) text3, ''):(return)

        differ(text2)                                   :s(out.text2)

*       Here if just text1.

        output = text1                                  :(return)

out.text2

        type2 = dt(text2)
        type3 = dt(text3)
*       output = 'dt(type2) ' dt(type2)
*       output = 'dt(type3) ' dt(type3)
        ident(datatype(text2),'string')                 :s(out.2)
*       output = 'out second argument not integer or string,'
*.      ' but of type ' type2
*.                                              	:(error)

out.2

        ident(type3,'integer')                          :s(out.3)
        ident(type3,'string')                           :s(out.3)

out.3
        type.ex(text3,'string')                         :s(out.ok)
        type.ex(text3,'integer')             	:s(out.ok)
*       output = 'out third argument not integer or string,'
*.      ' but of type ' type3
*.                                               :(error)

out.ok

        output = text1 ' [' text2 ']' text3  	:(return)

out.end


        define('traceoff()')                            :(traceoff.end)

*       Initiate tracing.

*TRACEOFF*
traceoff
        &ftrace = &trace =

        g.scoring = g.tracing = 0
        out('stop TRACING ')

traceoff.end

        define('traceon()')                             :(traceon.end)

*       Initiate tracing.

*TRACEON*
traceon

        out('start TRACING')
*       &ftrace = &trace = 1500000
        g.scoring = g.tracing = 1
                                                        :(return)
traceon.end

	define('add1(v)')	:(add1.end)

add1

	$v = $v + 1			:(return)

add1.end

*	program to play wordwizard (ww)
*	Use host(0) to give the signature of the puzzle.

	define('mark(line)')		:(mark.end)

*	skip words with wrong length
*	skip words with signature that differs from
*	that of the puzzle.

mark
	ne(size(line),size(g.puzzle))	:s(freturn)
	sig = signature(line)
	differ(signature(line),puzzle.signature) 	:s(return)
	mark = pair(,line)		:(return)
mark.end
