*       Copyright 2017, David Shields
*       Licensed under the MIT license.


*TODO	Add   elem ? set  for   is elem member of set  

*	Define '#' as unary operator that returns size of its operand.


	define('setl4.size(s)dt')			:(setl4.size.end)

*	Return size of operand.


setl4.size
	
	dt = datatype(s)

	output = 'enter setl4.size ' dt
	setl4.size = ident(dt,'string') size(s)			:s(return)
	setl4.size = ident(dt,'set') set.size(s)		:s(return)
	setl4.size = ident(dt,'sequence') sequence.size(s)	:s(return)
	output = 'setl4.size unknown type ' dt :(end)

setl4.size.end

	opsyn('#','setl4.size',1)

*       Sets
*       ____
        

*       A set is a collection of values, in no particular order.
*       SETL4  implements a set as a map for which the value
*       of the elements of the set is "true."


	data('set(set.table,set.size,set.next)')

	define('set.add(set,elem)')			:(set.add.end)

*	Add _elem_ to set, unless already present.


set.add

	elem = pair(set.size(set) = set.size(set) + 1,val)
	set.add(set, val)
	set.add = elem					:(return)

set.add.end

	define('set.apply(set,f)elem,elem.new')	:(set.apply.end)

*	_set.apply_ returns the set obtained by applying _f- to each elem in _set_.
*       If _f_ is a string, it is evaluated using _eval_; otherwise _f_is called
*       as a function.

set.apply

	set.apply = set.set(set.size(set))
	set.loop(set)

set.apply.next

	elem = set.next(set)				:f(return)
        elem.new = ident(datatype(f),'string')  apply(f,elem)
        elem.new = ident(datatype(f,'code')  apply(f,elem))
	set.put(set.apply,key(elem.new), value(elem.new)):(set.apply.next)

set.apply.end


*        define('set.array(aray)i,key')                  :(set.array.end)
*
**	Create a set defined by an array.
**	If the array has one dimension then create a set
**	from the array values.
**	If the array has two dimensions, create a set using the
**	array indice as the keys, and the correspong value as the
**	values.
*
*set.array
*
*        set.array = set()
*        i = prototype(aray)
*        integer(i)                                      :s(set.array.one)
*
**       Here to initialize from two-dimensional array
*
*set.array.next
*
*        key = aray[i = i + 1,1]                         :f(return)
*        set.put(set.aray,i,aray[i,2])                    :(set.array.next
*
*set.array.one
*
**        Here to initialize set from one-dimensional array
*
*set.array.next
*
*        key = aray[i = i + 1]				:f(return)
*        set.add(set.array,key)                          :(set.array.next)
*
*
*set.array.end

        define('set.domain(set)entry')			:(set.domain.end)

*       Return set with the keys in _set_.

        set.loop(set)

set.domain

        entry = set.next(set)                           :f(return)
        set.add(set.domain,ent)                         :(set.domain)

set.domain.end

	define('set.equal(set,oset)x')			:(set.equal.end)

*	Tests if two sets are equal.

set.equal

	set.equal = false
	ne(set.size(set),set.size(oset))		:s(return)

*	Here if same size, so test if all elements in one
*	set are in the other.

	set.loop(set)

seq.equal.next

	x = set.next(set)				:f(set.equal.done)
	seq.equal = set.member(oset,x)			:s(set.equal.next)f(return)

set.equal.done

	set.equal = true				:(return)

set.equal.end

        define('set.forall(set)')                    :(set.forall.end)

*       Returns set defined as follows:
*       Iterare over _set_. For each entry _ent_, invoke f(ent) and use the
*       result to define a new entry in the result.

set.forall

        set.forall = set()
        set.loop(set)

set.forall.next

	set.forall = apply(f,set.forall,set.next(set))          
.	:f(return)s(set.forall.next)


set.forall.end

        define('set.foreach(set,f)entry')               :(set.foreach.end)

*        Returns a set defined by iterating over the entries in _set_, and applying
*        f to the entry to define a new entry in the result.

set.foreach

        set.foreach = set()

set.foreach.next

        entry = apply(f,set.next(set))                    :f(return)
        set.put(set.foreach, entry.key(ent), entry.value(ent)):(set.foreach.next)

set.foreach.end

	define('set.in(set,elem)')				:(set.in.end)

*	Test if _elem_ is a member of set _set_.

set.in

        set.in = (differ(set.table[elem]) true, false)             :(return)

set.in.end

        define('set.intersection(a,b)elem')                                   :(set.intersection.end)

*       Returns intersection of sets _a_ and _b_.

set.intersection

*	Arrange so set a is the smaller set.

	le(set.size(a),set.size(b))				:s(set.intersection.a)
	set.intersection = a 
	a = b
	b = set.intersection

set.intersection.a

*	Make copy of set _a_ by making copy of _a_'s table.

	set.intersection = set.new(,set.size(a))
	set.table(set.intersection) = copy(set.table(a))

	set.loop(b)

set.intersection.b

	elem = set.next(b)					:f(return)

*	Skip this entry if not in set _a_.
	
	set.notin(a,elem)					:s(set.intersection.b)
	set.add(set.intersection,elem)				:(set.intersection.b)
	
set.intersection.end

	define('set.less(a,b)elem')			:(set.less.end)

*	Returns set define by set of elements of _a_ that are not in _b_.

set.less

	set.less = set.new()
	set.loop(a)

set.less.a

	elem = set.next(a)				:f(return)
	set.in(b,elem)					:s(set.less.a)
	set.add(set.less,elem)				:s(set.less.a)

set.less.end

        define('set.loop(set)')                    :(set.loop.end)

*       Returns an iterator for _set_. Use _set.next_ to retrieve
*       the next entry in set. _set.next_ fails when no more entries remain.

set.loop

        set.index(set) = 0

set.loop.order.inc

        set.array(set) = convert(set.table(set),'array'):(set.done)

set.loop.end

        define('set.new(init,n)i,key,str,valr')         :(set.new.end)

*       Create a new set.

*       A set is a list of values *  separated by spaces.

*               set       _init_ is a list consisting of a list of key/value pairs,
*                               with a colon (:) between the key and value.

set.new

        set.new = ident(init) set(table(128))           :s(return)
        kind = ident(kind) 'set'
        kind
        output = 'enter set.new [' init ']'
        init break(':')                                	:s(set.new.keyval)
        set.new = set(table(i))                         :(return)

set.new.keyval
        
        set.new = set(table(128))

set.new.keyval.next

        init break(':') . key ':' break(' ') . val ' ' =	:f(return)
        set.put(set.new,key,val)                        :(set.new.keyval.next)

set.new.end

        define('set.next(set)')                         :(set.next.end)

*       _set.next_ returns the next entry in a set, or fails if no entries remain.

set.next

        le(set.index(set) = set.index(set) + 1, set.size(set)):f(freturn)
        set.next = entry(set.array[set.index(set),1],set.array[set.index(set),2]):(return)

set.next.end

        define('set.notin(x,s)')                               :(set.notin.end)

*       Returns _true_ iff _x_ is is not element in _s_.

set.notin

        set.notin = (ident(set.table[x]) true, false)             :(return)

set.notin.end

        define('set.size(set)')                                 :(set.size.end)

set.size

        set.size = set.num(set)                                 :(return)

set.size.end

        define('set.union(a,b)elem')                                   :(set.union.end)

*       Returns union of sets _a_ and _b_.

set.union

*	Arrange so set a is the larger set.

	ge(set.size(a),set.size(b))				:s(set.union.a)
	set.union = a 
	a = b
	b = set.union

set.union.a

*	Make copy of a by making copy of a's table.

	set.union = set.new(,set.size(a))
	set.table(set.union) = copy(set.table(a))

	set.loop(b)

set.union.b

	elem = set.next(b)					:f(return)
	set.add(set.union,elem)					:(set.union.b)
	
set.union.end

* MAP.SBL

*       Copyright 2017, David Shields
*       Licensed under the MIT license.

*       This file extends SPITBOL by adding support for creating and operating
*       on maps.


*       Maps: Functions
*       --------------

*       In mathematics, a map, or function, is a set of ordered pairs that define a relation between
*       the first element of a pair, called the domain value, and the second value of the pair, called
*       the range value.

*	A _pair_ joins two values together. 

        data('pair(first,second)')

*       The SPITBOL datatype TABLE provides the machinery to implement maps.
*       SPITBOL provides no way to determine the number of domain values, or size, of
*       a map other than converting the map to an array, which is only way to iterate
*       over a map.

*       PLAYBOL represents a map using the following data structures:

*       _entry_ is used to maintain a key/value pair.

        data('entry(key,value)')

        data('map(map.table,map.size,map.next)')

*               _map.size_ is the number of entries in the table.

*               _map.table_ is the table used to maintain the map by the various

*                _map.next_ is used to iterate over a map.

*       Note that these values should not be directly altered by you, the user.
*       You do so at your peril. However, when iterating over a map, you
*	may read the value of _map.next_ to access the entry of the current
*	iteration.

*	For example, to obtain the number of words in a file

*REVISE BELOW
*		define('f.count(entry) ;f.count; f.count = map.size(value(words(entry))) :(return)')
*		define('f.sum(result,entry); f.sum; f.sum = result + value(entry) :(return)')
*		result = map.forall(map.apply(reader(filename),f.count),f.sum)


        define('map.add(map,val)entry')                 :(map.add.end)

*	NOTE: should move this to seq.sbl
map.add

	entry = (map.size(map) = map.size(map) + 1,val)
	map.put(map,map.size(map), val)		
	map.add = entry					:(return)

map.add.end

	define('map.apply(map,f)entry,pair,map.apply.result')	:(map.apply.end)

*	_map.apply_ returns the map obtained by applying _f- to each entry in _map_.
*       If _f_ is a string, it is evaluated using _eval_; otherwise _f_is called
*       as a function.
*	_map.apply_ returns a pair, where the first component in the new entry,
*	and the second argument is a value defined by the previous use of apply to _f_.
*	This allows the computation of a value defined by the iteration.

map.apply

	map.apply.map = map.map(map.size(map))
	map.loop(map)
	result =

map.apply.next

	entry = map.next(map)				:f(map.apply.done)
	pair = pair(map.apply.entry(entry,result))
	map.put(map.apply.map,first(pair), second(pair)):(map.apply.next)

map.apply.done

	map.apply = pair(map.apply.map,map.apply.result)	:(return)

map.apply.end

	define('map.apply.entry(f,entry)')		:(map.apply.entry.end)

*	Return a pair entry as follows:

*	If _f_ is a string, eval(f) must evaluate to a pair defining
*	new entry.

*	If _f_ is a function, then _f(entry)_ must return a pair
*	defining the new entry.

*	In either case, the first element of the pair is set to the
*	value returned above.

map.apply.entry
map.apply.entry.end

        define('map.domain(entry)')			:(map.domain.end)

*       Return set with the keys in _map_.
*	NOTE: SHould this be in set.sbl ?

map.domain

	map.domain = map.new(map.size(map))
        map.loop(map)

map.domain.next

        entry = map.next(map)                           :f(return)
        map.add(map.domain,ent)                         :(map.domain.next)

map.domain.end


	define('map.equal(map,omap)pair')		:(map.equal.end)

*	Test two maps for equality. 

*	Two maps are equal if they have the same size and the value 
*	of the first map for each element in its domain is the same 
*	as the value of the second map for the corresponding element.

map.equal

	eq(map.size(map),map.size(omap))		:f(return)
	map.loop(map)

map.equal.next

	entry = map.next(map)				:f(map.equal.done)
	key = key(entry)
	valu = val(entry)
	ident(value(map.get(map,key(entry))),
.         value(map.get(omap,key(entry)))) :s(map.equal.next)f(return)

map.equal.done

	map.equal = true				:(return)

map.equal.end
	
        define('map.forall(f,map)entry')		:(map.forall.end)

*	_map.forall_ returns a result defined by iterating over all the
*	entries in _map_. In each step of the iteration, _map.apply.entry_
*	is evaluatedl using the current entry and the latest value of the
*	result. 
*	_map_forall_ returns the last value so defined.
*	_map.forall_ returns a new map defined by iterating over _map_
*	and using _f_ to define each entry by calling _map.apply.entry_.


*	For example, the length of the largest key of a map on strings could
*	be found by having each call set resuslt to the length of the largest key so far seen.

map.forall

        map.forall = map(map.size(map))
        map.loop(map)

map.forall.next

	map.put(map,map.apply.entry(f,map.next(map)))	 :s(map.forall.next)

	map.forall = result				:(return)

map.forall.end

        define('map.foreach(map,f)entry,pair')               :(map.foreach.end)

*        Returns a map defined by iterating over the entries in _map_, and applying
*        f to the entry to define a new entry in the result.

map.foreach

        map.foreach = map(map.size(map))

map.foreach.next

        pair = first(apply(f,map.next(map)))                    :f(return)
        map.put(map.foreach, entry.first(pair),second(pair))	:(map.foreach.next)

map.foreach.end

        define('map.get(key,val)')                  :(map.get.end)

*       Gets the value of the key _key_ in the map _map_.

map.get

        map.get = map.table(map)[key]                   :(return)

map.get.end

	define('map.inverse(map)entry')			:(map.inverse.end)

*	_map.inverse_ returns the inverse of a map. The inverse is
*	a map with the keys and values of _map_ reversed. 
*	_map.inverse_ fails if there are two instances of the same
*	value in the range of the map.

map.inverse

	map.inverse = map.map(map.size(map))
	map.loop(map)

map.inverse.next

	entry = map.next(map)				:f(return)
	differ(map.get(map.inverse,value(entry)))	:s(freturn)
	map.put(map.inverse,value(entry), key(entry))  :(map.inverse.next)

map.inverse.end

        define('map.loop(map,kind)')                    :(map.loop.end)
*TODO*
*       Returns an iterator for _map_. Use _map.next_ to retrieve
*       the next entry in map. _map.next_ fails when no more entries remain.

*       _kind_ gives the kind of loop:

*               '+order'        iterate in order in which entries added. (default)
*               '-order'        iterate in reverse order in which entries added.
*               '+key'          iterate in incresing values of keys.
*               '-key'          iterate in decceasing values of keys.
*               '+val'          iterate in incresing values of values.
*               '-key'          iterate in decreasing values of keys.

*       Otherwise iterate over the keys in the order in which they were added to the map.

map.loop

        map.next(map) = 0
        ident(kind)                                     :s(map.loop.order)
        ident(kind, '+order')                           :s(map.loop.key.order.inc)
        ident(kind, '-order')                           :s(map.loop.key.order.dec)
        ident(kind, '+key')                             :s(map.loop.key.inc)
        ident(kind, '-key')                             :s(map.loop.key.dec)
        ident(kind, '+val')                             :s(map.loop.value.inc)
        ident(kind, '-val')                             :s(map.loop.value.dec)

map.loop.order.inc

        map.array(map) = convert(map.table(map),'array'):(map.done)

map.loop.rorder.inc

        output = 'loop rorder not implemented '         :(nosuchlabel)
        map.array(map) = convert(map.table(map),'array'):(map.done)

map.loop.key.inc

        map.array(map) = rsort(map.table(map),1)        :(return)

map.loop.key.dec

        map.array(map) = sort(map.table(map),1)         :(return)

map.loop.value.inc

        map.array(map) = rsort(map.table(map),2)        :(return)

map.loop.value.dec

        map.array(map) = sort(map.table(map),-2)        :(return)

map.loop.end

        define('map.new(init,n)i,key,str,valr')         :(map.new.end)

*       Create a new map.

*       A sequence is a list of values *  separated by spaces.

*               map       _init_ is a list consisting of a list of key/value pairs,
*			
*                               with a colon (:) between the key and value.

map.new

        map.new = ident(init) map(table(128))           :s(return)
        kind = ident(kind) 'map'
        kind
        output = 'enter map.new [' init ']'
        init break(':')                                	:s(map.new.keyval)
        map.new = map(table(i))                         :(return)

map.new.keyval
        
        map.new = map(table(128))

map.new.keyval.next

        init break(':') . key ':' break(' ') . val span(' ') =	:f(return)
        map.put(map.new,key,val)                        :(map.new.keyval.next)

map.new.end

        define('map.next(map)')                         :(map.next.end)

*       _map.next_ returns the next entry in a map, or fails if no entries remain.

map.next

        le(map.next(map) = map.next(map) + 1, map.size(map)):f(freturn)
        map.next = entry(map.array[map.next(map),1],map.array[map.next(map),2]):(return)

map.next.end

