*       Copyright 2017 Dave Shields

*       The software is licensed under the MIT license, a copy of which can be
*       found in the file LICENSE>


-include "setl4.stl"
-include "util.stl"

*   Extracts the comments from standard input, look for use of markdown format
*   and write the output to standard output.

*   This is a first cut. It is not yet working.


*       Translate define() statements to show function name and arguments in 
*       markdown format

*       Utility functions.

    define('empty(line)')                           :(empty.end)

*       Test if line is empty (null or all blanks).

*EMPTY*
empty

*   Note that, in many cases, the first character in line is not null,
*	so first test so see if that is the case for the current line.

    ident(line)                                     :s(return)
    differ(substr(line,1,1),' ')                    :s(freturn)
    line span(whitespace) =
    ident(line)                                     :s(return)f(freturn)

empty.end

*       Main program

    define('main()i,line,last,name,p,rest,w,word')             :(main.end)

*MAIN*
main

*       Main program.

    &anchor = &trim = 1

	&dump = 3
	tab = char(9)
	whitespace = ' ' tab

*       _g.lines_ is a table that holds the lines read.
*	_g.lines.n_ is the number of lines in _g.lines_.
*	_g.pos_ is the index in _g.lines_ of the current line.

    g.lines = table()
	g.lines.n = g.lines.pos = 0

	output = 'start reader'
	read()
	output = 'end reader'
 	read()
	terminal = g.lines.n ' lines read.'

loop.l

    le(i = i + 1, g.lines.n)			:f(return)
    line = line()
	output = 'scanning [' line ']'
    words = words(line)
    w = 0
loop.w

    p = words[w = w + 1,1]				:f(loop.l)
    word = words[w,2]
    output = lpad(w,3) ' ' word                     :(loop.w)

    
main.copy

*       Only output first in a run of blank lines.

    line = line()					:f(return)
    empty(line) empty(last)                         :s(main.next)
    output = line
    last = line

main.next
    line = line()                                  	:f(main.done)
    ident(line)                                     :s(main.copy)
    line '*'                                        :s(main.comment)
    line span(' ') "define('"  =            :f(main.next)
    line "define('" rem . rest = rest
    line break('(') . name '()' rem . rest = tab name '()'  :s(main.copy)
    line break('(') . name 
.       '(' bal . args rem . rest = tab name '(' args ')' :(main.copy)

main.comment

    line '*' =
    line tab =

main.comment.word

    oline = line
    line breakx(&ucase) . first span(&ucase) . word rem . rest =
.               '*' first '_' lcase(word) '_' rest      :f(main.copy)
    line = eq(size(word),1) oline                   :s(main.copy)f(main.comment.word)

main.done
							:(return)
main.end

	main()
*       
*END*
end
