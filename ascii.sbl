*       Copyright 2017, David Shields
*       Licensed under the MIT license.

*       This file extends SPITBOL by adding support for creating and operating
*       on maps.

*	Defines:	ascii(line)
*	Defines:	ascii.init(init)

*	Uses:		Map
        define('ascii(line)c,n,name,nul,num,pos')       :(ascii.end)

*       Return the text of line with every ascii character identified.

*ASCII*
ascii
        nul = substr(&alphabet,1,1)

ascii.next
        
*       Add space after previous character if result not null.

        ascii = differ(ascii) ascii ' '
        c = substr(line,1,1)                            :f(ascii.done)
        ident(c,nul)                                    :s(ascii.null)
*       output = 'ascii c[' c ']'
        line any('0123456789')                          :s(ascii.integer)
        line any(&lcase &ucase)                         :s(ascii.letter)
        line ' '                                        :s(ascii.space)

*       Check for control character (code <=26)

        &alphabet break(c) . pos                        :f(ascii.other)
        pos = size(pos) 
*       output = 'pos of [' c '] is [' pos ']'
        gt(pos,26)                                      :s(ascii.other)
        ascii = ascii g.ascii.name[c] '(^'  substr('ABCDEFGHIJKLMNOPQRSTUVWXYZ',pos,1) ')' 
        line len(1) =                                   :(ascii.next)

ascii.integer

        line span('0123456789') . text =
*       output = 'ascii num [' text ']'
        ascii = ascii  text                             :(ascii.next)

ascii.letter

        line span(&lcase &ucase) . text =
*       output = 'ascii letter [' text ']'
        ascii = ascii  text                             :(ascii.next)

ascii.null

        ascii = ascii 'NUL'                             :(ascii.next)

ascii.other
                
*       Here if none of the other cases apply, so just list the ascii name.

        ascii = ascii g.ascii.name[c]                   
        line = substr(line,2)                           :(ascii.next)

ascii.space

        line span(' ') . text =
*       output = 'ascii space [' text ']'
        
        ascii =  ascii 'SPC'
        ascii = gt(size(text),1) ascii 'SPC*' size(text)
        ascii = ascii 
                                                        :(ascii.next)
ascii.done

        ascii = trim(ascii)                             :(return)

ascii.end

        define('ascii.init(init)name,val')              :(ascii.init.end)

*       Initialize maps for use by _ascii_.
*       Since space (ascii 32) prints as space, use the name SPC for 32.

*ASCII.INIT*
ascii.init


        ascii.init = map.map(
.       '0:NUL 16:DLE 48:0 64:@ 80:P 96:`:112:p '
.       '1:SOH 17:DC1 33:! 49:1 65:A 81:Q  97:a 113:q '
.       '2:STX 18:DC2 34:" 50:2 66:B 82:R  98:b 114:r '
.       '3:ETX 19:DC3 35:# 51:3 67:C 83:S  99:c 115:s '
.       '4:EOT 20 DC4 36:$ 52:4 68:D 84:T 100:d 116:t '
.       '5:ENQ 21:NAK 37:% 53:5 69:E 85:U 101:e 117:u '
.       '6:ACK 22:SYN 38:& 54:6 70:F 86:V 102:f 118:v '
.       "7:BEL 23:ETB 39:' 55:7 71:G 87:W 103:g 119:w "
.       '8:BS  24:CAN 40:( 56:8 72:H 88:X 104:h 120:x '
.       '9:HT  25:EM  41:) 57:9 73:I 89:Y 105:i 121:y '
.       '10:LF 26:SUB 42:*:58 : 74:J 90:Z 106:j 122:z '
.       '11:VT 27:ESC 43:+:59 ; 75:K 91:[ 107:k 123:{ '
.       '12:FF 28:FS  44:,:60 < 76:L 92:\ 108:l 124:| '
.       '13:CR 29:GS  45:-:61 = 77:M 93:] 109:m 125:} '
.       '14:SO 30:RS  46:.:62 > 78:N 94:^ 110:n 126:~ '
.       '15:SI 31:US  47:/:63 ? 79:O 95:_ 111:o 127:DEL ' 

        g.ascii.name = map.map(128)
        g.ascii.val = map.map(128)
        

	map.loop(ascii.init)

ascii.init.next

	ent = map.next(ascii.init)			:(ascii.init.finis)
	g.ascii.name[substr(&alphabet,+v + 1,1] = name
	g.ascii.val[name] = +val			:(ascii.init.next)


*       Correct entry for 32 to be SPC, the space character
*       Correct entry for 0 to be NUL, the NUL character

        g.ascii.name[] = 'NUL'
        g.ascii.val['NUL'] = 0  
        g.ascii.name[' '] = 'SPC'
        g.ascii.val['SPC'] = 32                         :(return)
        
ascii.init.end

