
    define('add(set,elem)')                     :(add.end)

*   Add _elem_ to set _set_ if not already present.
*   A set is represented as a map from the elements to themselves,
*   the identity map.

add

    put(set,elem,elem)                          :(return)

add.end

    define('defined(map,key)entry')             :(defined.end)

*   Tests if the map _map_ has an entry for _key_.

defined

    entry = set.key(map)
    differ(entry)                               :s(return)f(freturn)

defined.end

    define('set.difference(a,b)elem')               :(set.difference.end)

*   Returns set defined by set of elements of _a_ that are not in _b_.

difference

    set.difference = a @ !'set.member(=a,b)'       :(return)

difference.end

    define('from(set,elem)this')                    :(from.end)

*   Return set consisting of all the elements of _a_ except _elem_.

from

    from = set.copy(set)
    loop(set)

from.next

    this = next(set)                               :f(return)
    ident(this,elem)                               :s(set.from.next)
    add(set.from,this)                         :(set.from.next)

from.end

    define('domain(map)elem)')                 :(domain.end)

*   Return set of the keys in _map_.

domain

    domain = set.new()
    loop(map)

domain.next

    entry = next(map)
    ident(value(entry))                         :s(domain.next)
    add(domain,key(key(next(map))))             :s(domain.next)f(return)

domain.end

    define('get(map,key)val)id')                :(get.end)

*   Gets the value of the key _key_ in the map _map_.

get

    id = set.key(map)[key]
    ident(id)                                       :s(return)
    get = value(set.index(map)[id])             :(return)

get.end

    define('set.integers(n)i')                      :(set.integers.end)

*   Return set containing integers 1 .. _n_

integers

    set.integers = set.new(n)
    i = 0

integers.next

    gt(i = i + 1,n)                                 :s(return)
    add(set.integers,i)                         :(set.integerl.next)

integers.end

    define('set.intersection(a,b)elem')             :(set.intersection.end)

*   Returns intersection of sets _a_ and _b_.

intersection

*   Make _a_ the smaller set.

    le(set.size(a),set.size(b))                     :s(set.intersection.next)
    set.intersection = a
    a = b
    b = set.intersection
    set.intersectino = set.new('set')
    loop(a)

intersection.next

    next(a)                                         :f(return)
    set.member(=a,b)                                :f(set.intersection.next)
    add(set.intersection,=a)                    :(set.intersection.next)

intersection.end

    define('put(map,key,value)v')               :(put.end)

*   Sets the value of the entry for key _key_ in map _map_ to be _val_,
*   creating a new entry if necessary.
*   _value_ is null to add an entry to a set.

put

    value = ident(value) key
    key = integer(key) +key
    value = integer(value) +value
    v = set.key(map)[key]
    differ(v)                                       :s(put.value)

*   Here to create new entry in map, and then merge to set new value.

    set.size(map) = set.size(map) + 1
    set.key(map)[key] = entry(key,value)

put.value

    set.key(map)[key] = entry(key,value)            :(return)

put.end

    define('range(map)elem)')                       :(range.end)

*   Return set of the keys in _map_.

range

    range = set.new()
    loop(map)

range.next

    entry = next(map)
    ident(value(entry))                             :s(range.next)
    add(range,value(key(next(map))))                :s(range.next)f(return)

range.end

    define('set.subset(a,b)member')                 :(set.subset.end)

*   Tests if _b_ is a subset of _a_.

subset

    set.subset = FALSE
    gt(set.size(b),set.size(a))                     :s(return)
    loop(b)

subset.next

    member = set.next(b)                            :f(set.subset.true)
    member(member,a)                                :s(set.subset.next)f(return)

subset.true

    set.subset = true                               :(return)

subset.end

    define('set.union(a,b)elem')                    :(set.union.end)

*   Returns union of sets _a_ and _b_.

union

*   Arrange so set a is the larger set.

    ge(set.size(a),set.size(b))                     :s(set.union.a)
    set.union = a
    a = b
    b = set.union

union.a

*   Make copy of a by making copy of a's table.

    set.union = copy(a)
    loop(b)

union.b

    elem = set.next(b)                              :f(return)
    add(set.union,elem)                         :(set.union.b)

union.end

