*       Copyright 2017 Dave Shields

*       The software is licensed under the MIT license, a copy of which can be
*       found in the file LICENSE>

*       MARKUP

*       Translate comments, translating words enclosed in underscores,
*       or in upper case, to markdown italic format. 

*       Translate define() statements to show function name and arguments in 
*       markdown format

*       Utility functions.

        define('empty(line)')                           :(empty.end)

*       Test if line is empty (null or all blanks).

*EMPTY*
empty

*       Note that, in many cases, the first character in line is not null,
*	so first test so see if that is the case for the current line.

        ident(line)                                     :s(return)
        differ(substr(line,1,1),' ')                    :s(freturn)
        line span(whitespace) =
        ident(line)                                     :s(return)f(freturn)

empty.end

        define('lcase(s)')                              :(lcase.end)

*       Convert argument to lower case.

*LCASE*
lcase

        lcase = replace(s,&ucase,&lcase)                :(return)

lcase.end

	define('line()')				:(line.end)

*	Return next line from g.lines, fail if no more lines.

*LINE*
line

	le(g.lines.pos = g.lines.pos + 1,g.lines.n)	:f(freturn)
	line = g.lines[g.lines.pos]			
							:(return)

line.end

        define('read()line')             		:(read.end)

*       Read standard input to the end, saving all the lines read in _g.lines_.

*READ*
read

        output = gt(g.lines.n,3000) 'runaway read, quitting' :s(end)
	line = input					:f(return)
        g.lines.n = g.lines.n + 1
        g.lines[g.lines.n] = line			:(read)

read.end

        define('words(line)n,w,pos,i,sp')                  :(words.end)

*       Return array of the words in s, fail if no words.
*       The first entry for an array element is the starting index;
*       the second is the word itself.

*WORDS*
words

*       Make sure there is a blank to start off so initial span()
*       matches something, and also one at end to break to
*       in case last word extends to end of line.

        words = table(n)
	output = 'words [' line ']'
        line = ' ' line ' '
        pos = 0

words.sp

*       Account for blank(s) between words.

        line span(' ') . sp =

        ident(line)                                        :s(words.done)

*       Point to start of next word

        pos = pos + size(sp)

words.w

*       While it is customary to absorb the blank in the
*       usage below, we leave it in so there will be at least
*       one blank to satisfy span() when loop back to words.sp

        line break(' ') . w  =                             :f(words.done)
        words[pos] = w
	output = 'words pos [' pos '] is [' w ']'
        pos = pos + size(w)                             :(words.sp)

words.done

	output = 'words done'
        words = convert(words,'array')                  
	
							:(return)

words.end

*       Main program

        define('main()i,line,last,name,p,rest,w,word')             :(main.end)

*MAIN*
main

*       Main program.

        &anchor = &trim = 1

	&dump = 3
	tab = char(9)
	whitespace = ' ' tab

*       _g.lines_ is a table that holds the lines read.
*	_g.lines.n_ is the number of lines in _g.lines_.
*	_g.pos_ is the index in _g.lines_ of the current line.

        g.lines = table()
	g.lines.n = g.lines.pos = 0

	output = 'start reader'
	read()
	output = 'end reader'
 	read()
	terminal = g.lines.n ' lines read.'

loop.l

        le(i = i + 1, g.lines.n)			:f(return)
        line = line()
	output = 'scanning [' line ']'
        words = words(line)
        w = 0
loop.w

        p = words[w = w + 1,1]				:f(loop.l)
        word = words[w,2]
        output = lpad(w,3) ' ' word                     :(loop.w)

        
main.copy

*       Only output first in a run of blank lines.

        line = line()					:f(return)
        empty(line) empty(last)                         :s(main.next)
        output = line
        last = line

main.next
        line = line()                                  	:f(main.done)
        ident(line)                                     :s(main.copy)
        line '*'                                        :s(main.comment)
        line span(' ') "define('"  =            :f(main.next)
        line "define('" rem . rest = rest
        line break('(') . name '()' rem . rest = tab name '()'  :s(main.copy)
        line break('(') . name 
.       '(' bal . args rem . rest = tab name '(' args ')' :(main.copy)

main.comment

        line '*' =
        line tab =

main.comment.word

        oline = line
        line breakx(&ucase) . first span(&ucase) . word rem . rest =
.               '*' first '_' lcase(word) '_' rest      :f(main.copy)
        line = eq(size(word),1) oline                   :s(main.copy)f(main.comment.word)

main.done
							:(return)
main.end

	main()
*       
*END*
end
* This is start
	define('start(pid)player,tiles,perm,perms,permi,free,offset,i,'
.       	'highest,lower,best,n,word,start,score,move,max'):(start.end)

*	Determine best starting.turn. At least one letter in this move
*	must be in the center square (8,8). The only bonus available is
*	double word, for any word of more than four characters.

*	Find the move the highest score. Given two moves with the
*	same score, prefer the one with the lowest tile cost.
*
*	The return value has the form 'm s' where m is the move
*	and s is its score.
*
*	There are seven tiles, so we just try all permutations
*	of length one up to seven.

*START*
start

	max = 7;* maximum number of tiles to play
	player = g.players[pid]
	tiles = rack(player)
	n = 0;* number of tiles to play
	highest = lowest = 0;* best score, lowest cost

*	Assume word will start in column 8

	start = 8

*	Don't use 's' on starting move: save it for later.

	tiles break('s')				:f(start.n)
	tiles = less(tiles,'s')
	max = max - 1

start.n	gt(add1(.n),max)				:s(start.done)

	kind = size(tiles) '?' n
*	out('start.n kind=' kind)
	perms = g.permutations[kind]			:f(start.n)
	permi = 0

start.word

*	Get next word, check that valid, then see if new high score

	perm = perms[add1(.permi)]			:f(start.n)
	word = replace(perm,substr('1234567',1,size(tiles)),tiles)

*	out('kind ' kind ' perm ' perm ' word ' word)
	checkword(word)					:f(start.word)
	add1(.checkwords)

*	Score is the value of the tiles unless the word has five or
*	more characters, in which case the double word bonus
*	at index twelve can be achieved.

	score = (lt(size(word),5) cost(word), 2 * cost(word))

*	See if get bonus for playing seven tiles.

	score = eq(size(word),7) score + 35

**	Add the first word found to set HIGHEST and *lowest*

	eq(highest,0)					:s(start.new)

	lt(score,highest)				:s(start.word)
	gt(score,highest)				:s(start.new)

*	Here if current best and new move have same score.
*	Prefer the one with the lowest cost.

	lt(cost(word),lowest)				:s(start.new)

start.new

	highest = score
	lowest = cost(word)
	best = word
							:(start.word)
start.done

*	Start word at position 8, unless word size greater than
*	five, in which case move it to the left, but making sure
*	move still covers double-word cell at position twelve.

	offset = (lt(size(best,5) 0, 5 - size(best)))

*	Initialize free array for move.

	free = array(size(best))
	i = 0

start.free

	free[add1(.i)] = 7 + i  + offset		:s(start.free)

	start = move(8 + offset,free,best,highest) :(return)

start.end
