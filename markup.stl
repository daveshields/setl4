*       Copyright 2017 Dave Shields

*       The software is licensed under the MIT license, a copy of which can be
*       found in the file LICENSE>

*       MARKUP

*       Translate comments, translating words enclosed in underscores,
*       or in upper case, to markdown italic format. 

*       Translate define() statements to show function name and arguments in 
*       markdown format

*       Utility functions.

        define('empty(line)')                           :(empty.end)

*       Test if line is empty (null or all blanks).

*EMPTY*
empty

*       Note that, in many cases, the first character in line is not null,
*	so first test so see if that is the case for the current line.

        ident(line)                                     :s(return)
        differ(substr(line,1,1),' ')                    :s(freturn)
        line span(whitespace) =
        ident(line)                                     :s(return)f(freturn)

empty.end

        define('lcase(s)')                              :(lcase.end)

*       Convert argument to lower case.

*LCASE*
lcase

        lcase = replace(s,&ucase,&lcase)                :(return)

lcase.end

	define('line()')				:(line.end)

*	Return next line from g.lines, fail if no more lines.

*LINE*
line

	le(g.lines.pos = g.lines.pos + 1,g.lines.n)	:f(freturn)
	line = g.lines[g.lines.pos]			
							:(return)

line.end

        define('read()line')             		:(read.end)

*       Read standard input to the end, saving all the lines read in _g.lines_.

*READ*
read

        output = gt(g.lines.n,3000) 'runaway read, quitting' :s(end)
	line = input					:f(return)
        g.lines.n = g.lines.n + 1
        g.lines[g.lines.n] = line			:(read)

read.end

        define('words(line)n,w,pos,i,sp')                  :(words.end)

*       Return array of the words in s, fail if no words.
*       The first entry for an array element is the starting index;
*       the second is the word itself.

*WORDS*
words

*       Make sure there is a blank to start off so initial span()
*       matches something, and also one at end to break to
*       in case last word extends to end of line.

        words = table(n)
	output = 'words [' line ']'
        line = ' ' line ' '
        pos = 0

words.sp

*       Account for blank(s) between words.

        line span(' ') . sp =

        ident(line)                                        :s(words.done)

*       Point to start of next word

        pos = pos + size(sp)

words.w

*       While it is customary to absorb the blank in the
*       usage below, we leave it in so there will be at least
*       one blank to satisfy span() when loop back to words.sp

        line break(' ') . w  =                             :f(words.done)
        words[pos] = w
	output = 'words pos [' pos '] is [' w ']'
        pos = pos + size(w)                             :(words.sp)

words.done

	output = 'words done'
        words = convert(words,'array')                  
	
							:(return)

words.end

*       Main program

        define('main()i,line,last,name,p,rest,w,word')             :(main.end)

*MAIN*
main

*       Main program.

        &anchor = &trim = 1

	&dump = 3
	tab = char(9)
	whitespace = ' ' tab

*       _g.lines_ is a table that holds the lines read.
*	_g.lines.n_ is the number of lines in _g.lines_.
*	_g.pos_ is the index in _g.lines_ of the current line.

        g.lines = table()
	g.lines.n = g.lines.pos = 0

	output = 'start reader'
	read()
	output = 'end reader'
 	read()
	terminal = g.lines.n ' lines read.'

loop.l

        le(i = i + 1, g.lines.n)			:f(return)
        line = line()
	output = 'scanning [' line ']'
        words = words(line)
        w = 0
loop.w

        p = words[w = w + 1,1]				:f(loop.l)
        word = words[w,2]
        output = lpad(w,3) ' ' word                     :(loop.w)

        
main.copy

*       Only output first in a run of blank lines.

        line = line()					:f(return)
        empty(line) empty(last)                         :s(main.next)
        output = line
        last = line

main.next
        line = line()                                  	:f(main.done)
        ident(line)                                     :s(main.copy)
        line '*'                                        :s(main.comment)
        line span(' ') "define('"  =            :f(main.next)
        line "define('" rem . rest = rest
        line break('(') . name '()' rem . rest = tab name '()'  :s(main.copy)
        line break('(') . name 
.       '(' bal . args rem . rest = tab name '(' args ')' :(main.copy)

main.comment

        line '*' =
        line tab =

main.comment.word

        oline = line
        line breakx(&ucase) . first span(&ucase) . word rem . rest =
.               '*' first '_' lcase(word) '_' rest      :f(main.copy)
        line = eq(size(word),1) oline                   :s(main.copy)f(main.comment.word)

main.done
							:(return)
main.end

	main()
*       
*END*
end
