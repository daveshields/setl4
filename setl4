
*       Copyright 2017, David Shields
*       Licensed under the MIT license.

*# SETL4 - An Implementation of SETL Written in SPITBOL


*## What is SPITBOL?

*       SNOBOL is a general purpose programming language with special emphasis
*       on processing strings and text that was developed at Bell Labs in the
*       1960's by a team led by Ralph Griswold. The final version was called SPITBOL4.

*       Macro SPITBOL, or SPITBOL, is a very efficient implementation of SNOBOL4.
*       Created by Robert B. K. Dewar and Ken Belcher in 1969, SPITBOL/360
*       was written in IBM/360 assembly language, in a style Dewar termed
*       "aggressive assembly." That is, using every trick in the book to write
*       the fastest, most compact, code possible.
*
*       For example, SNOBOL4 requires maintaining a count of the number of
*       statements executed and the ability to stop execution when a specified
*       number of statements have been executed.  SPITBOL/360 does this by
*       computing an unnormalized floating point constant such that successive
*       increments of it result in floating point overflow when the limit is reached.

*       Dewar and Belcher also wrote Realia COBOL, a COBOL compiler for Intel/x86
*       written in COBOL. It produced very efficient code, better code than,
*       for example, that produced by IBM's product COBOL compiler.

*       Dewar ported SPITBOL/360 to several machines. Dewar joined the faculty
*       of the Courant Institute of Mathematical Sciences (CIMS) of New York
*       University (NYU) as a Professor in the early 1970's. In 1973,
*       while working with Anthony P. "Tony" McCann of Leeds University,
*       Dewar created Minimal, a portable assembly language. Dewar and
*       McCann then rewrote SPITBOL in Minimal, resulting in Macro SPITBOL,
*       or SPITBOL. The implementation has proved very stable, with only
*       minor changes in the last several decades.

*       Macro SPITBOL is remarkably small. The code consists of about 28,000
*       lines: 2000 lines of comments defining Minimal, 5000 lines of constant/data
*       declarations, and 21,000 lines of code.  Every line of code has a comment.
*       The executable for x86 Linux is less than 150 kilobytes.

*       SPITBOL was implemented for several machines and operating systems by
*       a small team that included Steve Duff, Mark Emmer, Bob Goldberg, and Dave Shields:
*       ICL 1900, Univac, CDC 6600, IBM PC, Apple Macintosh, SUN Solaris Sparc,
*       Microsoft (DOS/NT/Windows), Intel x86_64 (Unix/Linux), and x86_64 Apple iOS.
*       Special credit is due Mark Emmer, who led the project from the mid 1980's
*       to 2009, when Dave Shields became the maintainer of SPITBOL.

*       SETL4 requires a modified version of standard SPITBOL called SPITBOL4.
*       SPITBOL4 differs from standard SPITBOL as follows:
*
*-  There is no automatic case folding. In standard SPITBOL the names 'x' and 'X' are the same;
*       they are different in SPITBOL4.
*-  The default case is lower case.
*-  The function _set()_ has been renamed to _zet_, so that _set_ can be used as an identifier.
*-  The default value of _&anchor_ is 1. The default value of _&trim_ is 1.

*       The file `bin/setl4' provided as part of the distribution is the executable for _spitbol4_.

*## What is SETL?

*       SETL (SET Language)  is  a programming language with  finite sets as
*       the fundamental data type. It was created by Jacob T. "Jack" Schwartz
*       of the Courant Institute of Mathematical Sciences (CIMS) of New York
*       University (NYU).

*       Jack founded the SETL project in 1970. It was later funded by two
*       five-year grants from the Office of Naval Research.

*       SETL was used to write NYU Ada/Ed, the first validated Ada compiler.
*       Devloped on the DEC Vax 11/780, Ada/Ed was ported to the IBM PC (DOS)
*       by a team led by Dave Shields.


*## Why the name SETL4?

*       The SETL Project produced three implementations of SETL. The first was
*       written by Dave Shields in BALM, a language developed by Prof. Malcom
*       Harrison of CIMS, the second by Henry S. "Hank" Warren in PL/I while on
*       leave from IBM, and the third by Robert B. K. Dewar and Art Grand in LITTLE,
*       a low-level implementation language developed at CIMS.

*       SETL4 is the fourth implementation of SETL produced during the course of
*       the SETL Project.  Dave Shields wrote the first implementation. This was
*       followed by two more implementations. This is the fourth implementation
*       written by a member of the SETL project,  hence the name SETL4.


*## Brief Introduction to SETL4

*       SETL4 extends SPITBOL by adding the datatype _set_ to represent finite sets.

*       A set is a collection of distinct elements: for example,  _{a,b,c}_ is a set,
*       as is _{a,b,c,a}_; however, _{a,b,c,a}_ has only three elements, and is
*       equal to _{a,b,c}_.

*       For example, the folowing SETL4 expression determines if the integer _P_ is prime:

*               !exists(|'int 2 P' @ 'multiple(P,this)')

*       where _multiple(a,b)_ is true if and only if _a_ is a multiple of _b_.

*## Sets in SETL4

*       SETL4 provides several kinds of sets.

*       Sets of kind 'set' are a collection of distinct members.

*       Sets of kind 'map' consist of a series or ordered pairs,
*       called entries. The first element of an entry is the key,
*       and the second is the value.  No two entries in the map can
*       have the same key but different values.

*       Sets of kind 'iterator' consist of  integers of the form
*```
*       low, low + step, ... high
*```

*       or

*```
*       high, high - step ... low
*```

*       If only _low_ is specified, then the iteator is interpreted as 'iterator 1 low'.
*       For example, 'iterator 100' is the set 1, 2, ... 100.
*       and 'iterator 5 25 5' is the set {5 10 15 20 25}; where
*       iteration over the iterator will go in order 5, 10 ... 25.
*       'iterator 25 5 -5' is the same set; but iteration will
*       go in the order 25,20 ... 5.
*
*       If _high_ is less than _low_, then a negative step is undersood,
*       even if it is given as a positive value. For example, both
*       `iter 25 5 -5` and `iter 25 5 5' go in order "25, 20 ... 1"

*       Iterators support efficient iteration, but they provide only
*       the operations of iteration and membership; you cannot
*       add or remove an element from an iterator.

*       Sets of kind 'integer' are intended or sets of integers
*       containing many elements. See below for more details.

*       A sequence is a map defined on a set of consecutive positive integers.
*       For example 'sequence 5' is a map defined on 1, 2, ... 5.

*       Sequences are represented in the same way as a map. They differ from a map only
*       in that iteration over a sequence returns the values of the sequence, not the
*       instances of _entry_ that are returned when iterating over a map.

*       By convention, the kinds are writtten 'int', 'iter', 'map', 'seq', and 'set'.


*## Set Data Type

*       A set is a collection unequal objects, and is represented in SETL4 by the datatype _set_:

        data('set(set.kind,set.iter,set.index,set.key,set.size,set.encloser,'
.       'set.block,set.blocks,set.offset,set.str)')

*       where

*- _set.kind_          is the kind of the set: 'integer', 'iterator', 'map', 'sequence', or 'set'.
*                          The kind is specified when the set is created. The default kind is 'set'.
*                          The kinds are abbreviated below as:'int', 'iter', 'map', 'seq', or 'set'.

*- _set.iter_ iterator for controlling iteration over the set.

*- _set.index_         SPITBOL table used to map the integer id assigned
*                          each element to the value of the element.
*                           It is needed to support iteration.

*- _set.key_  SPITBOL table mapping set elements to index entries.

*- _set.size_          the current number of members.

*- _set.encloser_      characters used to enclose value when showing this set


*       The following fields are used only for sets of kind 'int':

*- _set.block_         block

*- _set.blocks_        number of blocks

*- _set.offset_        offset within block corresponding to a given integer

* _set.str_            is used to update the current block's membersip string
*                          for sets of kind 'init'


*       New elements in the set are assigned an integer id. The table _set.index_
*       maps the id to a key; it is used to iterate over the set. The table
*       _set.key_ maps a key to its associated value; it is used to retrieve element values.

*## Sets of integers

*       SETL4 sets of kind _integers' provide an efficient implementation of a set with
*       many non-negative integers, such as  a set with more than a million integers.
*
*       The set is represented by a table of strings, each with  _setl4.config.int_ characters,
*       so that the first block represents the integers `0 .. _setl4_config.int_ -1 and so forth.
*       Addition to  the set is done by setting the appropriate character in a block to '+'.
*       New blocks are allocated only when necesary.

*       The SPITBOL function BREAK is used to find the next element
*       in the set when iterating over the set.

*## Ordered Pairs

*       In set theory, sets are not ordered. The set _{a,b}_ is the same as (equal to)
*       the set _{b,a}_.

*       Although sets are not ordered, sets can be used to define an ordered pair:

        data('pair(first,second)')

*       by defining _pair(a,b)_ to be
*
*           _{a,{a,b}}_
*
*       It is easy to prove that, given this definition, _pair(a,b)_ is equal
*       to _pair(c,d)_ if and only if _a_ is equal to _c_ and _b_ is equal to _d_.


*## Maps

*       A map defined on a finite set is a set of ordered pairs,
*       or entries, that define a relation between the first element of an entry,
*       its _key_, and the second element of the entry, the value of the map for _key_.

        data('entry(key,value)')

*       A set of ordered pairs is a map if and only if there do not exist two entries
*       _entry(a,b)_ and _entry(c,d)_ such that _a_ is equal to _c_ and _b_ is not equal to _d_.
*       For example, the map defined by the set _{[one,1],[2,two],[one,1]}_ is valid, but
*       one cannot define a map based on the set _{[one,1],[2,two],[one,3]}_.

*       However, SETL4 does allow the use of a set of pairs that would not
*       be allowed in stanard set theory to define a map. If two of more pairs
*       have the same first value, the the last such pair encountered defines the
*       value to be used. For exampe, the set _{entry(one,1),entry(2,two),entry(one,3)}_ produces
*       the same map as _{entry(one,3),entry(2,two)}_.

*       Though you can use _entry to give a key and its associated value, the
*       preferred convention is separate a key and its value with a colon.
*       allows you to write "key:value,"
*```
*           new('map' one:1 two:2 three:3')

*```

*       instead of

*```
*           new('map' entry('one',1) ' ' entry('two',2) ' ' entry('three',3) )
*```

*       Though in set theory, maps are defined in terms of sets, in the SETL4
*       implementation, sets are represented are maps, by mapping each element
*       to itself. For example, the set _{a,b,c}_ is kept as the map: {a:a,b:b,c:c}.

*       SETL4 supports adding entries to a set of kind _map_ by using the
*       key and value in the entry to define the value of the map for _key(entry)_
*       to be _value(entry)_.

*       The SPITBOL datatype TABLE provides the machinery to implement maps.
*       SPITBOL provides no way to determine the number of entries in a table
*       other than converting the map to an array. This is the only way in
*       SPITBOL to iterate over a SPITBOL table.

*       For this reason, maps are implemented using two tables: _index_ and _key_.
*       Each new entry added to a map is given an integer id, starting with one.
*       The field _index_ maps the id's to the associated pairs.
*       The entries in _index_ allow efficient iteration over the
*
*       The table _key_ maps keys in the map to the corresponding entry in the map.
*       The entries in _key_ permit efficient retrieval of the map's value for a given key.

*       SETL4 supports stacks by implementing them as a sequence. The fuction
*       _push()_ pushes a value on to the stack; the function _pop_ removes the
*       top value.


*## Loops, Iterators

*       Loops in SPITBOL have the form of a test followed by the loop body,
*       with the body ending with a branch back to the test.

*  For example, here is a loop that prints the first one hundred integers:

*```
*test
*           i = i + 1
*           le(i,100)                       :f(done)
*           output = i                      :(test)
*done
*```

*       This can also be written as:

*```
*test
*           output = le(i = i + 1,100) i    :s(test)
*```

*       Loops in SETL4 are constructed using the _loop_ and _next_ statements.

*       A loop has the form:

*```
*           loop(set,thisname)
*
*       set.next
*           var = next(set)     :f(set.done)
*           out(this)           :(set.next)
*       set.done
*```

*       The first operand specifies of _loop_ gives the set or range of values
*       of the iteration.  The optional second argument names a variable that is
*       updated as part of successful call to _next_.  The name _this_ is used
*       if the second argument is not given. The _loop_ statement above can be
*       written as _loop(set)_ or also _loop(set,.this)_ or _loop(set,'this').
*
*       Loops can have a specific variable associated with a loop.

*```
*           loop(set,.this.s)
*           ...
*       set.next
*           next(set)           :f(set.done)
*           out(this.s)         :(set.next)
*       set.done
*```

*       The _loop_ statement creates an instance of _iterator_ to control the
*       iteration. The _next_ statement advances the iteration by producing the
*       next element or failing if no more elements remain.

*       See the functions _prime_ and _primes_ defined below to see _loop_
*       and _next_ in action. See also the code for _exists_ and _forall_.

*       SETL4 provides the datatype _iterator_ to control iteration over a
*       range of integers, over a set, or over a map.

        data('iterator(iter.next,iter.start,iter.finis,iter.step,iter.thisname,'
.                     'iter.block,iter.blocks,iter.offset,iter.str)')

*       where

*-  _iter.next      last value returned by the iterator.

*-  The following fields are used to iterate over a range:

*-  _iter.start_    starting value for iteration

*-  _iter.finis_    finishing value for iteration

*-  _iter.step_     difference between values of an iteration

*-  _iter.thisname_ name of iteration variable to be update to iteration value

*## Showing Values

*       Use the function _show()_ to display the value of a SETL4 or SPITBOL object

*       Sets are listed with the values enclosed in '{}'.
*       Sequences of ten or fewer elements are listed with the
*       values enclosed in '()'. Sequences of more than ten elements
*       are listed with the index and value enclosed in '[]').
*       Pairs and entries are listed with the component values enclosed in '()'.

*## Additional Operations Provided as an Artifact of the Implementation

*       The use of the tables _set.index_ and _set.key_ to implement a set makes it
*       possible to provide some operations not available in in standard set theory.
*       For example, it is possible to retrieve elements using the function _get_.
*       _Get(s,i)_ retrieves the i-th element in the set.

*       The function _sorter_ can be used to determine the order in which the elements
*       of a set are accessed during an iteration, or to 'sort' the tables implementing
*       the set. For example, _sorter(s,'+v')_ sorts a map in increasing order of the
*       values of the map. _sorter(s,'-v')_ sorts the values in descendng order, and
*       so forth. For example, here is the code to find the ten members with
*       the largest values in a map:

*```
*           sorter(map,'-v')
*           largest = new('set')
*           iter = new('iter 1 10')
*           loop(set)
*
*       largest.add
*
*           add(largest,next(set))               :s(largest.add)
*```

*       _Sorter_ is used by the _show_ function to display the values of a set or
*       map in a standard order. For example, if _s_ is a set with the elements
*       'a', 'b' and 'c', then _show(s)_ yields `set 'a' 'b' 'c' }`, not
*       `set 'b' 'c' 'a' }`.

*## SETL4 Configuration Options

*       _setl4.config.channel.1_ is channel number for temporary files, that is,
*       files created on entry to a procedure and closed before returning from
*       the procedure.

        setl4.config.channel.1 = 3

*       Define initial sizes of tables when creating a set.

*       _setl4.config.set.table.size_ is default size for the _index_ and _key_ tables of a set.

        setl4.config.set.table.size = 1024
        setl4.config.set.table.size = 32000

*       _setl4.config.int.table.size_ is size of index and key tables in set of kind 'int.'

        setl4.config.int.table.size = 1000

*       _setl4.config.int_ is number of characters in the block for an integer set.
*       _setl4.config.int.init_ is string of spaces of size _setl4.config.int_.

        setl4.config.int = 1000
        setl4.config.int = 20
        setl4.config.int.init = dupl('-',setl4.config.int)

*## Additonal SETL4 data types

*       SETL4 provides the following data type in addtion to _set_:

*           _token_

*       where

*           token(lineno,ndx,type,text) is a lexeme, or lexical token.

*## SETL4  Operator Symbols

*       SETL4 provides the following operator symbols:
*
*       _#s_        returns the size of a string or set _s_
*       _x ~ s_     tests if _x_ is member of set _s_
*       _s @ e_     is equivalent to _filter(s,e)
*       _=s_        returns the value of the iteration variable (usually 'this') of a loop.

*       For example, _member(x,s)_ can be written _x ~ s_, _set.size(x)_ can be written
*       _#s_, and _filter(s,e)_ can be written _s @ e_.

*       Need to define _setl4.size_ before use of opsyn to allow use of '#'
*       as unary operator to return size of set or string.

        define('setl4.size(set)')                       :(setl4.size.end)

*       Setl4.set.size_ returns the  size of operand.

setl4.size

        setl4.size = ident(datatype(set),'string') size(set):s(return)
*       setl4.size = differ(iter.step(set)) (iter.finis(set) - iter.start(set) / iter.step(set)) + 1:s(return)
        setl4.size = set.size(set)                      :(return)

setl4.size.end

        opsyn('#','setl4.size', 1)

*## Sample data

*       Programs need data. Since SPITBOL is designed to analyze and manipulate text, SETL4 provides
*       a library consisting of several works chosen from the world's greatest literature, including
*       the works of William Shakespeare, a dictionary, and the text of the King James version
*       of the Bible. Except for the dictionary, all texts were obtained using Project Gutenberg.

*       As an extension of SPITBOL, SETL4 brings the raw power and speed of SPITBOL to the task
*       of working with text. Additional functions are provided, including a lexical scanner, or
*       tokenizer, to assist in performing deep, detailed analysis of textual structure.

*       Several of these functions have as their purpose the translation of text into sets, maps,
*       and sequences. For example, the tokenizer returns a sequence consisting of the tokens
*       in a line of text.

*       In order to be able to use the program ./examples/align.stl to align the
*       goto fields in the source, use the variable _char(58)_ where
*       the colon character enclosed in quotes would normally be used.

*## SETL4 Functions

*       SETL4 provides the following functions:
*
*-  add(set,elem)               Adds element to set.
*-  and(a,b)                    Tests if both operands are true.
*-  append(str,w,ch)            Appends _ch_ (or space if _ch_ is null) to _str_, then _w_
*-  arbitrary(n)                Returns arbitary (randomly chosen) integer in 1 .. _n_.
*-  arbitrary(set)              Returns arbitary (randomly chosen) element of _set_.
*-  assert(expr)                Tests that _expr_ is true, ends execution otherwise.
*-  binary(n)                   Returns string with value of _n_ in binary number.
*-  checkout(filename)          Returns ('checks out') set or map defined by a text file from the libary
*-  compare(a,b)                Compares two integers or strings, returning -1 (less), 0 (equal), or +1 (greater).
*-  compose(a,b)                Returns composition of two maps or tables.
*-  defined(map,key)            Tests if a map is defined for a specified key.
*-  difference(a,b)             Returns set of members of set _a_ not in the set _b_.
*-  domain(map)                 Returns set of elements in the domain of a map.
*-  equal(a,b)                  Tests if two SETL4 objects are equal.
*-  even(n)                     Tests if _n_ is even.
*-  exists(set,expr)            Tests if an expression is true for at least one element in a set.
*-  factorial(n)                Returns n!  = n * (n -1) * ... * 1.
*-  reduce(proc,file)	Filters a file by applying proc to each line. Default file is standard input.
*-  frequency(s)                Returns frequency of values in sequence, map or string _s_.
*-  get(map,key)                Gets the value of map _map_ for _key_ for a map.
*-  get(set,i)                  Gets the i-th element in a set, or fails if no such element.
*-  false(e)                    Tests if argument is false.
*-  forall(set,expr)            Tests if an expression is true for every element of a set.
*-  integers(n)                 Returns set of integers 1 ... n.
*-  intersection(a,b)           Returns set of elements common to two sets.
*-  join(a,b,c)                 Joins several sequences/strings into one sequence/string.
*-  loop(set,this)              Set up iteration over _set_ using _next_. _this_ names variable updated during iteration.
*-  multiple(n,m)               Tests if _n_ is a multiple of _m_.
*-  odd(n)                      Tests if _n_ is odd.
*-  out(text1,text2,text3)      Outputs _text1_, then _text2_ enclosed in '[]' if _text2_ not null.
*-  pack(seq)                   Packs sequence of strings into single string.
*-  powerset(set)               Return the powerset of _set_, the set of all the subsets of _set_.
*-  product(seq)                Returns (Cartesian) product of a sequence of sets or strings.
*-  member(set,elem)            Tests if _elem_ is a member of _set_.
*-  new(str)                    Returns a new set specified by _str_.
*-  next(set)                   Returns next element in iteration defined by prevous _loop_, fails if no more elements.
*-  not(expr)                   Tests if operand is false.
*-  number(s)                   Returns integer defined by _s_.
*-  or(a,b)                     Tests if either operand is true.
*-  pop(stack)                  Pop the top of a stack and return its value.
*-  prime(n)                    Tests if _n_ is prime.
*-  primes(n)                   Returns set of primes less than _n_.
*-  push(stack,value)           Push value onto a stack.
*-  put(map,key,val)            Defines the value of a map key.
*-  quicksort(seq)              Use Hoare's quicksort algorithm to sort a sequence.
*-  random(n)                   Returns random integer if _n_ is integer, elsel random element of set or map.
*-  random.seed()               Sets random number seed to initialize _random_.
*-  range(map)                  Returns set of elements in the range of a map.
*-  reader(filename,expr)       Returns sequence of lines in file _filename_, using _expr_ (if given).
*-  reader.str(str,delim)       Like _reader(filename..)_ but reads lines from a string with lines.
*-  reduce(set,expr,n)          Returns set of elements in _set_ for which _expr_ is true.
*-  set.size(set)               Returns number of elements in set _set_.
*-  #set                        Same as _set.size(set)_
*-  show(v)                     Show value of _v_.
*-  show.boolean(v)             Shows value of _v_ as boolean.
*-  show.text(v)                Same as _show()_, but strings are not enclosd in quotes.
*-  slice(str,first,last)       Like SPITBOL substr to work for sequences and tuples.
*-  sorter(set,type)            Sorts a set, map or string according to _type_.
*-  split(s)                    Returns string of whitespace-separated fields into sequence.
*-  square.root(n)              Returns integer square root on _n_
*-  subset(a,b)                 Tests if the set _b_  is a subset of set _a_
*-  this(set)                   Returns current iteration value for _set_.
*-  top(s)                      Returns top element of sequence viewed as stack.
*-  tolower(s)                  Returns _s_ with upper case letters replaced by lower case equivalent.
*-  traceon()                   Turns on tracing.
*-  traceoff()                  Turns off tracing
*-  tokens(s)                   Returns sequence of the tokens in string _s.
*-  true(e)                     Tests if operand is true.
*-  union(a,b)                  Returns set consisting of all the members in two sets.
*-  unpack(str)                 Unpacks string into sequence of its characters.
*-  toupper(s)                  Returns _s_ with lower case letters replaced by upper case equivalent.
*-  visit(set,expr)             Visits each element of set _set_ and evaluates _expr_ for that element.
*-  words(s,w)                  Returns sequence of words (defined by _w_) in _s_.
*-  writer(lines)               Writes sequence _lines_ to standard output.

*       SETL4 Function Definitions

        define('add(set,elem)ara,i,n,str')              :(add.end)

*       _Add_ adds an element to a set if it not already a member.
*       If the set has kind _map_ and _elem_ has the data type _entry_
*       the map is updated using the key and value of the entry.

add

*       Test if adding blank and if so, do not convert to integer.
*       Otherwise convert string with integer value to integer.

        elem = integer(elem) +elem

        differ(datatype(set),'set') error('attempt to add to non-set ' datatype(set))

        ident(set.kind(set),'map')                      :s(add.map)
        ident(set.kind(set),'seq')                      :s(add.seq)f(add.set)

add.map

        differ(datatype(elem),'entry') error("can only add 'entry' elements to a map.")
        put(set,key(elem),value(elem))                  :(return)

add.set

        member(elem,set)                                :s(return)

add.seq

        set.size(set) = #set + 1
        set.index(set)[#set] = elem
        set.key(set)[elem] = elem
                                                        :(return)

add.end

        define('and(a,b)')                              :(and.end)

*       _And_ tests if both operand are true (not null), only
*       evaluating the second argument when necessary.

and

*       See if both operands are integers.

        and = integer(a) eq(a)                          :s(freturn)
        and = integer(b) eq(b)                          :s(freturn)
        and = integer(a) integer(b) ne(a * b)           :s(return)f(freturn)

*       Here where at least one operand for 'and' is not integer, so
*       use ident/differ to evaluate.

        and = differ(a) differ(b)                       :s(return)f(freturn)

and.end

        define('append(str,w,ch)')                      :(append.end)

*       _Appends appends _ch_, or ' ' if _ch_ is null, to _str_ and then appends _w_.

append

        append = str (ident(str) w, (ident(ch) ' ' , ch) w):(return)

append.end

        define('arbitrary(set)iter,r')                  :(arbitrary.end)

*       _Arbtrary_ returns an arbitrary (randomly selected) element of a set, or
*       if the argument is an integer, then _arbitrary_ returns a random
*       integer in the range 1 .. _set_.

arbitrary

        arbitrary = integer(set) random(+set)           :s(return)
        r = random(#set)
        ident(set.kind(set),'iter')                     :s(arbitrary.iter)
        arbitrary = set.key(set)[set.index(set)[r]]
                                                        :(return)

arbitrary.iter

        iter = set.iter(set)
        arbitrary = iter.starbitraryitrary(iter) + (r - 1) * iter.step(iter):(return)

arbitrary.end

        define('assert(expr)')                          :(assert.end)

*       _Assert_ tests that its argument expression is non null, ending execution otherwise.

assert

        true(expr)                                      :s(return)
        error('assertion failed, quitting')

assert.end

        define('assert.type(obj,typ)')                  :(assert.type.end)

*       _Assert.type_ tests that _obj_ has datatype _typ_, and ends execution if not.

assert.type

        assert(ident(datatype(obj),typ))                :s(return)
        error('assertion on datatype failed ' typ )


assert.type.end

        define('binary(n)')                             :(binary.end)

*       _Binary_returns a string with the value of _n_ as a binary number.

binary

        n = n * 2

binary.next

        n = n / 2

        binary = eq(n)   '0'                            :s(return)
        binary = eq(n,1) '1'                            :s(return)
        binary = even(n) binary(n / 2) '0'
        binary = odd(n)  binary(n / 2) '1'
                                                        :(return)

                                                        :(binary.next)

binary.done

*       binary = ident(binary) '0'                          :s(return)
*       binary = gt(size(binary),1) substr(binary,2)
                                                        :(return)

binary.end

        define('checkout(filename)file,fullname,line,word'):(checkout.end)

*       _Checkout_ checks out (retrieves) a file from the library as a sequence of lines
*       or a set of words. _Checkout_ lists the available files if _filename_ is null.

*       Dictionary has one word per line, with toupper 'S' at end denoting
*       that both singular and plural form are words in the dictionary.

*       When checking out text files, skip blank lines and lines that start with '*'.

checkout

        differ(filename)                                :s(checkout.check)

checkout.list

        out('available texts in the checkout            :')
        out('dictionary')
        out('genesis')
        out('hamlet')
        out('new-testament')
        out('old-testament')
        out('romeo-and-juliet')
        out('shakespeare')
        out('sonnets')
                                                        :(return)

checkout.check

*       See if _filename_ matches one of the available texts.


        filename = setl4.begins('dictionary',filename)        :s(checkout.open)
        filename = setl4.begins('enable1',filename)           :s(checkout.open)
        filename = setl4.begins('genesis',filename)           :s(checkout.open)
        filename = setl4.begins('hamlet',filename)            :s(checkout.open)
        filename = setl4.begins('new-testament',filename)     :s(checkout.open)
        filename = setl4.begins('old-testament',filename)     :s(checkout.open)
        filename = setl4.begins('romeo-and-juliet',filename)  :s(checkout.open)
        filename = setl4.begins('shakespeare',filename)       :s(checkout.open)
        filename = setl4.begins('sonnets',filename)           :s(checkout.open)

        out('Sorry, that text is not available.')
        out('Here is a list of the available texts:')   :(checkout.list)

checkout.open

        fullname = setl4.path '/library/' filename '.txt'
        input(.file,3,fullname)                         :s(checkout.opened)
        error('unable to open file ',filename)          :(freturn)

checkout.opened

*       Dictionary requires special handling.

        ident(filename,'dictionary')                    :s(checkout.dictionary)
        checkout = set('seq',iterator(),table(2000),table(2000))

checkout.next

        line = file                                     :f(checkout.finis)
        lines = lines + 1
        ident(line)                                     :s(checkout.next)
        line '*'                                        :s(checkout.next)
        push(checkout,line)                             :(checkout.next)

checkout.dictionary

        checkout = set('set',iterator(),table(40000),table(40000))

checkout.dictionary.add

        add(checkout,word)

checkout.dictionary.next

        word = file                                     :f(checkout.finis)
        ident(substr(word,size(word),1),'S')            :f(checkout.dictionary.add)

*       Here if plural. Add plural form and them merge to add singular form.

        word = substr(word,1, size(word) - 1)
        add(checkout, word 's')                         :(checkout.dictionary.add)

checkout.finis

        endfile(3)                                      :(return)

checkout.end

        define('compare(a,b)')                          :(compare.end)

*       _Compare_ compares two integers or strings, returning -1 if the _a_ is
*       less than _b_ , 0 if both have the seq.eq value, and +1 if the _a_ is greater than _b_.

compare

        a = integer(a) +a
        b = integer(b) +b
        differ(datatype(a),datatype(b)) error("compare argument types differ " datatype(a) " " datatype(b))
        ident(datatype(a),'string')                     :s(compare.strings)

*       Here to numerically compare integers.

        compare = lt(a,b) -1                            :s(return)
        compare = eq(a,b) 0                             :s(return)
        compare = 1                                     :(return)

compare.strings

*       Here to lexically compare strings.
        compare = llt(a,b) -1
        compare = leq(a,b) 0
        compare = lgt(a,b) 1
*       out('compare ' show(a) ' ' show(b) ' ' compare)
                                                        :(return)

compare.end

        define('compose(a,b)ara,entry,i')               :(compose.end)

*       _Compose_ returns the composition of two maps or tables.
*       Given maps _a_ and _b_ such that _range(a)_ is a subset of _domain(b)_,
*       then the composition _c_ of _a_ and _b_ is defined as follows:
*       Let A be a member of the domain of _a_. Let B be the value of _a[A]_.
*       Then _c[A]_ is defined as _b[B]_.

compose

        ident(datatype(a),'table')                      :s(compose.table)

*       Here to compose two maps.

        n = #a
        compose = eq(n) new('map')                      :s(return)
        compose = new('map #' n)
        set.size(compose) = n
        loop(a)

compose.map.next

        entry  = next(a)                                :f(return)
        put(compose,key,get(b,value(entry)))            :(compose.map.next)

compose.table

        ara = convert(a,'array')                        :f(show.table.error)
        prototype(ara) break(',') . n
        compose = table(n)
        i = 0

compose.table.next

        le(i = i + 1,n)                                 :f(return)
        compose[i] = b[a[i]]                            :(compose.table.next)

compose.end

        define('defined(map,key)entry')                 :(defined.end)

*       _Defined_ tests if the map _map_ has an entry for _key_.

defined
        key = integer(key) +key
        defined = set.key(map)[key]
        differ(defined)                                 :s(return)f(freturn)

defined.end

        define('difference(a,b)this')                   :(difference.end)

*       _Difference_ returns the set difference of two sets, which is
*       defined as the set of elements of the first set that are not
*       also elements of the second set.

difference

        difference = new('set')
        loop(a)

diference.next

        this = next(a)                                  :f(return)
        member(this,b)                                  :s(difference.next)
        add(difference,this)                            :(difference.next)

difference.end

        define('domain(map)elem)')                      :(domain.end)

*       _Domain_ returns the domain of map, which is the set of the keys in _map_.

domain

        domain = new('set')
        loop(map)

domain.next

        entry = next(map)                               :f(return)
        differ(entry) add(domain,key(entry))            :(domain.next)

domain.end

        define('equal(a,b)entry,i,key,value')           :(equal.end)

*       _Equals_ tests if two objects are equal. Use DIFFER unless both are sets, in
*       which case use equality tests specified below.

equal

        ident(datatype(a),datatype(b))                  :f(freturn)
        ident(datatype(a),'entry')                      :s(equal.entry)
        ident(datatype(a),'pair')                       :s(equal.pair)
        ident(datatype(a),'set')                        :s(equal.sets)
        ident(a,b)                                      :s(return)f(freturn)

equal.entry

        equal(key(a),key(b))                            :f(freturn)
        equal(value(a),value(b))                        :f(freturn)s(return)

equal.int

        eq(iter.start(a),iter.start(b))                 :f(freturn)
        eq(iter.finis(a),iter.finis(b))                 :f(freturn)
        eq(iter.step(a),iter.step(b))                   :f(freturn)s(return)

equal.map

*       Two maps are equal if they have the same vaue at every element in the domain.

        eq(#a,#b)                                       :f(freturn)
        gt(i = i + 1, #a)                               :s(equal.true)
        entry = set.index(a)[i]
        ident(value(entry),get(b,key(entry)))           :f(freturn)s(equal.map)

equal.pair

        equal(first(a),first(b))                        :f(freturn)
        equal(second(a),second(b))                      :f(freturn)s(return)

equal.seq

*       Two sequences are equal if they have the same vaue at every element in the domain.

        eq(#a,#b)                                       :f(freturn)
        gt(i = i + 1, #a)                               :s(equal.true)
        ident(set.seq(a)[i], set.seq(b)[i])             :s(equal.seq)f(freturn)

equal.sets


        eq(#a,#b)                                       :f(freturn)
        ident(set.kind(a),set.kind(b))                  :f(freturn)
        ident(set.kind(set),'int')                      :s(equal.int)
        ident(set.kind(set),'iter')                     :s(equal.iter)
        ident(set.kind(set),'map')                      :s(equal.map)
        ident(set.kind(set),'seq')                      :s(equal.seq)
        ident(set.kind(set),'set')                      :s(equal.set)
        error('equal mismatched kinds')


equal.set

*       Two sets are equal if and only if each is a subset of the other.

        eq(#a,#b)                                       :f(freturn)
        subset(a,b)                                     :f(freturn)
        subset(b,a)                                     :f(freturn)
                                                        :(return)
        equal = and(subset(a,b),subset(b,a))            :f(freturn)s(return)

equal.end

        define('error(str)')                            :(error.end)

*       _Error_ writes out its argument string and ends execution.

error

*       &dump = 2
*       &dump = 3
        out('&dump',&dump)

*       Clear variables that need not appear in &dump output

        setl4.clear()
        out('Fatal error: ' str)                        :(end)

error.end

        define('even(n)')                               :(even.end)

*       _Even_ tests if its argument is even.

even

*HERE*

        integer(n)                                      :f(freturn)
        eq(remdr(n,2))                                  :s(return)f(freturn)

even.end

        define('exists(set,expr)this,e')                :(exists.end)

*       _Exists_ tests if there is an element in _set such that _expr_ is true.

exists

        loop(set)

exists.loop

        this = next(set)                                :f(freturn)
        exists = eval(expr)                             :f(exists.loop)s(return)

exists.done

        output = 'exists loop ended, failing'           :(freturn)

exists.end

        define('factorial(n)')                          :(factorial.end)

*       _Factorial_ computes the value of the factorial function of its argument.

factorial

        integer(n)                                      :f(freturn)
        factorial = (eq(n,1) 1, n * factorial(n -1))    :(return)

factorial.end

        define('false(e)')                              :(false.end)

*       _False_ tests if its argument is false (null).

false

        e = integer(e) +e
        false = integer(e)  eq(e)                       :s(freturn)
        false = ident(e)                                :s(return)f(freturn)

false.end

        define('forall(set,expr)e')                     :(forall.end)

*       _Forall_ tests if _expr_ is true for all elements of _set_.

forall

        loop(set)

forall.loop

        next(set)                                       :f(return)
        e = eval(expr)                                  :f(freturn)s(forall.loop)

forall.end

	define('filter(proc,file)channel,line,var')	:(filter.end)

*	Filters the specified file by applying proc to each line in the file.
*	If the file is not given, then standard input is used.
*	Filter does not write to an output file, but returns the result
*	of applying the filter procedure to each line in the sequence filter.lines.out.

*	Globals:
*
*	filter.file.in 			Input file
*	filter.line.in			Current line
*	filter.line.out			Result of applying proc to filter.line.in
*	filter.lines.in			All the lines in the file as a sequence
*	filter.lines.out		All the filtered lines as a sequence
*	filter.integer			Output variable set by the filter
*	filter.string			Output variable set by the filter
*	filter.data			Output datatype set by the filter

filter
	ident(filefile)			:s(filter.next)

*	Here to open the input file

	differ(file) open(.var,'filter.channel',file)	:f(filter.fail)
	
filter.next

	line = differ(file) .var	:f(filter.eof)
	filter.line = ident(file) input	:f(filter.eof)
	filter.line.out = apply(proc(line)) 	:f(filter.fail)
	filter.lines.in = join(filter.lines.in, filter.line.in)
	filter.lines.out = join(filter.lines.out, filter.line.out)
					:(filter.next)
filter.fail

filter.eof

	differ(file) endfile('filter.channel')	:s(return)f(freturn)

filter.end
	
*	
        define('frequency(map)this')                    :(frequency.end)

*       _Frequency_ returns a frequency distribution for a map,
*       sequence  or string. The frequency distribution of a string
*       gives the number of times each character in the string occurs
*       in the string. The distribution of a map or sequence gives,
*       for each element in the range of the map the number of keys
*       having that value.


frequency

        frequency = new('map')
        ident(datatype(map),'set')                      :s(frequency.map)

*       Compute distribution for string by converting string to sequence
*       and merging with code to find distribution for a map.

        map = unpack(map)

frequency.map

*       Here to compute frequency distribution of a map.

        loop(map)

frequency.next

        this = value(next(map))                         :f(return)
        this = integer(this) +this
        put(frequency,this,get(frequency,this) + 1)     :(frequency.next)

frequency.end

        define('get(map,key)val,entry')                 :(get.end)

*       _Get_ gets the value of the key _key_ in the map _map_, or gets
*       element _key_ in a set, failing if no such element.

get

        key = integer(key) +key
        ident(set.kind(map),'int')                      :s(get.int)
        ident(set.kind(map),'map')                      :s(get.map)
        ident(set.kind(map),'seq')                      :s(get.map)
        ident(set.kind(map),'set')                      :s(get.set)
        error('get on unsupported kind of set           : ' set.kind(map))

get.int

        error("get on set of kind 'int' not yet supported.")

get.map

        get = set.key(map)[key]                         :(return)

get.set

        ident(set.kind(map),'iter')                     :s(get.int)
        get = set.index(map)[key]
        ident(get)                                      :s(freturn)f(freturn)
        get = set.key(map)[entry]                       :(return)

get.end

        define('int(n)')                                :(int.end)

*       _Int_ Returns _n_ if _n_ is an integer, or returns _n_ converted to an
*       integer if _n_ is real, or returns the value of a string written in exponential
*       (scientific) notation converted to its integer value.

int

        int = integer(n) n                              :s(return)
        int = ident(datatype(n),'real') convert(n,'integer'):s(return)
        int = n
        n break('e')                                    :f(return)
        n break('e') . int 'e' =
        int = int * +('1' dupl('0',n))
        int = +int
                                                        :(return)

int.end

        define('integers(n)')                           :(integers.end)

*       _Integers_ returns the set containing the integers 1 .. _n_

integers

        integers = set('set',iterator(),table(n),table(n))

integers.next

        le(i = i + 1,n) add(integers,i)                 :s(integers.next)f(return)

integers.end

        define('intersection(a,b)this')                 :(intersection.end)

*       _Intersection_ returns the intersection of its argument sets.

intersection

*       Make _a_ the smaller

        le(#a,#b)                                       :s(intersection.next)
        a = b
        b = intersection
        intersection = new('set')
        loop(a)

intersection.next

        this = next(a)                                  :f(return)
        member(this,b) add(intersection,this)           :(intersection.next)

intersection.end

        define('join(s1,s2,s3)i,this')                  :(join.end)

*       _Join_ combines one of more sequences (strings) into a single sequence
*       (string) by joining all their elements together.

join

        s1 = differ(s1) ident(datatype(s1),'integer') convert(s1,'string')
        s2 = differ(s2) ident(datatype(s2),'integer') convert(s2,'string')
        s3 = differ(s3) ident(datatype(s3),'integer') convert(s3,'string')

        join = differ(s1) differ(s2) differ(s3) join(join(s1,s2),s3):s(return)
        ident(datatype(s1),'string')                    :s(join.string)
        join = new('seq')
        loop(s1)

join.s1

        push(join,value(next(s1)))                      :s(join.s1)

        ident(s2)                                       :s(return)

*       Test if second argument is sequence.

        ident(datatype(s2),'set') ident(set.kind(s2),'seq'):s(join.s2)

*       Here if not sequence, so just add it to result and return.

        push(join,s2)                                   :(return)

join.s2

*       Here to join elements in the second argument to the result.

        loop(s2)

join.s2.next

        push(join,value(next(s2)))                      :s(join.s2.next)f(return)

join.string

*       Here to join strings.

        join = s1 (differ(s2) s2, '') (differ(s3) s3,''):(return)

join.end

        define('loop(set,thisname)iter')                :(loop.end)

*       _Loop_ creates or updates the iterator of _set_ so that,
*       on the call to _next()_,  _iter.next_  will be
*       advanced to select the first element in the iteration.

*       If _thisname_ is not null, then _thisname_ is set to 'this'.
*       On each call to _next()_ during the iteration established
*       by _loop_, the value of the iterate will be assigned to _thisname_.

loop

        differ(datatype(set),'set') out('loop() unsupported argument type.')
        differ(datatype(set),'set') show(set)
        differ(datatype(set),'set')
.           error('loop() expects argument to be set, but given ' datatype(set))

        iter = iterator()

        ident(set.kind(set),'iter')                     :s(loop.iter)
        ident(set.kind(set),'int')                      :s(loop.int)
        ident(set.kind(set),'map')                      :s(loop.map)
        ident(set.kind(set),'seq')                      :s(loop.map)
        ident(set.kind(set),'set')                      :s(loop.set)
        error('unknown kind of iterator, ' set.kind(set))

loop.int

        iter.next(set) = set.block(iter) = set.offset(iter) = 0:(loop.finis)

loop.iter

*       When iterating over a set of kind 'iter', use the iterator
*       created when the set was created.

        iter = set.iter(set)                            :(loop.finis)
        iter.next(iter) = gt(iter.step(iter)) iter.start(iter) - iter.step(iter)
        iter.next(iter) = lt(iter.step(iter)) iter.start(iter) + iter.step(iter)
                                                        :(loop.finis)


loop.map
loop.seq
loop.set

loop.finis

        thisname = ident(thisname) .this
        thisname = ident(datatype(thisname),'string') .thisname
        iter.thisname(iter) = thisname
        set.iter(set) = iter                            :(return)

loop.end

        define('member(elem,set)kind,entry,i,iter,key,this,value,block)'):(member.end)

*       _Member_ tests if _elem_ is member of _set_.

member

*       Branch according to whether _set_ is set, map, or sequence.

        eq(#set)                                        :s(freturn)

*       Do not convert single space to integer.

        elem = differ(elem,' ') integer(elem) +elem
        ident(datatype(elem),'entry')                   :s(member.map)
        ident(set.kind(set),'int')                      :s(member.int)
        ident(set.kind(set),'iter')                     :s(member.iter)
        ident(set.kind(set),'set')                      :s(member.set)
        error('requesting member for unsupported set kind, ' kind )

member.int

*       To test for membership in set of kind _int_ get the block
*       for the element. If it is null then fail since element not
*       in the set. Otherwise see if character corresponding to the
*       value of _elem_ is '+'.

        block = elem / setl4.config.int
        this = +(remdr(elem,setl4.config.int) + 1)
        value = set.key(set)[block]
        ident(value)                                    :s(freturn)
        ident(substr(value,this,1),'+')                 :s(return)f(freturn)

member.iter

        integer(elem)                                   :f(freturn)
        iter = set.iter(set)
        lt(iter.step(iter)) lt(elem,iter.finis(iter))   :s(freturn)
        gt(iter.step(iter)) eq(remdr(elem - iter.start(iter),iter.step(iter))):s(return)
        lt(iter.step(iter)) eq(remdr(iter.start(iter) - elem,iter.step(iter))):s(return)
                                                        :(freturn)

member.map

        differ(set.key(set)[key(elem)])                 :s(return)f(freturn)

member.set

        differ(set.key(set)[elem])                      :s(return)f(freturn)

member.end

        define('multiple(n,m)')                         :(multiple.end)

*       _Multiple_ Tests if _n_ is a multiple of _m_.

multiple

        multiple = eq(remdr(n,m))                       :s(return)f(freturn)

multiple.end

        define('new(init,elem1,elem2)kind,i,index,iter,len,n,key,seq,val,values,words)'):(new.end)

*       _New_ constructs a new set with initial values determined by string _init_.

*       The first three characters in _init_ give the kind of the set:
*
*           'iter'          iterator, followed by iterator specification
*           'map'           map, followed by list of key/value pairs separated by colon
*           'set'           set, followed by list of initial members
*           'seq'           sequence, followed by list of initial values.

*       The set kind may optionally be followed by a number sign (#) followed by an integer, to
*       indicate an estimate of the number of elements in a set or map. The number need not be
*       accurate. Values that are too high will cause the program to expend space to save some time;
*       numbers that are too low will expend some time to save space.

*       _New_ returns the new object.

new

*       Assume kind is 'set' unless explicitly specified.

        kind = 'set'

        init span(' ') =
        ident(init)                                     :s(new.set)
        init = init ' '
        init break(' ') . kind span(' ') =
        kind = (gt,size(kind),3) substr(kind,1,3)
        setl4.begins('integers',kind)                         :s(new.kind)
        setl4.begins('iterator',kind)                         :s(new.kind)
        setl4.begins('map',kind)                              :s(new.kind)
        setl4.begins('seq',kind)                              :s(new.kind)
        setl4.begins('set',kind)                              :s(new.kind)
        setl4.begins('string',kind)                           :s(new.kind)

*       If the kind is not given, then the kind is 'set' and _init_
*       is not null, it gives the initial element(s) to add to the set.

        kind = 'set'

new.kind

        kind = gt(size(kind),3) substr(kind,1,3)
        n = 0
        init span(' ') =
        n = setl4.config.table.int.table.size
        init '# ' span('0123456789') . n =              :s(new.sized)
        init '#' span('0123456789') . n =

new.sized

*       Branch on kind to finish initialization of new set.

                                                        :($('new.' kind))
new.int

        new = set('set',iterator(),table(n),table(n))
        set.kind(new) = 'int'
        set.index(new) = table(1000)
        set.key(new) = table(1000)

new.int.next

        init break(' ') . key span(' ') =               :f(new.init.elem)
        add(new,int(key))                               :(new.int.next)

net.int.elem

        differ(elem1) add(new,elem1)
        differ(elem2) add(new,elem2)                    :(return)

new.ite
new.iter

        new = set('iter')
        iter = iterator()
        iter.thisname = .this
        set.iter(new) = iter
        iter.step(iter) = 1
        seq = new('seq ' init)

*       Ignore extra arguments to iterator constructor.

        set.size(seq) = gt(#seq,3)
        eq(#seq,1)                                      :s(new.iter.1)
        eq(#seq,2)                                      :s(new.iter.2)
        eq(#seq,3)                                      :s(new.iter.3)

new.iter.1

        iter.start(iter) = 1
        iter.finis(iter) = get(seq,1)
        iter.step(iter) =  1                            :(new.iter.step)

new.iter.2

        iter.start(iter) = get(seq,1)
        iter.finis(iter) = get(seq,2)
        iter.step(iter) =  1                            :(new.iter.step)

new.iter.3

        iter.start(iter) = get(seq,1)
        iter.finis(iter) = get(seq,2)
        iter.step(iter)  = get(seq,3)

new.iter.step

*       Make sure step negative if first argument to iter is greater than the second.

        lt(iter.step(iter)) out('new -step',iter.step(iter))
        iter.step(iter) = gt(iter.start(iter),iter.finis(iter))  gt(iter.step(iter)) - iter.step(iter)
        set.size(new) = ((iter.finis(iter) - iter.start(iter)) / iter.step(iter)) + 1
                                                        :(return)

new.map

        new = set('map',iterator(),table(n),table(n))
        set.encloser(new) = '{}'

*       If present, _init_ is a list consisting of a list of key/value pairs,
*       with a colon (:) separating the key and value.

        init = init ' '
        init span(' ') =
        ident(init)                                     :s(return)

new.map.next

        init break(char(58)) . key char(58) break(' ') . val span(' ') =:f(return)
        put(new,key,val)
                                                        :(new.map.next)

new.seq

        new = set(kind,iterator(),table(n),table(n))
        set.encloser(new) = '()'
        init span(' ') =
        ident(init)                                     :s(return)
        init = init ' '

new.seq.next

        init span(' ') =
        init break(' ') . val ' ' =                     :f(return)
        push(new,val)                                   :(new.seq.next)

new.set

        new = set('set',iterator(),table(n),table(n))
        set.kind(new) = 'set'
        set.encloser(new) = '{}'
        ident(init)                                     :s(return)

new.set.iter.next

        init break(' ') . key span(' ') =               :f(new.set.elem)
        add(new,key)                                    :(new.set.iter.next)

new.set.elem

        differ(elem1) add(new,elem1)
        differ(elem2) add(new,elem2)

new.set.done

                                                        :(return)

new.end

        define('new.stack()')                           :(new.stack.end)

*       _New.stack_ returns a new stack.

new.stack

*       Don't allocate stack table when creating stack. Do that
*       when first add value to stack.

        new.stack = stack(,0)                           :(return)

new.stack.end

        define('next(set)iter,key,next,str,thisname,value'):(next.end)

*       _Next_ advances an iteration or fails if no more elements remain.

next

*       Branch on kind to find next iteration value.

        iter = set.iter(set)                            :($('next.' set.kind(set)))

next.int

*       Iteration over a set    of kind 'int' makes use of the following fields:
*
*           set.block      is current block for iteration
*           set.offset     is zero if this block not search, or else index of an
                           element of the set in this block
*           set.str        is set to the string of a block when advance to it.

*       Branch to get first block if _set.str_ is null.

        ident(set.str(set))                             :s(next.int.block)

next.int.test

*       See if any members remain in this block, branching to _next.int.block_ if none.

next.int.block

*       Here to advance to next block, ending iteration if no more remain.

        set.block(set) = set.block(set) + 1
        gt(set.block(set),set.blocks(set))              :s(freturn)
        set.str(set) = set.key(set)[set.index(set)[set.block(set)]]
        str = set.str(set)
        str break('+') . key                            :f(next.int.block)

*       Here when member found. Clear the membership character and return.

        set.str(set) = set.key(set)[block]
        set.str(set) = ne(set.offset(set))
.               substr(set.str(set),1,set.offset(set) - 1,'-','+')
.              '+'
.              substr(str,set.offset(set) + 1)
        set.str(set) = str
        next = (set.block(set) * setl4.config.int) + size(key):(next.finis)

next.iter

*       Here to find next element in iterator.

        eq(iter.step(iter)) error('iterator with step zero')
        next = iter.next(iter) = iter.next(iter) + iter.step(iter)
        gt(iter.step(iter)) gt(next,iter.finis(iter))   :s(freturn)
        lt(iter.step(iter)) lt(next,iter.finis(iter))   :s(freturn)
                                                        :(next.finis)

next.map
next.seq
next.tup

        next = iter.next(iter) = iter.next(iter) + 1
        le(next,#set)                                   :f(freturn)
        key = set.index(set)[next]
        next = entry(key,set.key(set)[key])             :(next.finis)

*next.seq
*
*        next = iter.next(iter) = iter.next(iter) + 1
*        le(next,#set)                             :f(freturn)
*        key = set.index(set)[next]
*        next = set.key(set)[next]                          :(next.finis)
*
next.set

        next = iter.next(iter) = +iter.next(iter) + 1
        le(next,#set)                                   :f(freturn)
        next = set.index(set)[next]                     :(next.finis)

next.finis

*       Here to update _thisname_  to the next iteration value.

        thisname = iter.thisname(iter)
        thisname = ident(datatype(thisname),'string') .this
        $(thisname) = next                              :(return)

next.end

        define('not(expr)')                             :(not.end)

*       _Not_ returns the negation of a boolean expression.

not

        not = integer(expr) (eq(expr) 1, '')            :s(return)f(freturn)
        not = ident(expr) 1                             :s(return)f(freturn)

not.end

        define('number(n)')                             :(number.end)

*       Test if _n_ is a string with integer value or integer, returning its
*       value if so, or failing otherwise.

number

        number = integer(n) +n                          :s(return)f(freturn)

number.end

        define('odd(n)')                                :(odd.end)

*       _Odd_ tests if its argument is odd.

odd

        integer(n)                                      :f(freturn)
        odd = ne(remdr(n,2))                            :s(return)f(freturn)

odd.end

        define('or(a,b)')                               :(or.end)

*       _Or_ tests if either operand is true, fails otherwise, only evaluating
*       its second argument if necessary

or
        or = integer(a) ne(a)                           :s(return)
        or = integer(b) ne(b)                           :s(return)

*       Here if operands not both integers, so use ident/differ.

        or = differ(a)                                  :s(return)
        or = differ(b)                                  :s(return)f(freturn)

or.end

        define('out(text1,text2)type1,type2')           :(out.end)

*       _Out_ writes a line to standard output  conisting of _text1_,
*       then _text2_ enclosed in brackets if _text2_ is not null.

out

        text2 = setl4.is.plain(text2) setl4.plain(text2)
        output  = text1 (differ(text2) '[' text2 ']', '') :(return)

out.end

        define('out.dt(v)')                             :(out.dt.end)

*       Show datatype of _v_

out.dt

        out('Datatype ' v,eval('datatype(' v ')'))      :(return)

out.dt.end

        define('pack(seq)i')                            :(pack.end)

*       _Pack_ packs a sequence of strings into a single string.

pack

        loop(seq)

pack.next

        pack = pack value(next(seq))                    :s(pack.next)f(return)

pack.end

        define('pop(stack)')                            :(pop.end)

*       _Pop_ removes (pops) the top item from stack, or fails if the stack is empty.

pop

        pop = stack
        eq(#stack)                                      :s(freturn)
        pop = set.key(stack)[set.index(stack)[#stack]]
        set.size(stack) = #stack - 1                    :(return)

pop.end

        define('powerset(set)b,i,j,n,N,s,this')         :(powerset.end)

*       Return the powerset of _set_, defined as the set of all subsets of a set.

powerset

        powerset = new('set')

*       Let _n_ be the size of _set_.
*       The powerset of the empty set is the empty set.

        n = #set
        eq(n)                                           :s(return)

*       Compute _N_ = 2 to the powerset _n_.

        N = 1
        i = 0

powerset.N

        le(i = i + 1,n)                                 :f(powerset.N.done)
        N = N * 2                                       :(powerset.N)

powerset.N.done

*       Compute the powerset as follows:

*       Loop for i = 0 ... N - 1:
*           Let _b_ be the string containing the binary value of _i_, padded to length _n_.
*           Set _this_ to the empty set.
*           Loop for _j_ = _size(b)_ ... _1_
*               If the _j_-th character of _b_ is '1' then add
*               the _j_-th element of _set_ to _this_.
*           Add _this_ to _powerset_.

        i = -1

powerset.next.i

        lt(i = i + 1,N)                                 :f(return)
        b = binary(i,n)
        this = new('set')
        j = size(b) + 1

powerset.next.j

        gt(j = j - 1)                                   :f(powerset.j.done)
        s = substr(b,j,1)
        ident(s,'1') add(this,set.index(set)[j])
                                                        :(powerset.next.j)

powerset.j.done

        add(powerset,this)                              :(powerset.next.i)

powerset.end

        define('prime(n)')                              :(prime.end)

*       _Prime_ tests if _n_ is a prime integer.

prime

        n = integer(n) +n
        eq(n,2)                                         :s(return)
        even(n)                                         :s(freturn)
        exists(new('iter 3 ' square.root(n) ' 2'), 'multiple(n,this)'):s(freturn)f(return)

prime.end

        define('primes(n)this')                         :(primes.end)

*       _Primes_ returns the set of primes less than _n_.

primes

        primes = new('seq')
        primes = integer(n)                             :f(return)
        primes = lt(n,3) new('set 2')                   :s(return)
        primes = filter(new('iter 2 ' (n - 1)),'prime(this)'):(return)
        primes = new('seq 2')
        iter = new('iter 2 ' (n - 1))
        loop(set)

primes.loop

        this = next(set)                                :f(return)
        prime(this) push(primes,this)                   :(primes.loop)

primes.end

        define('product(seq,strings)partial,t1,slice1,set1,set2,this1,this2,tup,tmp,p1,p2'):(product.end)

*       _Product_ returns the Cartesian product.set of a sequence of strings or sets.

*       The product of an empty set is the empty set; the product
*       of a single set is itself; the product of more than two sets
*       is defined recursively; and the product of two sets is computed
*       element by element.

*       If argument _strings_ is not null then _sets_ is a sequence of strings.

product

        product = new('set')
        product = eq(#seq)                              :s(return)
        product = eq(#seq,1) copy(seq)                  :s(return)

        set1 = get(seq,1)
        set2 = get(seq,2)
        eq(#seq,2)                                      :s(product.two)

*       Here to compute the product of three or more sets. First,
*       compute the partial product of all the sets except the last one,
*       and then compute the product of that partial product and the last set.

        set1 = product(slice(seq,1,#seq - 1),strings)
        set2 = top(seq)

product.two

*       Here to compute the product of two sets.

*       Loop over the first set. If an element is a tuple, then we are extending a
*       partial product. Otherwise we are interating over the first set in a product
*       and need to create a tuple from the element.

*       Then loop over the second set. For each element in the second set, add a new
*       element to the output that extends the tuples of the current element in the
*       first set.

        product = new('set')
        loop(set1,.this1)

product.set.next1

        next(set1)                                      :f(return)
        this1 = ident(strings) differ(datatype(this1),'set')  push(new('seq'),this1)

        loop(set2,.this2)

product.set.next2

        next(set2)                                      :f(product.set.next1)
        add(product,join(this1,this2))                  :s(product.set.next2)

product.end
        define('push(seq,val1,val2,val3,val4,val5)')    :(push.end)

*       _Push_ adds new value(s) to a seq or tuple, returning the updated
*       seq or tuple as its value.

push
        seq = ident(seq) new('seq')
        push = seq
        ident(val1)                                     :s(return)
        push.value(seq,val1)
        ident(val2)                                     :s(return)
        push.value(seq,val2)
        ident(val3)                                     :s(return)
        push.value(seq,val3)
        ident(val4)                                     :s(return)
        push.value(seq,val4)
        ident(val5)                                     :s(return)
        push.value(seq,val5)                            :(return)

push.end

        define('push.value(seq,value)n')                :(push.value.end)

*       _Push.value_ adds _value_ to a seq or tuple, returning
*       the updated seq or tuple as its value.

push.value

        ident(seq) error('push() first argument is null.')
        differ(datatype(seq),'set')
.           error('push() first argument is not a set, but instance of ' datatype(seq))
        ident(set.kind(seq),'map')                      :s(push.value.add)
        ident(set.kind(seq),'seq')                      :s(push.value.add)
        error('first argument to push.value must be set or map, is ' datatype(seq))

push.value.add

        set.size(seq) = #seq + 1
        n = #seq
        set.index(seq)[n] = n
        value = differ(value,' ') integer(value) +value
        set.key(seq)[n] = value                         :(return)

push.value.end

        define('put(map,key,value)v')                   :(put.end)

*       _Put_ sets the value of the entry for key _key_ in map _map_ to be _val_,

put

        key = integer(key) +key
        value = integer(value) +value
        differ(set.key(map)[key])                       :s(put.value)

*       Here to create new entry in map, and then merge to set new value.

        set.size(map) = #map + 1
        set.index(map)[#map] = key

put.value

        set.key(map)[key] = value                       :(return)

put.end

        define('quicksort(seq)c,seq.eq,set.gt,seq.lt,pivot,this'):(quicksort.end)

*       _Quicksort_ sorts the sequence _seq_ using Hoare's quicksort algorithm.
*       _Seq_ must be sequence of integers or sequence of strings.

*       This program is for demonstrating SETL4.
*       Use the much more efficient _sorter_ for production use.

quicksort

        quicksort = le(#seq,1) seq                      :s(return)
        pivot = arbitrary(seq)
        number(pivot)                                   :f(quicksort.strings)

*       Here to sort sequence of integers.

        quicksort = join( quicksort(filter(seq,  'lt(value(this),pivot)')),
.                                   filter(seq,  'eq(value(this),pivot)'),
.                         quicksort(filter(seq,  'gt(value(this),pivot)'))):(return)


*       Here to sort sequence of strings.

        quicksort = join( quicksort(filter(seq,  'llt(value(this),pivot)')),
.                                   filter(seq,  'leq(value(this),pivot)'),
.                         quicksort(filter(seq,  'lgt(value(this),pivot)'))):(return)

quicksort.end

        define('random(n)')                             :(random.end)

*       Return integer uniformly distributed in 1,2,...,n.
*       If n=0 returns real uniformly distributed in the interval [0,1].
*       The Algorithm is based on that in section 16.1 of "Algorithms in SNOBOL4,"
*       James F. Gimpel, John Wiley and Sons, 1976.

random

        ident(setl4.random.initialized) random.seed()
        setl4.random.value = remdr(setl4.random.value * 4676, 414971)
        random  = setl4.random.value / 414971.0
        random = ne(n) convert(random * n,'integer') + 1

*       Make sure random of integer never returns zero.

        random = integer(random) eq(random) 1
                                                        :(return)
random.end

        define('random.seed()s,c')                      :(random.seed.end)

*       Compute seed for random number generator from date and time.

random.seed
        differ(setl4.random.initialized)                :s(return)
        setl4.random.initialized = 'TRUE'
        setl4.random.value =
        s = date()
        s = replace(s,'/                                :-','123')

*       Get all the digits in s.

random.seed.loop

        s len(1) . c =                                  :f(random.seed.done)
        ident(c,' ')                                    :s(random.seed.loop)
        setl4.random.value = setl4.random.value c       :(random.seed.loop)

random.seed.done

*       Reverse the seed so digits depending on time come first.

        setl4.random.value = +reverse(setl4.random.value)
                                                        :(return)
random.seed.end

        define('range(map)elem,entry)')                 :(range.end)

*       _Range_ returns the range of map, which is the set of the values in _map_.

range

        range = new('set')
        loop(map)

range.next

        entry = next(map)                               :f(return)
        add(range,value(key(entry)))                    :(range.next)

range.end

        define('reader(filename,undent)line')           :(reader.end)

*       _Reader_ returns a sequence of the lines in the file specified by _filename_.
*       Lines are read from standard input if _filename_ is null.
*       If _undent_ is not null, leading spaces in lines are eliminated.
*       _Reader_ ignores (skips over) lines that start with '*'.

reader

        line  = input
        out('first',line)
        ident(filename)                                 :s(reader.read)
        input(.file,setl4.config.channel.1,filename)    :s(reader.opened)
        out('unable to open reader file ' filename '.') :(freturn)

reader.read

        reader = new('seq')

reader.next

        line = (ident(filename) input, file)            :f(reader.eof)
        out(line)
        ident(line)                                     :s(reader.next)
        line '*'                                        :s(reader.next)
        ident(undent)                                   :s(reader.add)
        line span(' ') =

reader.add

        push(reader,line)                               :(reader.next)

reader.eof

*       Here at end of file; close temporary file if one was needed.

        differ(filename) endfile(setl4.config.channel.1):(return)

reader.end

        define('reader.str(str,delim)line')             :(reader.str.end)

*       _Reader.str_ returns a sequence of the lines in _str_, where
*       the character _delim_ is used to indicate end of line.
*       If _delim_ is  not given, then '/' is understood.

reader.str

        delim = ident(delim) '/'
        reader.str = new('seq')

reader.str.next

        str break(delim) . line delim =                 :f(return)
        push(reader.str,line)                           :(reader.str.next)

reader.str.end

        define('reduce(set,expr,n)e,this')              :(reduce.end)

*       According to Paul Halmos, in his book "Naive Set Theory,"
*       a major principle of set theory, often referred to by its
*       German name _Aussonderungsaxiom_, is the Axiom of Specification:

*       To every set _A_ and every condition _S(x)_ there corresponds
*       a set _B_ whose elements are exactly those elements _x_ of _A_
*       for which _S(x)_ holds.

*       In SETL4 we say that the expression '_A_ @ _S_' "reduces"
*       _A_ by _S_. This can also be read as
*               "the subset of _A_ such that _S_ is true"

*       _Reduce_ returns the subset of a set, map or sequence _set_
*        for which the given expresion is true.

*       _reduce(s,e)_ can also be written using the operator symbol '@':
*```
            s @ e
*```
*       that is, "the elements in _s_ at which _e_ is true.

*       If _n_ is not null, it gives an estimate of the size of the result.

reduce

        ident(set.kind(set),'map')                      :s(reduce.map)
        ident(set.kind(set),'seq')                      :s(reduce.seq)
        filter = new('set' (eq(n) '', ' #' n))
        loop(set)

reduce.set.next

        this = next(set)                                :f(return)
        eval(expr) add(filter,this)                     :(reduce.set.next)

reduce.map

        reduce = new('map')
        loop(set)


reduce.map.loop

        this = next(set)                                :f(return)
        eval(expr) push(reduce,value(this))             :(reduce.map.loop)

reduce.seq

        filter = new('seq')
        loop(set)

reduce.seq.loop

        this = next(set)                                :f(return)
        eval(expr) push(reduce,this)                    :(reduce.seq.loop)

reduce.end

        define('show(v,type,q)ara,i,kind,elem,entry,key,line,hdr,n,this,str,value'):(show.end)

*       _Show_ displays the value of its first argument in a form that is hopefully both
*       readable and pleasing to the eye.

*       If _type_ is not null, sets and maps are ranked in order given by _type_.
*       Otherwise sets and maps are increased in ascending value of members (set)
*       or keys (map).

*       If _q_ is not null, strings are not shown with enclosing quotes;
*       by default they are shown with enclosing quotes.

show

*       Show nothing by writing out nothing.

        ident(v)                                        :s(return)

        setl4.is.plain(v)  show.out(setl4.plain(v,q))   :s(show.finis)

        ident(datatype(v),'array')                      :s(show.array)
        ident(datatype(v),'entry')                      :s(show.entry)
        ident(datatype(v),'table')                      :s(show.table)
        ident(datatype(v),'iterator')                   :s(show.iterator)
        differ(datatype(v),'set') error('unexpected datatype to show, ' datatype(v))

        type = ident(type) '+k'
        kind = set.kind(v)
        ident(kind,'int')                               :s(show.int)
        ident(kind,'iter')                              :s(show.iter)
        ident(kind,'map')                               :s(show.map)
        ident(kind,'seq')                               :s(show.seq)
        ident(kind,'set')                               :s(show.set)
        error('show unknown set kind',kind,' quitting.')

show.array

        proto = prototype(ara)
        proto break(',')                                :s(show.array.2)

*       Here for one dimensional array.

show.array.1
        first = ara[add1(.i)]                           :f(show.array.done)
        show.out(lpad(i,3) tab first)                   :(show.array.1)

show.array.2
        first = ara[add1(.i),1]                         :f(show.array.done)
        show.out(lpad(i,3) tab show(first,type) tab show(ara[i,2],type)):(show.array.2)

show.array.done

                                                        :(show.finis)

show.entry

        setl4.is.plain(key(v)) setl4.is.plain(value(v)) :f(show.entry.notplain)
        show.out(setl4.plain(key(v),q) char(58) setl4.plain(value(v),q)):s(show.finis)

show.entry.notplain

        show(key(v))
        show.char(char(58))
        show(value(v))
                                                        :(show.finis)
show.iter

*       The iterator is the only meaningful part of a set of type iter
*       so reset _v_ to the iterator and show that.

        v = set.iter(v)
        show.out('{ iter')
        ne(+iter.start(v))  show.out(' start='  iter.start(v))
        ne(+iter.finis(v))  show.out(' finis='  iter.finis(v))
        ne(+iter.step(v))   show.out(' step='   iter.step(v))
        ne(+iter.next(v))   show.out(' next='   iter.next(v))
        show.out('} ')                                  :(show.finis)

show.iterator

        show.out('( iterator')
        ne(+iter.start(v))  show.out(' start='  iter.start(v))
        ne(+iter.finis(v))  show.out(' finis='  iter.finis(v))
        ne(+iter.step(v))   show.out(' step='   iter.step(v))
        ne(+iter.next(v))   show.out(' next='   iter.next(v))
        show.out(') ')                                  :(show.finis)

show.int
show.map
show.set
                                                        :(show.compound)

show.pair

        setl4.is.plain(first(v)) setl4.is.plain(second(v))    :f(show.pair.notplain)
        show.out('(' setl4.plain(first(v),q) ',' setl4.plain(second(v),q) ')'):(show.finis)

show.pair.notplain

        show.out(first(v))
        show.out(char(58))
        show(second(v))                                 :(show.finis)

show.seq


*       If the sequence has more than ten elements, change the encloser to '{}'

        set.encloser(v) = (le(#v,10) '()', '[]')
                                                        :(show.compound)

show.compound

        sorter(v,type)
        loop(v)
        show.out(substr(set.encloser(v),1,1))
        show.level = show.level + 1

show.compound.next

        elem = next(v)                                  :f(show.compound.done)
        setl4.is.plain(elem) show(setl4.plain(elem,q),,q) :s(show.compound.next)
        ident(kind,'int')  show(elem,,q)                :s(show.compound.next)
        ident(kind,'iter') show(elem,,q)                :s(show.compound.next)

*       show = ident(datatype(value(entry),'token'))
*                   show  show.token(v,,'TRUE')             :s(show.map.check)

        ident(kind,'map')   show(elem,,q)               :s(show.compound.next)

*       If showing a sequence, show only the value of element if less
*       than ten elements, otherwise show the element with the index.

        ident(kind,'seq') ident(set.encloser(v),'[]')   show(elem,,q):s(show.compound.next)
        ident(kind,'seq') ident(set.encloser(v),'()')   show(value(elem),,q):s(show.compound.next)

        ident(kind,'set')   show(elem,,q)               :s(show.compound.next)

show.compound.done

        show.level = show.level - 1
        show.out(substr(set.encloser(v),2,1))
                                                        :(show.finis)

show.table

        show.out('[')
        ara = convert(v,'array')                        :f(show.table.error)
        i = 0
        prototype(ara) break(',') . n                   :(show.table.next)

show.table.error

        error('error converting table to array')

show.table.next

        le(i = i + 1,n)                                 :f(show.table.done)
        show(ara[i,1],,q)                               :(show.table.next)

show.table.done

        show.out(']')                                   :(show.finis)

show.finis

        show.done()
                                                        :(return)

show.end

        define('show.char(ch)')                         :(show.char.end)

*       Show single character, not enclosed in blanks.

show.char

        show.line = show.line ch                        :(return)

show.char.end

        define('show.done()')                           :(show.done.end)

*       Write out _show.line_ unless in midst of showing compound object.

show.done

        le(size(show.line),72)                          :s(show.done.finis)

*       Here to write out long line.

        out(show.line)
        show.line =

show.done.finis

        gt(show.level)                                  :s(return)
        differ(show.line) out(show.line)
        show.line =                                     :(return)

show.done.end

        define('show.out(str)')                         :(show.out.end)

*       Append _str_ to _show.line_.

show.out

        str = differ(str,' ') integer(str) +str         :s(show.out.show)
        differ(datatype(str),'string')
.           error('show.out expects argument to be string, but got ' datatype(str))

show.out.show

        show.line = show.line (differ(show.line) ' ', '') str
*       show.line = show.line  str
        le(size(show.line),72)                          :s(return)
        out(show.line)
        show.line =                                     :(return)

show.out.end

        define('show.boolean(e)')                       :(show.boolean.end)

*       _Show.b_ shows the value if its argument as a boolean value: TRUE or FALSE

show.boolean

        integer(e) out((ne(e) 'TRUE', 'FALSE'))         :s(return)
        out((differ(e) 'TRUE', 'FALSE'))                :(return)

show.boolean.end

        define('show.eval(expr)e')                      :(show.eval.end)

*       _Show.eval_ evaluates its argument and returns 'true' if
*       the evaluation succeeded, or 'false' if not.

show.eval

        eval(expr)                                      :s(show.eval.success)
        show.eval = 'false'                             :(show.eval.finis)

show.eval.success

        show.eval = 'true'

show.eval.finis

        out('eval ' expr ' ' show.eval)                 :(return)

show.eval.end

        define('show.text(v)')                          :(show.text.end)

*       _Setl4.show.text_ yields same results as _show_ except that strings
*       are not enclosed in quotes.

show.text

        show(v,,'NOQUOTE')                              :(return)

show.text.end

        define('slice(v,start,n)')                      :(slice.end)

*       _Slice_ returns a slice of a sequence, string or tuple.
*       For a string _slice_ is equivant to SPITBOL's _substr_.

slice

        slice = ident(datatype(v),'string') substr(v,start,n):s(return)

*       Here to compute slice of a string or tuple.

        slice = new(set.kind(v))
        n = ident(n) #v - start + 1
        lt(start,1)                                     :s(freturn)
        gt(start + n - 1,#v)                            :s(freturn)
        start = start - 1

slice.next

        push(slice,get(v,start = start + 1))
        gt(n = n - 1)                                   :s(slice.next)f(return)

slice.end


        define('sorter(set,type)ara,entry,i,key,index.table,map,n,seq,str,tbl,value.table,value'):(sorter.end)

*       _Sorter_ sorts the index table of _set_ according to _type_ to reflect
*       a desired sort of the elements of set, keys or maps, or values of map.
*       _Sorter_ doesn't create a new set, but just updates the index table so that,
*       going forward, entries will be visited in the order specified by _type_.

*       _Sorter_ can also be used to put a string in normal form by converting the string
*       into a sequence of the characters in the string and then sorting the range
*       of the sequence.

*       The argument _type_ specifies the ordering to be used:

*           '+index'    increasing order of when entry created (oldest first)

*           '-index'    decreasing order of when entry created (most recent first)

*           '+key'      increasing order of the values in the domain

*           '-key'      decreasing order of the values in the domain

*           '+value'    increasing order of the values in the range

*           '-value'    decreasing order of the values in the range

*       Types for keys and values may be abbreviated: "+key" may be written
*       as "+k" or "+ke", "+value" as "+v" or +"val", and so forth.

sorter

*       Here to detect cases for which sort has no meaning, in which case
*       return immediately. This includes the case 'int' which, though possible
*       to sort as desired, requires a complicated algorithm that has yet to be
*       thought through.

        ident(datatype(set),'set') ident(set.kind(set),'int'):s(return)
        ident(datatype(set),'set') ident(set.kind(set),'iter'):s(return)

*       Use _sorter.string_ if input is a string.

        sorter = ident(datatype(set),'string') sorter.string(set):s(return)

        ident(type) error('sorter null type.')
        ident(type,'no')                                :s(return)
        n = #set
        index.table = set.index(set)

        type = get(sorter.types,type)

*       Nothing to do if set is empty or only has one element.

        le(n,1)                                         :s(return)
        differ(datatype(set),'set') error('sorter bad datatype ' datatype(set))
        ident(type) error('sorter null type')

        ident(type,'+v')                                :s(sorter.value)
        ident(type,'-v')                                :s(sorter.value)

        tbl = sorter.set(set,type)
        differ(datatype(tbl),'table') error('sorter result not table')
                                                        :(sorter.finis)
        i = 0

sorter.index.next

        error('why did we reach here')
        le(i = i + 1,n)                                 :f(sorter.finis)
        tbl[i] = set.index(set)[ara[i,1]]               :(sorter.index.next)

sorter.value

*       Here to  sort by value: build table mapping index numbers into
*       the values associated with their keys, and sort that.

        tbl = compose(set.index(set),set.key(set))
        type = ident(type,'+v') '+k'
        type = ident(type,'-v') '-k'
        value.table = sorter.table(set,type,tbl)
        i = 0

*       The table is in proper order, so replace values with the keys
*       associated with that value.

sorter.value.next

        le(i = i + 1,n)                                 :f(sorter.finis)
        tbl[i] = value.table[i]                         :(sorter.value.next)

sorter.finis

        set.index(set) = tbl                            :(return)

sorter.end

        define('sorter.set(set,type)ara,i,index')       :(sorter.set.end)

*       _Setl4.table.sorter_ returns an index table derived from the
*       index table of _set_ that reflects the ordering given by _type_.

sorter.set

        le(#set,1)                                      :s(return)
        ara = ident(type,'+i')    sort( set.index(set), 1):s(sorter.set.1)
        ara = ident(type,'-i')    rsort(set.index(set), 1):s(sorter.set.1)
        ara = ident(type,'+k')    sort( set.index(set), 2):s(sorter.set.1)
        ara = ident(type,'-k')    rsort(set.index(set), 2):s(sorter.set.1)

        error('sorter.set unsupported key type          : ' type)

sorter.set.1

        differ(datatype(ara),'array')
.                   error('sorter.set sort result not array:' datatype(ara))

        sorter.set = table(n)
        index = 0

sorter.set.set.next

        le(i = i + 1,n)                                 :f(return)
        index = ara[i,1]
        sorter.set[i] = set.index(set)[index]           :(sorter.set.set.next)

sorter.set.end

        define('sorter.string(str)ara,c,i,tbl')         :(sorter.string.end)

*       _Sorter_sorts a string into a string with all the characters
*       in lexical (alphabetic) order.

sorter.string

        tbl = table(size(str))

sorter.string.tbl

        c = substr(str,i = i + 1,1)                     :f(sorter.string.sort)
        tbl[i] = c                                      :(sorter.string.tbl)

sorter.string.sort

*       Sort the table and rebuild the string in sorter order.

        i = 0
        ara = sort(tbl,2)

sorter.string.next

        c = ara[i = i + 1,2]                            :f(return)
        sorter.string = sorter.string c                 :(sorter.string.next)

sorter.string.end

        define('sorter.table(set,type,tbl)ara,i,index') :(sorter.table.end)

*       _Setl4.table.sorter_ returns an index table derived from the
*       index table of _set_ that reflects the ordering given by _type_.

sorter.table

        le(#set,1)                                      :s(return)

        ara = ident(type,'+i')    sort(tbl,1)           :s(sorter.table.1)
        ara = ident(type,'-i')    rsort(tbl,1)          :s(sorter.table.1)
        ara = ident(type,'+k')    sort(tbl,2)           :s(sorter.table.1)
        ara = ident(type,'-k')    rsort(tbl,2)          :s(sorter.table.1)
        error('sorter.table unexpected type             :' type)

sorter.table.1

        sorter.table = table(n)
        index = 0

sorter.table.table.next

        le(i = i + 1,#set)                              :f(return)
        index = ara[i,1]                                :f(sorter.table.error)
        sorter.table[i] = index.table[index]
                                                        :(sorter.table.table.next)
sorter.table.error

        error('sorter.table error, array out of bounds reference.')

sorter.table.end

        define('split(line)word')                       :(split.end)

*       _Split_ splits a line into a sequence of words, where words are separated by one of more spaces.

split

        split = new('seq')
        line span(' ') =
        ident(line)                                     :s(return)
        line = line ' '

split.next

*       Here to split line into a sequence of its words.

        line break(' ') . word span(' ') =              :f(return)
        push(split, word)                               :(split.line.next)

split.end

        define('square.root(n)')                        :(square.root.end)

*       _Square.root_ returns the square root of its argument, rounded up.

square.root

        square.root = int(sqrt(n)) + 1                  :(return)

square.root.end

        define('subset(a,b)this')                       :(subset.end)

*       _Subset_ tests if its second argument is a subset of the first.
*       _b_ cannot be a subset if it has more members than _a_.

subset

        gt(#b,#a)                                       :s(freturn)
        loop(b)

subset.next

        this = next(b)                                  :f(return)
        member(this,a)                                  :s(subset.next)f(freturn)

subset.end

        define('this(set)')                             :(this.end)

*       _This_ returns the value determined in the most recent call to next.

this

        this = iter.thisname(set)                       :(return)

this.end

*#  Tokens: Lexical Scanning


*       A token is represented as an instance of the datatype _token_ as follows:

        data('token(lineno,col,type,text)')

*       where:
*               _lineno_        is the line number within the file;
*               _col_           is the index (column number) of the first character of the token in the line;
*               _type_          is the token's type, as described below; and
*               _text_          is the text of the token.

*       The type is represented by a single character, as follows:

*               'c'             comment, indicated by asterisk (*) in the first column.
*                               The text consists of the entire line.

*               'i'             integer, consisting of one or more digits ('0123456789')

*               'l'             left opener, one of '(<[{'

*               'p'             punctation, one of '.;,?!', or single quote (') or double quote ("),

*               'o'             other printable character, one of '~@#$%^&*_-+=`'.

*               'q'             quoted str, starting witn '"', and continuing to the next instance of the opening quote character.

*               'r'             right closer, one of ')>]}'

*               's'             space, consistine of one or more spaces (spaces)

*               't'             tab character

*               'u'             unprintable character, for example control-k

*               'w'             word, consisting of one of more letters in upper or lowercase, or "'" or "_".

*       The longest possible string meeting the rules is used when building a token.
*       For example, 'abc' is just the word 'abc', not 'a' followed by 'bc', and so forth.

*       It is recommended that the tab character NOT be used as an abbreviation for
*       one or more spaces in the input file. If tabs are used, then _col_ is ill-defined.
*       If tabs are not used, then _col_ indicates the true position in the line of
*       the first character of the token, and so error messages and references to the
*       token will be exact.  For example, _pos_ could be used to indicate where to give
*       emphasis to a token by underlining it, or enclosing it in '_' to generate
*       markdown format, and so forth.

        define('tokens(line)type,pos,text,lineno')      :(tokens.end)

*       _Tokens_ scans a line _line_ and returns a table of the tokens in the line.
*       The table has keys from 1..n, where _n_ is the number of tokens found.

*       This function is an instance of what is called a lexical scanner, or tokenizer.
*       This is the first stage in a programming language compiler, or for any program
*       that processes text files with a specified structure.

tokens

        tokens = new('seq')
        line '*'                                        :f(tokens.next)
        type = 'c'
        text = line
        line =                                          :(tokens.new)

tokens.next

        line ' '                                        :s(tokens.space)
        line any('0123456789')                          :s(tokens.integer)
        line any('(<[{')                                :s(tokens.left)
        line any('.;,?!')                               :s(tokens.punctuation)
        line '"'                                        :s(tokens.quote)
        line any('~@#$%^&*_-+=')                        :s(tokens.other)
        line any(')>]}')                                :s(tokens.right)
        line char(9)                                    :s(tokens.tab)
        line any(&lcase &ucase)                         :s(tokens.word)

*       Here for unprintable
        error('unprintable?? fix in tokens')

tokens.integer

        type = 'i'
        line span('0123456789') . text =                :(tokens.new)

tokens.punctuation

        type = 'p'                                      :(tokens.character)

tokens.other

        type = 'o'                                      :(tokens.character)

tokens.quote

        type = 'q'
        line '"' break('"') . text '"' =
        text = '"' text '"'                             :(token.new)

tokens.right

        type = 'r'                                      :(tokens.character)

tokens.space

        type = 's'
        line span(' ')  . text =                        :(tokens.new)

tokens.tab

        type = 't'                                      :(tokens.character)

tokens.word

*TODO*
        type = 'w'
        line span(&ucase &lcase "_" "'") . text =       :(tokens.new)

tokens.character

*       Here if token is single character.

        line len(1) . text                              :(tokens.new)

tokens.new

        setl4.add(tokens,token(lineno,pos,type,text))   :(tokens.next)

tokens.end

        define('tolower(s)')                            :(tolower.end)

*       _Lower.case_ converts argument to tolower.

tolower

        tolower = replace(s,&ucase,&lcase)              :(return)

tolower.end

        define('top(seq)')                              :(top.end)

*       _Top_ returns the last element of a sequence, or fails if the sequence is empty.

top

        differ(datatype(seq),'set')  error('argument to top is not a set')
        eq(#seq)                                        :s(freturn)
        ident(set.kind(seq),'seq')                      :s(top.get)
        error('argument to top() is not sequence or tuple.')

top.get

        top = get(seq,#seq)                             :(return)

top.end

        define('toupper(s)')                            :(toupper.end)

*       _Upper.case_ converts its argument to toupper.

toupper

        toupper = replace(s,&lcase,&ucase)              :(return)

toupper.end

        define('traceoff()')                            :(traceoff.end)

*       _Traceoff_ ends tracing.

traceoff

        &ftrace = &trace =
        out('stop TRACING ')

traceoff.end

        define('traceon()')                             :(traceon.end)

*       _Traceon_ begins tracing.

traceon

        out('start TRACING')
*       &ftrace = &trace = 1500000
        g.scoring = g.tracing = 1
                                                        :(return)
traceon.end

        define('true(e)')                               :(true.end)

*       _True_ Tests if its operand is true (not null).

true

        e = integer(e) +e
        integer(e) ne(e)                                :s(return)
        differ(e)                                       :s(return)f(freturn)

true.end

        define('union(a,b)this')                        :(union.end)

*       _Union_ returns the union of sets _a_ and _b_.

union

union.a

        union = new('set ' (#a + #b))
        loop(a)

union.a.next

        this = next(a)                                  :f(union.b)
        add(union,this)                                 :(union.a.next)

union.b

        loop(b)

union.b.next

        this = next(b)                                  :f(return)
        add(union,this)                                 :(union.b.next)

union.end

        define('unpack(str)seq,ch')                     :(unpack.end)

*       Unpack string _str_ into sequence of its characters.

unpack

        unpack = new('seq')

unpack.next

        str len(1) . ch =                               :f(return)
        push(unpack, ch)                                :(unpack.next)

unpack.end

        define('visit(set,expr)this')                   :(visit.end)

*       _Visit_ loops over _set and calls _eval_ with argument
*       _expr_  for each of member of the set.

visit

        loop(set)

visit.next

        this = next(set)                                :f(return)
        eval(expr)                                      :(visit.next)

visit.end

        define('words(line,w)pat,word')                 :(words.end)

*       _Words_ returns a sequence of the words in _line_, where _w_
*       is a string that defines the allowed characters in a word.
*       If _w_ is null, the a word consists of consecutive upper or
*       lower case letters.

words

        words = new('seq')
        w = ident(w) &ucase &lcase
        pat = span(w)

words.next

        line pat . word =                               :s(words.add)

*       No word begins at this character, so move on to the next one.

        line len(1) =                                   :f(return)s(words.next)

words.add

        push(words, word)                               :(words.next)

words.end

        define('writer(lines)')                         :(writer.end)

*       _Writer_ writes the lines in the sequence _lines_ to standard output.

writer

        loop(lines)

writer.next

        output = next(lines)                            :f(return)s(writer.next)

writer.end

*## SETL4 internal functions

*       Functions whose names begin with _setl4_ are for internal use only, and are
*       not meant to be called directly by the SETL4 user.

*       Their definitions and implmentations may change at any time, so use them
*       directly at your own peril.


        define('setl4.begins(str,init)')                      :(setl4.begins.end)

*       _Begin_ tests if string _str_ setl4.begins with string _init_.
*       It returns _str_ on success, fails otherwise.

setl4.begins

        ident(str)                                      :s(freturn)
        ident(init)                                     :s(freturn)
        setl4.begins = str
        ident(str,init)                                 :s(return)
        gt(size(init),size(str))                        :s(freturn)
        ident(substr(str,1,size(init)),init)            :s(return)f(freturn)

setl4.begins.end

        define('setl4.clear()')                         :(setl4.clear.end)

*       _Setl4.clear) clears the values of setl4 global variables,
*        in order to reduces amount of &dump output.

setl4.clear

        setl4.config.set.table.size = setl4.config.stack = setl4.config.set.table.size = setl4.config.int =
.       setl4.config.int.init = setl4.random.initialized = setl4.any.digit = setl4.span.digits =
.       setl4.break.digit = setl4.break.letter = setl4.any.letter =
.       setl4.span.letters = setl4.span.spaces = setl4.break.space =
.       setl4.any.word = setl4.span.word = setl.sorter.map = sorter.types =
                                                        :(return)
setl4.clear.end

        define('setl4.is.plain(v)')                     :(setl4.is.plain.end)

*       Tests if _v_  has a plain type.
*       The plain types are 'integer', 'name', 'real', and 'string'.

setl4.is.plain

        ident(v)                                        :s(return)
        ident(datatype(v),'integer')                    :s(return)
        ident(datatype(v),'name')                       :s(return)
        ident(datatype(v),'real')                       :s(return)
        ident(datatype(v),'string')                     :s(return)
                                                        :(freturn)

setl4.is.plain.end

        define('setl4.plain(v,q)')                      :(setl4.plain.end)

*       Tests if _v_ is a setl4.plain type, where the setl4.plain types are _entry_, _integer_,
*       _pair_, _real_, and _string_. If _v_ is setl4.plain, then _setl4.plain_ returns its
*       value as a string. Otherwise, _v_ is returned as the value.

*       The value of a string is enclosed in quotes unless _q_ is not null.

setl4.plain

        ident(v)                                        :s(return)
        setl4.plain = v
        setl4.is.plain(v)                               :f(return)
        setl4.plain = integer(v) +v                     :s(return)

*       Nothing to be done if argument is not string.

        ident(datatype(v),'string')                     :s(setl4.plain.string)
        error('unexpected input type to setl4.plain, ' datatype(v))

setl4.plain.string

*       Return string with no enclosing quotes if _q_ is not null.

        ident(q)                                        :s(setl4.plain.quote)
        setl4.plain = v                                 :(return)

setl4.plain.quote

*       Here to enclose string in quote characters.

        setl4.plain '"'                                 :s(return)
        setl4.plain "'"                                 :s(return)
        v break("'")                                    :s(setl4.plain.double)

*       Here if arguent does not contain a single quote, so use single quotes around it.

        setl4.plain = "'" v "'"                         :(return)

setl4.plain.double

*       Here if arguent contains single quote, so use double quotes around it.

        setl4.plain = '"' v '"'                         :(return)

setl4.plain.end

        define('setl4.show(set)iter')                   :(setl4.show.end)

*       Setl4.show_ shows  the fields of an instance of _set_ or _iterator_.

setl4.show

        ident(datatype(set),'iterator')                 :s(setl4.show.iter)
        ident(datatype(set),'set')                      :s(setl4.show.set)
                                                        :(return)

setl4.show.iter

        setl4.show =  out('(iterator '
.                (ne(iter.start(set)) ' start           :'     +iter.start(set), '')
.                (ne(iter.finis(set)) ' finis           :'     +iter.finis(set),'')
.                (ne(iter.step(set))  ' step            :'      +iter.step(set),'') ')' )
                                                        :(return)

setl4.show.map
setl4.show.seq
setl4.show.set

        iter = set.iter(set)
                                            out('{')
                                            ne(#set) out('size',#set)

        differ(set.index(set)) differ(set.key(set))
.                                           out('  has index and key tables')

*       differ(set.index(set))              out('  has index table')
*       differ(set.key(set))                out('  has key table')

*       differ(iter)                        out('  has iterator')
        differ(iter) ne(iter.start(iter))   out('  start',    iter.start(iter))
        differ(iter) ne(iter.finis(iter))   out('  finis',    iter.finis(iter))
        differ(iter) ne(iter.step(iter))    out('  step',     iter.step(iter))
                                            out('}')
        differ(set.index(set)) differ(datatype(set.index(set)),'table')
.               error(' set.index is not table')
        differ(set.key(set)) differ(datatype(set.key(set)),'table')
.               error('set.key is not table')
                                                        :(return)
setl4.show.end

        define('Out(text1,text2,text3)type1,type2')     :(Out.end)

*       _Out_ is just another name for _out_. Use it for debugging, as
*       will be the be easy to find calls to it, so can delete them
*       once they have served their purpose.

Out

        out(text1,text2,text3)                          :(return)

Out.end


*## SETL4 Global variables

*       setl4.path is the home directory for setl4. It is specified by the environment
*       variable SETL4PATH.

        setl4.path =
        setl4.random.initialized =
        setl4.random.value = 2017

*       Useful patterns

        setl4.any.digit         =   any('0123456789')
        setl4.span.digits       =   span('0123456789')
        setl4.break.digit       =   break('0123456789')

        setl4.break.letter      =   break(&lcase &ucase)
        setl4.any.letter        =   any(&lcase &ucase)
        setl4.span.letters      =   span(&lcase &ucase)
        setl4.span.spaces       =   span(' ' char(9))
        setl4.break.space       =   break(' ' char(9))

        setl4.any.word          =   any(&lcase &ucase '0123456789')
        setl4.span.word         =   span(&lcase &ucase '0123456789')

        setl4.random.value      = 2017
*       sorter.types gives valid values for the argument _type_ in the function _sorter()_

        sorter.types = new('map '
.          '+:+k +k:+k +ke:+k +key:+k -:-k -k:-k -ke:-k -key:-k '
.          '+v:+v +va:+v +val:+v +valu:+v +value:+v -v:-v -va:-v -val:-v -valu:-v -value:-v '
.          '+i:+i +in:+i +ind:+ +inde:i+i +index:+i -i:-i -in:-i -ind:- -inde:i-i -index:-i')

*       Show.level is set non-zero when listing elements within a compound object.

        show.level = 0

*       _setl4.config.library.texts_ is a set of the names of the available texts.

        setl4.config.library.texts = new('set dictionary genesis hamlet new-testament old-testament romeo-and-juliet shakespeare sonnets')

*  _Setl4.opsyn_ uses _opsyn_ to define a SETL4 operator.

setl4.op

*  SETL4 uses some of the undefined SPITBOL operators for SETL4 functions.

*  Characters available for use by 'opsyn' to associate the character
*  with a function.

*  binary  &  @  #  %  ~
*  unary:  !  %  /  #  =  | /



        opsyn('=','this',       1)
        opsyn('@','filter',     2)
        opsyn('~','member',     2)

*       Here endeth the SETL4 code.
*       May you fare well using it.


        define('setl4.init()home')                      :(setl4.init.end)

*       Initialize setl4 system.
*       A value for SETL4PATH is required in order for 'checkout' to locate the
*       library files.

setl4.init

*       Get value of SETL4PATH from environment, ending if it is not set.

        setl4.path = host(4,"SETL4PATH")
        ident(setl4.path) error("SETL4PATH not defined.")
                                                        :(return)

setl4.init.end

        setl4.init()

