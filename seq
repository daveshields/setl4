
    define('seq.add(seq,val)')                      :(seq.add.end)

seq.add

    setl4.seq.room(seq)
    seq.add = seq.push(seq,val)                     :(return)

seq.add.end

    define('seq.get(seq,i)')                        :(seq.get.end)

*   Gets the value of element _i_ in the sequence _seq_

seq.get

    seq.get = set.seq(seq)[i]                       :f(freturn)s(return)

seq.get.end

    define('seq.integers(n)i')                      :(seq.integers.end)

*   Returns sequence of integers in the range 1 .. _n_.

seq.integers

    seq.integers = new('seq ' n)

seq.integerl.next

    gt(i = i + 1, n)                                :s(return)
    setl4.seq.room(seq)
    seq.push(seq.integers,i)                        :(seq.integerl.next)

seq.integers.end

    define('seq.push(seq,value)')                   :(seq.push.end)

seq.push

    assert.type(seq,'set')
    assert(ident(set.kind(seq),'seq'))
    value = integer(value) +value
    setl4.seq.room(seq)
    set.size(seq) = set.size(seq) + 1
*    str.out('seq.add',value)
    set.seq(seq)[set.size(seq)] = value             
                                                    :(return)

seq.push.end

    define('seq.put(seq,i,value)v,len')             :(seq.put.end)

*   Sets the value of element _i_ in the sequence _seq_ to be _value_.

seq.put

    assert(ident(kind(seq),'seq'))
    set.seq(seq)[i] = value                         :(return)

seq.put.end

    define('seq.range(seq)')                        :(seq.range.end)


*    Return set with the values in _seq_ as its members.

seq.range

    kind = kind(seq)
    output = differ(kind,'seq') 'range called on non-seq, quitting' :s(end)
    seq.range = set.new()
    loop(seq)

seq.range.next

    set.add(seq.range,set.next(seq))                :f(return)s(seq.range.next)

seq.range.end

