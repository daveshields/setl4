*       Copyright 2017, David Shields
*       Licensed under the MIT license.

*       Boolean Logic
*       -------------

*       Boolean logic is a form of algebra with just two values: true and false.

*       In SPITBOL, the algebra is defined on strings: the null string is "false"
*       and all other strings are "true."
*       IDENT is used to test for true, DIFFER for false. Both signal their
*       results by success (true) or failure (false).

*       In SETL4, the algebra is defined on the integers: zero is "false"
*       and all other integers are "true."
*       _eq_ is used to test for false, _ne_ for true.


        false = 0
        true = 1

*       Sets
*       ____
        

*       A set is a collection of values, in no particular order.
*       SETL4  implements a set as a map for which the value
*       of the elements of the set is "true."


	data('set(set.table,set.count,set.next)')

*       Maps: Functions
*       --------------

*       In mathematics, a map, or function, is a set of ordered pairs that define a relation between
*       the first element of a pair, called the domain value, and the second value of the pair, called
*       the range value.


*	A _pair_ joins two values together. 

        data('pair(first,second)')

*       The SPITBOL datatype TABLE provides the machinery to implement maps.
*       SPITBOL provides no way to determine the number of domain values, or size, of
*       a map other than converting the map to an array, which is only way to iterate
*       over a map.

*       SETL4 represents a map using the following data structures:

*       _entry_ is used to maintain a key/value pair.

        data('entry(key,value)')

	data('map(map.table,map.count,map.next)')

*	where

*		_map.table_ is the table used to maintain the key/value pairs of the map.

*		_map.count_ is the current size of the map.

*		_map.next_ is used when iterating over the map.


*       Sequences.
*       ----------

*       A sequence is a map defined on the positive integers: 1,2, ... ,n.

        data('sequence(sequence.table,sequence.next,sequence.count)')

*               _sequence.count_ is the length of the sequence.

*               _sequence.table_ is the map representing the sequence.

*               _sequence.next_ is used to iterate over the sequence.


*       Stacks
*       ------

*       A stack is a sequence with a limited set of operations.

        data('stack(stack.table,stack.size)')

*               _stack.table_   is the table used to maintain the stack.

*               _stack.size_    is the number of entries in the stack.


*	Lines
*	-----

*	Lines can be just strings or, in some cases, a line is represented by a pair:

	data('line(mark,text)')

*	where

*		_mark_ is defined by the value returned by an instance
*		of the _eval_ function ...

*		_text_ is the text of the line.

*	For example, the _reader_ function reads a file and returns a sequence of _lines_.

        define('false(e)')                              :(false.end)

*       Returns true if its argument is false, or else false.

*FALSE*
false

        false = (eq(e) true, false)                     :(return)

false.end

        define('true(e)')                              :(true.end)

*       Returns true if its argument is true, or else false.

*TRUE*
true

        true = (ne(e) true, false)			:(return)

true.end

        define('and(b1,b2)')                		:(and.end)

*       Returns true iff (if and only if) both arguments are true.

*AND*
and

	and = (true(b1) true(b2) true, false)		:(return)

and.end

        define('or(b1,b2,b3,b4,b5,b6)')                 :(or.end)

*       Returns true iff (if and only if) at least one argument is true.

*OR*
or

	or = (true(b1) true, true(b2) true, false)	:(return)

or.end

*
*       The positive integers are the integers in the set 1..n.

*       Basic Functions on Integers
*       ---------------------------

*                even(n)         true iff n is even.
*                odd(n)          true iff n is odd.
*                prime(n)        true iff n is a prime number
*                factorial(n)    returns the value of n! = n * (n - 1) * ... * 


        define('even(n)')                                  :(even.end)

*       Returns true iff n is even.

*EVEN*
even

        even = (eq(remdr(n,2)) true,false)               :(even.end)

even.end

	define('factorial(n)')				:(factorial.end)

*	Returns n! = n*(n-1)*(n-2) ... 1

factorial

	factorial = (eq(n,1) 1, n * factorial(n -1))	:(return)

factorial.end

        define('odd(n)')                           	:(odd.end)

*       Returns true iff n is odd.

*ODD*
odd

        odd = (ne(remdr(n,2)) true,false)               :(odd.end)

odd.end

	
        define('prime(n)')                                :(prime.end)

*       Returns true iff n is prime.

*PRIME*
prime


        terminal = 'prime not implemented'             :(error)
        prime = (eq(remdr(n,2)) true,false)             :(prime.end)

prime.end

        define('string.append(str,w,ch)')                      :(string.append.end)

*	_string.append_ string.appends _ch_, or ' ' if _ch_ is null, to _str_
*	and then string.appends _w_.

*STRING.APPEND*
string.append

        string.append = (ident(str) w, str (ident(ch) ' ' , ch) w):(return)

string.append.end

        define('string.ascii(line)c,n,name,nul,num,pos')       :(string.ascii.end)

*       Return the text of line with every string.ascii character identified.

*ASCII*
string.ascii
        nul = substr(&alphabet,1,1)

string.ascii.next
        
*       Add space after previous character if result not null.

        string.ascii = differ(string.ascii) string.ascii ' '
        c = substr(line,1,1)                            :f(string.ascii.done)
        ident(c,nul)                                    :s(string.ascii.null)
*       output = 'string.ascii c[' c ']'
        line any('0123456789')                          :s(string.ascii.integer)
        line any(&lcase &ucase)                         :s(string.ascii.letter)
        line ' '                                        :s(string.ascii.space)

*       Check for control character (code <=26)

        &alphabet break(c) . pos                        :f(string.ascii.other)
        pos = size(pos) 
*       output = 'pos of [' c '] is [' pos ']'
        gt(pos,26)                                      :s(string.ascii.other)
        string.ascii = string.ascii g.string.ascii.name[c] '(^'  substr('ABCDEFGHIJKLMNOPQRSTUVWXYZ',pos,1) ')' 
        line len(1) =                                   :(string.ascii.next)

string.ascii.integer

        line span('0123456789') . text =
*       output = 'string.ascii num [' text ']'
        string.ascii = string.ascii  text                             :(string.ascii.next)

string.ascii.letter

        line span(&lcase &ucase) . text =
*       output = 'string.ascii letter [' text ']'
        string.ascii = string.ascii  text                             :(string.ascii.next)

string.ascii.null

        string.ascii = string.ascii 'NUL'                             :(string.ascii.next)

string.ascii.other
                
*       Here if none of the other cases apply, so just list the string.ascii name.

        string.ascii = string.ascii g.string.ascii.name[c]                   
        line = substr(line,2)                           :(string.ascii.next)

string.ascii.space

        line span(' ') . text =
*       output = 'string.ascii space [' text ']'
        
        string.ascii =  string.ascii 'SPC'
        string.ascii = gt(size(text),1) string.ascii 'SPC*' size(text)
        string.ascii = string.ascii 
                                                        :(string.ascii.next)
string.ascii.done

        string.ascii = trim(string.ascii)                             :(return)

string.ascii.end

        define('string.ascii.init(init)name,val')              :(string.ascii.init.end)

*       Initialize maps for use by _string.ascii_.
*       Since space (string.ascii 32) prints as space, use the name SPC for 32.

*ASCII.INIT*
string.ascii.init


        string.ascii.init = map.map(
.       '0:NUL 16:DLE 48:0 64:@ 80:P 96:`:112:p '
.       '1:SOH 17:DC1 33:! 49:1 65:A 81:Q  97:a 113:q '
.       '2:STX 18:DC2 34:" 50:2 66:B 82:R  98:b 114:r '
.       '3:ETX 19:DC3 35:# 51:3 67:C 83:S  99:c 115:s '
.       '4:EOT 20 DC4 36:$ 52:4 68:D 84:T 100:d 116:t '
.       '5:ENQ 21:NAK 37:% 53:5 69:E 85:U 101:e 117:u '
.       '6:ACK 22:SYN 38:& 54:6 70:F 86:V 102:f 118:v '
.       "7:BEL 23:ETB 39:' 55:7 71:G 87:W 103:g 119:w "
.       '8:BS  24:CAN 40:( 56:8 72:H 88:X 104:h 120:x '
.       '9:HT  25:EM  41:) 57:9 73:I 89:Y 105:i 121:y '
.       '10:LF 26:SUB 42:*:58 : 74:J 90:Z 106:j 122:z '
.       '11:VT 27:ESC 43:+:59 ; 75:K 91:[ 107:k 123:{ '
.       '12:FF 28:FS  44:,:60 < 76:L 92:\ 108:l 124:| '
.       '13:CR 29:GS  45:-:61 = 77:M 93:] 109:m 125:} '
.       '14:SO 30:RS  46:.:62 > 78:N 94:^ 110:n 126:~ '
.       '15:SI 31:US  47:/:63 ? 79:O 95:_ 111:o 127:DEL ') 

        g.string.ascii.name = map.map(128)
        g.string.ascii.val = map.map(128)
        

	map.loop(string.ascii.init)

string.ascii.init.next

	ent = map.next(string.ascii.init)			:(string.ascii.init.finis)
	g.string.ascii.name[substr(&alphabet,+v + 1,1)] = name
	g.string.ascii.val[name] = +val			:(string.ascii.init.next)


*       Correct entry for 32 to be SPC, the space character
*       Correct entry for 0 to be NUL, the NUL character

        g.string.ascii.name[] = 'NUL'
        g.string.ascii.val['NUL'] = 0  
        g.string.ascii.name[' '] = 'SPC'
        g.string.ascii.val['SPC'] = 32                         :(return)
        
string.ascii.init.end

        define('string.datename(date)s')                       :(string.datename.end)

*       Convert date to form with no spaces, just dashes, to be
*       suitable for use as part of a file name.

*STRING.DATENAME*
string.datename

        string.datename = replace(date,' :/','---')
        string.datename = substr(string.datename,12,8) '-' substr(string.datename,1,10)
                                                        :(return)
string.datename.end

	define('string.frequency(string)')		:(string.frequency.end)

*	Return map from the characters in a string to the number of times
*	each occurs in the string.

STRING.FREQUENCY*
string.frequency
	
	string.frequency = map(50)

string.frequency.next

	string len(1) . c = 				:f(string.frequency.end)
	map.put(string.frequency,c,map.get(string.frequency,c) + 1)	:(string.frequency.next)

string.frequency.end

        define('string.lower(s)')                              :(string.lower.end)

*       Convert argument to lower case.

*STRING.LOWER*
string.lower

        string.lower = replace(s,&ucase,&lcase)                :(return)

string.lower.end

        define('string.spaces(line)c')                         :(string.spaces.end)

*       Returns string which has ' ' in position _i_ if the _i_-th
*	characer in _string_ is a space (' '), or '*' otherwise.


        define('string.less(str,sub)before,after')             :(string.less.end)

**      Less removes the first instance of each character in SUB from *str*,
**      where SUB is a substring of *str*.

*STRING.LESS*
string.less
        ident(str)                                      :s(return)
        string.less = str

string.less.ch
        sub len(1) . ch =                               :f(return)
        string.less break(ch) . before  ch rem . after
        string.less = before after                             :(string.less.ch)

string.less.end

        define('string.prefix(str,pre)word')                   :(string.prefix.end)

*       Prefix takes a list of space-separated words str and string.prefixes each
*       with the string pre.

*STRING.PREFIX*
string.prefix

        str = str ' ';* so each word followed by space

string.prefix.1

        str break(' ') . word span(' ')  =              :f(return)
        add1(.string.prefixcount)
        string.prefix = append(string.prefix, pre word,'A')           :(string.prefix.1)

string.prefix.end

	define('string.slice(str,first,last)')		:(string.slice.end)

*STRING.SLICE*
string.slice

	string.slice = substr(str,first,last)		:(return)

string.slice.end

*STRING.SPACES*
string.spaces

	line len(1) . c					:f(return)
	string.spaces = string.spaces (ident(c,' ') ' ', '*')		:(string.spaces)

string.spaces.end
        define('string.upper(s)')                              :(string.upper.end)

*       Convert argument to upper case.

*STRING.UPPER*
string.upper

        string.upper = replace(s,&lcase,&ucase)                :(return)

string.upper.end

        define('map.domain(map)entry)')			:(map.domain.end)

*       Return set with the keys in _map_.

map.domain

	map.domain = set.new(#map)
        map.loop(map)

map.domain.next

        entry = map.next(map)                           :f(return)
        set.add(map.domain,key(entry))               	:(map.domain.next)

map.domain.end

	define('map.equal(a,b)entry,key,value')		:(map.equal.end)

*	Test two maps for equality. 

*	Two maps are equal if they have the same size and the value 
*	of the first map for each element in its domain is the same 
*	as the value of the second map for the corresponding element.

map.equal

	map.equal = ne(#a,#b) false			:s(return)
	map.loop(map)

map.equal.next

	entry = map.next(map)				:f(map.equal.done)
	key = key(entry)
	value = value(entry)
	ident(value(map.get(map,key(entry))),
.         value(map.get(omap,key(entry)))) :s(map.equal.next)f(return)

map.equal.done

	map.equal = true				:(return)

map.equal.end
	
	define('map.eval(map,s)entry,pair,map.apply.result')	:(map.eval.end)

*	_map.eval returns the map obtained by evaluating _eval(s)_ for each
*	pair in the map. The expression _s_ may use _pair_ to reference this pair.
*	_eval(s) should return a pair; it is used to construct the next entry in the
*	result map. The entry is ignore if the call to _eval_ fails.

map.eval

	map.eval = map.new(#map)
	map.loop(map)
	result =

map.eval.next

	entry = map.next(map)				:f(return)
	pair = eval(s)					:f(map.eval.next)
	map.put(map.eval,first(pair), second(pair))	:(map.eval.next)

map.eval.end

        define('map.forall(s,map)entry')		:(map.forall.end)

* TODO
* NEED TO RETHINK THIS.
*	_map.forall_ returns a result defined by iterating over all the
*	entries in _map_. In each step of the iteration, _eval_ 
*	is evaluated using _eval_, with the variable _entry_ being set
*	to the current entry of the iteration.

*	_map_forall_ returns the last value so defined.
*	_map.forall_ returns a new map defined by iterating over _map_
*	and using _f_ to define each entry by calling _map.apply.entry_.


*	For example, the length of the largest key of a map on strings could
*	be found by having each call set resuslt to the length of the largest key so far seen.

map.forall

        map.forall = map.new(#map)
        map.loop(map)

map.forall.next

	map.put(map,map.apply.entry(f,map.next(map)))	 :s(map.forall.next)

	map.forall = result				:(return)

map.forall.end

        define('map.foreach(map,f)entry,pair')               :(map.foreach.end)

*        Returns a map defined by iterating over the entries in _map_, and applying
*        f to the entry to define a new entry in the result.

map.foreach

        map.foreach = map.new(#map)

map.foreach.next

        pair = first(apply(f,map.next(map)))                    :f(return)
        map.put(map.foreach, entry.first(pair),second(pair))	:(map.foreach.next)

map.foreach.end

        define('map.get(key,val)')                  :(map.get.end)

*       Gets the value of the key _key_ in the map _map_.

map.get

        map.get = map.table(map)[key]                   :(return)

map.get.end

	define('map.inverse(map)entry')			:(map.inverse.end)

*	_map.inverse_ returns the inverse of a map. The inverse is
*	a map with the keys and values of _map_ reversed. 

map.inverse

	map.inverse = map.new(#map)
	map.loop(map)

map.inverse.next

	entry = map.next(map)				:f(return)
	differ(map.get(map.inverse,value(entry)))	:s(freturn)
	map.put(map.inverse,value(entry), key(entry))  :(map.inverse.next)

map.inverse.end

        define('map.loop(map,kind)')                    :(map.loop.end)
*TODO*
*       Returns an iterator for _map_. Use _map.next_ to retrieve
*       the next entry in map. _map.next_ fails when no more entries remain.

*       _kind_ gives the kind of loop:

*               '+order'        iterate in order in which entries added. (default)
*               '-order'        iterate in reverse order in which entries added.
*               '+key'          iterate in incresing values of keys.
*               '-key'          iterate in decceasing values of keys.
*               '+val'          iterate in incresing values of values.
*               '-key'          iterate in decreasing values of keys.

*       Otherwise iterate over the keys in the order in which they were added to the map.

map.loop

        map.next(map) = 0
        ident(kind)                                     :s(map.loop.order)
        ident(kind, '+order')                           :s(map.loop.key.order.inc)
        ident(kind, '-order')                           :s(map.loop.key.order.dec)
        ident(kind, '+key')                             :s(map.loop.key.inc)
        ident(kind, '-key')                             :s(map.loop.key.dec)
        ident(kind, '+val')                             :s(map.loop.value.inc)
        ident(kind, '-val')                             :s(map.loop.value.dec)

map.loop.order.inc

        map.array(map) = convert(map.table(map),'array'):(map.done)

map.loop.rorder.inc

        output = 'loop rorder not implemented '         :(nosuchlabel)
        map.array(map) = convert(map.table(map),'array'):(map.done)

map.loop.key.inc

        map.array(map) = rsort(map.table(map),1)        :(return)

map.loop.key.dec

        map.array(map) = sort(map.table(map),1)         :(return)

map.loop.value.inc

        map.array(map) = rsort(map.table(map),2)        :(return)

map.loop.value.dec

        map.array(map) = sort(map.table(map),-2)        :(return)

map.loop.end

        define('map.new(init,n)i,key,str,valr')         :(map.new.end)

*       Create a new map.

*       A sequence is a list of values *  separated by spaces.

*               map       _init_ is a list consisting of a list of key/value pairs,
*			
*                               with a colon (:) between the key and value.

map.new
	ouput = 'enter map.new'

        map.new = ident(init) map(table(128))           :s(return)
        kind = ident(kind) 'map'
        output = 'enter map.new [' init ']'
        init break(':')                                	:s(map.new.keyval)
        map.new = map(table(i))                         :(return)

map.new.keyval
        
        map.new = map(table(128))

map.new.keyval.next

        init break(':') . key ':' break(' ') . val span(' ') =	:f(return)
        map.put(map.new,key,val)                        :(map.new.keyval.next)

map.new.end

        define('map.next(map)')                         :(map.next.end)

*       _map.next_ returns the next entry in a map, or fails if no entries remain.

map.next

        le(map.next(map) = map.next(map) + 1, #map)	:f(freturn)
        map.next = entry(map.array[map.next(map),1],map.array[map.next(map),2]):(return)

map.next.end

        define('map.range(map)')                    	:(map.range.end)


*NOTE This should be in SET

*        Return set with the values in _map_.


map.range

        map.range = map.sequence()
        map.loop(map)

map.range.next

        map.range.add(entry.value(map.next(map)))        :f(return)s(map.range.next)

map.range.end

	define('map.reduce(map,f)entry,result')	:(map.reduce.end)

*	_map.reduce_ returns a new map by iterating over the elements in
*	_map_ and evaluatibg _f(entry)_ on each entry.
*	_test_ must be the name of the functiono to be used for the test.
*	The entry is added if the result, or is ignored otherwise.

map.reduce

	map.reduce = map(#map)
	map.loop(map)

map.reduce.next

	entry = map.next(map)
*	false(apply(test,entry)			:s(map.reduce.next)
	map.put(map.reduce,key(entry),value(entry))	:(map.reduce.next)

map.reduce.end

        define('map.put(key,val)v')                 :(map.put.end)

*       Sets the value of the entry for key _key_ in map _map_ to be _val_, 
*       creating a new entry if there is no current entry for _key_.

map.put

*        output = 'enter map.put dt ' datatype(map) ' key [' key '] val [' val ']'
        v = map.table(map)[key]
        differ(v)                                       :s(map.put.value)

*       Here to create new entry in map.

        map.count(map) = #map + 1

map.put.value

        map.table(map)[key] = val                       :(return)

map.put.end

	define('map.size(map)')				:(map.size.end)

*	Returns number of entries in map _map_.

map.size

	map.size = #map					:(return)

map.size.end

        define('map.test(key)')                     	:(map.test.end)

*       Tests if the map _map_ has an entry for _key_.

map.test

	map.test = (differ(map.table(map)[key]) true, false) (return)                     

map.test.end


	define('mark(line)')		:(mark.end)

*	program to play wordwizard (ww)
*	Use host(0) to give the signature of the puzzle.

*	skip words with wrong length
*	skip words with signature that differs from
*	that of the puzzle.

mark
	ne(size(line),size(g.puzzle))	:s(freturn)
	sig = signature(line)
	differ(signature(line),puzzle.signature) 	:s(return)
	mark = pair(,line)		:(return)
mark.end

        define('number.cardinal(n,word)')                      :(number.cardinal.end)

*       If N is one, returns 'one' followed by WORD.
*       Otherwise returns NUMBER(N) followed by WORD and 'S'.

number.cardinal

        number.cardinal = (eq(n,1) 'one ' word, number(n) ' '  word 's'):(return)

number.cardinal.end

        define('number.number(n)')                             :(number.number.end)

**      If N can be represented as a string of one or two words
**      then return that string. Otherwise return N.

number.number
        number.number = eq(n) 'zero'                           :s(return)
        number.number = g.numbers[n]
        differ(number.number)                                  :s(return)
        number.number = n                                      :(return)
number.number.end

        define('number.thousands(s)n')                         :(number.thousands.end)

*       Format s with comma's every three digits from right.

number.thousands

        n = size(s)
        number.thousands = le(n,3) s                           :s(return)
        number.thousands = number.thousands(substr(s,1,n - 3)) ',' substr(s, n - 2, 3):(return)

number.thousands.end 

        define('out(text1,text2,text3)type1,type2')     :(out.end)

*       Output a line conisting of TEXT1, TEXT2 enclosed
*       in brackets, followed by TEXT3.

*OUT*
out
        output = text1 (differ(text2) '[' text2 ']', '')  (differ(text3) text3, ''):(return)

        differ(text2)                                   :s(out.text2)

*       Here if just text1.

        output = text1                                  :(return)

out.text2

        type2 = dt(text2)
        type3 = dt(text3)
*       output = 'dt(type2) ' dt(type2)
*       output = 'dt(type3) ' dt(type3)
        ident(datatype(text2),'string')                 :s(out.2)
*       output = 'out second argument not integer or string,'
*.      ' but of type ' type2
*.                                              	:(error)

out.2

        ident(type3,'integer')                          :s(out.3)
        ident(type3,'string')                           :s(out.3)

out.3
        type.ex(text3,'string')                         :s(out.ok)
        type.ex(text3,'integer')             	:s(out.ok)
*       output = 'out third argument not integer or string,'
*.      ' but of type ' type3
*.                                               :(error)

out.ok

        output = text1 ' [' text2 ']' text3  	:(return)

out.end

        define('random(n)')                             :(random.end)

*       Return integer uniformly distributed in 1,2,...,n.
*       If n=0 returns real uniformly distributed in the interval [0,1].
*       The Algorithm is based on that in section 16.1 of "Algorithms in SNOBOL4,"
*       James F. Gimpel, John Wiley and Sons, 1976.

*RANDOM*
random

        g.random_var = remdr(g.random_var * 4676, 414971)
        random  = g.random_var / 414971.0
        random = ne(n) convert(random * n,'integer') + 1
                                                        :(return)
random.end

        define('random.seed()s,c')                       :(random.seed.end)

*       Compute seed for random number generator from date and time.

*RANDOMSEED*
random.seed
        g.random_var =
        s = g.date
        s = replace(s,'/:-','   ')

*       Get all the digits in s.

random.seed.loop

        s len(1) . c =                                  :f(random.seed.done)
        ident(c,' ')                                    :s(random.seed.loop)
        g.random_var = g.random_var c                   :(random.seed.loop)

random.seed.done

*       Reverse the seed so digits depending on time come first.

        g.random_var = +reverse(g.random_var    )
                                                        :(return)

random.seed.end

        define('reader(filename,expr)line,makr')               :(reader.end)

*       Return a sequence of the lines in the file specified by _filename_.
*	If _expr_ is not null, then _eval_ is called just
*	after each line is read, with the variable _pair_ set to
*	the associated pair. If _eval_ fails the line is skipped. 
*	Otherwise returns a new pair to be entered in the input 
*	sequence.


*READER*
reader

        differ(filename) input(.file,g.channel.temp,filename):s(reader.opened)
        out('unable to open reader file ' filename '.') :(freturn)

reader.opened

        reader = map(1024)

reader.next

        map.add(map, (ident(filename) input, file))     :f(reader.eof)s(reader.next)

reader.eof

*       Here at end of file; close temporary file if one was needed.

        differ(filename) endfile(g.channel.temp)        :(return)

reader.end

	define('reader.string(str,delim)line')		:(reader.string.end)

*	Returns a sequence of the lines in _str_,
*	where the delimiter character _delim_ is used to mark 
*	the end of a line. One intended use of _reader.string_ 
*	is to assist in the construction of test programs.

reader.string

	delim = ident(delim) '/'
	reader.string = map.sequence()

reader.string.next

	str break(delim) . line delim =			:f(return)
	add(reader.string,line)				:(reader.string.next)

reader.string.end

        define('sequence.add(sequence,val)')		:(sequence.add.end)

sequence.add

	entry = (sequence.count(sequence) = #sequence + 1,val)
	sequence.put(sequence,#sequence, val) :(return)

sequence.add.end

	define('sequence.eval(sequence,s)value')	:(sequence.eval.end)

*	_sequence.eval_ returns the sequence obtained by calling _eval_ with argument _s_
*	for each value in the sequence. If _eval_ does not fail, the value returned defines
*	the next entry in the new sequence.

sequence.eval

	sequence.eval = sequence.new(#sequence)
	sequence.loop(sequence)

sequence.eval.next

	user.value = sequence.next(sequence)				:f(return)
	value = eval(s)							:f(sequence.eval.next)
	sequence.add(sequence.eval,value)				:(sequence.eval.next)
	
sequence.eval.end

*        define(‘sequence.forall(sequence)’)    :(sequence.forall.end)
*
**        Returns sequence defined as follows:
**        Iterare over _sequence_. For each entry _ent_, invoke f(ent) and use the
**        result to define a new entry in the result.
*
*sequence.forall
*
*        sequence.forall = sequence()
*        sequence.loop(sequence)
*
*sequence.forall.next
*
*sequence.forall = apply(f,sequence.forall,sequence.next(sequence))          :f(return)s(sequence.forall.next)
*
*sequence.forall.end

*        define(‘sequence.foreach(sequence,f)entry’)               :(sequence.foreach.end)
*
**        Returns a sequence defined by iterating over the entries in _sequence_, and applying
**        f to the entry to define a new entry in the result.
*
*sequence.foreach
*
*        sequence.foreach = sequence()
*
*sequence.foreach.next
*
*        entry = apply(f,sequence.next(sequence))                    :f(return)
*        sequence.put(sequence.foreach, entry.key(ent), entry.value(ent)):(sequence.foreach.next)
*
*sequence.foreach.end

        define('sequence.get(i)')                                  :(sequence.get.end)

*       Gets the value of element _i_ in the sequence _sequence_

sequence.get

	gt(i,0) le(i,#sequence)					:f(freturn)
        sequence.get = sequence.table(sequence)[i]

sequence.get.end

        define('sequence.loop(sequence,kind)')                    :(sequence.loop.end)

*       Returns an iterator for _sequence_. Use _sequence.next_ to retrieve
*       the next entry in sequence. _sequence.next_ fails when no more entries remain.

*       _kind_ gives the kind of loop:

*               '+order'        iterate in order in which entries added. (default)
*               '-order'        iterate in reverse order in which entries added.
*               '+key'          iterate in incresing values of keys.
*               '-key'          iterate in decceasing values of keys.
*               '+val'          iterate in incresing values of values.
*               '-key'          iterate in decreasing values of keys.

*       Otherwise iterate over the keys in the order in which they were added to the sequence.

sequence.loop

        sequence.index(sequence) = 0
        ident(kind)                                     :s(sequence.loop.order)
        ident(kind, '+order')                           :s(sequence.loop.key.order.inc)
        ident(kind, '-order')                           :s(sequence.loop.key.order.dec)
        ident(kind, '+key')                             :s(sequence.loop.key.inc)
        ident(kind, '-key')                             :s(sequence.loop.key.dec)
        ident(kind, '+val')                             :s(sequence.loop.value.inc)
        ident(kind, '-val')                             :s(sequence.loop.value.dec)

sequence.loop.order.inc

        sequence.array(sequence) = convert(sequence.table(sequence),'array'):(sequence.done)

sequence.loop.rorder.inc

        output = 'loop rorder not implemented '         :(nosuchlabel)
        sequence.array(sequence) = convert(sequence.table(sequence),'array'):(sequence.done)

sequence.loop.key.inc

        sequence.array(sequence) = rsort(sequence.table(sequence),1)        :(return)

sequence.loop.key.dec

        sequence.array(sequence) = sort(sequence.table(sequence),1)         :(return)

sequence.loop.value.inc

        sequence.array(sequence) = rsort(sequence.table(sequence),2)        :(return)

sequence.loop.value.dec

        sequence.array(sequence) = sort(sequence.table(sequence),-2)        :(return)

sequence.loop.end

        define('sequence.new(init,n)i,key,str,valr')         :(sequence.new.end)

*       Create a new sequence.

*       A sequence is a list of values *  separated by spaces.

*               sequence       _init_ is a list consisting of a list of key/value pairs,
*                               with a colon (:) between the key and value.

sequence.new

        sequence.new = ident(init) sequence(table(128))           :s(return)
        kind = ident(kind) 'sequence'
        kind
        output = 'enter sequence.new [' init ']'
        init break(':')                                	:s(sequence.new.keyval)
        sequence.new = sequence(table(i))                         :(return)

sequence.new.keyval
        
        sequence.new = sequence(table(128))

sequence.new.keyval.next

        init break(':') . key ':' break(' ') . val ' ' =	:f(return)
        sequence.put(sequence.new,key,val)                        :(sequence.new.keyval.next)

sequence.new.end

        define('sequence.next(sequence)')                         :(sequence.next.end)

*       _sequence.next_ returns the next entry in a sequence, or fails if no entries remain.

sequence.next

        le(sequence.index(sequence) = sequence.index(sequence) + 1, #sequence):f(freturn)
        sequence.next = entry(sequence.array[sequence.index(sequence),1],sequence.array[sequence.index(sequence),2]):(return)

sequence.next.end

        define('sequence.range(sequence)')                    :(sequence.range.end)


*        Return set with the values in _sequence_ as its members.


sequence.range

        sequence.range = seq.new(#sequence)
        sequence.loop(sequence)

sequence.range.next

        sequence.range.add(value(sequence.next(sequence)))        :f(return)s(sequence.range.next)

sequence.range.end

        define('sequence.put(sequence,i,val)v')                 :(sequence.put.end)

*       Sets the value of element _i_ in the sequence _sequence_ to be _val_.

sequence.put

        output = 'enter sequence.put dt ' datatype(sequence) ' i [' i '] val [' val ']'
        v = sequence.table(sequence)[i]
        differ(v)                                       :s(sequence.put.value)

*       Here to create new entry in sequence.

        sequence.count(sequence) = #sequence + 1

sequence.put.value

        sequence.table(sequence)[i] = val              	:(return)

sequence.put.end

	define('sequence.size(sequence)')		:(sequence.size.end)

*	Returns number of entries in sequence _sequence_.

sequence.size

	sequence.size = #sequence			:(return)

sequence.size.end

	define('set.add(set,elem)')			:(set.add.end)

*	Add _elem_ to set, unless already present.

set.add

	elem = set.table(set)[elem]			
	differ(elem)					:s(return)
	set.count(set) = #set + 1
	set.table(set)[elem] = elem			:(return)

set.add.end

	define('set.apply(set,s)elem,elem.new')	:(set.apply.end)

*	_set.apply_ returns the set defined by calling _eval(s)_ for every
*	element of _set_, using the result to define the elements of the
*	result. No new element is added if the call to _eval_ fails.

set.apply

	set.apply = set.new(#set)
	set.loop(set)

set.apply.next

	elem = set.next(set)				:f(return)
	elem.new = eval(s)				:f(set.apply.next)
	set.add(set.apply,elem.new)			:(set.apply.next)

set.apply.end

        define('set.array(aray)i,key')                  :(set.array.end)

*	Create a set defined by an array.
*	If the array has one dimension then create a set
*	from the array values.
*	If the array has two dimensions, create a set of pairs
*	consisting of the indices and corresponding values.

set.array

        set.array = set()
        i = prototype(aray)
        integer(i)                                      :s(set.array.one)

*       Here to initialize from two-dimensional array

	i = 0

set.array.two.next

	set.add(set.array,pair(ara[i = i + 1,1],ara[i,2])) :f(return)s(set.array.two.next)

set.array.one

*        Here to initialize set from one-dimensional array

	i = 0

set.array.one.next

        key = aray[i = i + 1]				:f(return)
        set.add(set.array,aray[i = i + 1])              :f(return)s(set.array.next)

set.array.end

	define('set.equal(a,b)x')			:(set.equal.end)

*	Tests if two sets are equal.

set.equal

	set.equal = false
	ne(#a,#b)					:s(return)

*	Here if same size, so test if all elements in one
*	set are in the other.

	set.loop(a)

seq.equal.next

	x = set.next(a)					:f(set.equal.done)
	set.equal = set.member(b,x)			:s(set.equal.next)f(return)

set.equal.done

	set.equal = true				:(return)

set.equal.end

        define('set.forall(set)')                    :(set.forall.end)

*       Returns set defined as follows:
*       Iterare over _set_. For each entry _ent_, invoke f(ent) and use the
*       result to define a new entry in the result.

set.forall

        set.forall = set()
        set.loop(set)

set.forall.next

	set.forall = apply(f,set.forall,set.next(set))          
.	:f(return)s(set.forall.next)


set.forall.end

        define('set.foreach(set,f)entry')               :(set.foreach.end)

*        Returns a set defined by iterating over the entries in _set_, and applying
*        f to the entry to define a new entry in the result.

set.foreach

        set.foreach = set()

set.foreach.next

        entry = apply(f,set.next(set))                    :f(return)
        set.put(set.foreach, entry.key(ent), entry.value(ent)):(set.foreach.next)

set.foreach.end

	define('set.in(set,elem)')				:(set.in.end)

*	Test if _elem_ is a member of set _set_.

set.in

        set.in = (differ(set.table[elem]) true, false)       	:(return)

set.in.end

        define('set.intersection(a,b)elem')                    	:(set.intersection.end)

*       Returns intersection of sets _a_ and _b_.

set.intersection

*	Arrange so set a is the smaller set.

	le(#a,#b)						:s(set.intersection.a)
	set.intersection = a 
	a = b
	b = set.intersection

set.intersection.a

*	Make copy of set _a_ by making copy of _a_'s table.

	set.intersection = set.new(,#a)
	set.table(set.intersection) = copy(set.table(a))

	set.loop(b)

set.intersection.b

	elem = set.next(b)					:f(return)

*	Skip this entry if not in set _a_.
	
	set.notin(a,elem)					:s(set.intersection.b)
	set.add(set.intersection,elem)				:(set.intersection.b)
	
set.intersection.end

	define('set.less(a,b)elem')			:(set.less.end)

*	Returns set define by set of elements of _a_ that are not in _b_.

set.less

	set.less = set.new()
	set.loop(a)

set.less.a

	elem = set.next(a)				:f(return)
	set.in(b,elem)					:s(set.less.a)
	set.add(set.less,elem)				:s(set.less.a)

set.less.end

        define('set.loop(set)')                    :(set.loop.end)

*       Returns an iterator for _set_. Use _set.next_ to retrieve
*       the next entry in set. _set.next_ fails when no more entries remain.

set.loop

        set.index(set) = 0

set.loop.order.inc

        set.array(set) = convert(set.table(set),'array'):(set.done)

set.loop.end

	define('set.member(set,elem)')			:(set.member.end)

*	Tests if _elem_ is an element of set _set_.

set.member

	set.member = (set.member(set,elem) true, false)	:(return)

set.member.end

        define('set.new(init,n)i,key,str,valr')         :(set.new.end)

*       Create a new set.

*       A set is a list of values *  separated by spaces.

*               set       _init_ is a list consisting of a list of key/value pairs,
*                               with a colon (:) between the key and value.

set.new

        set.new = ident(init) set(table(128))           :s(return)
        kind = ident(kind) 'set'
        kind
        output = 'enter set.new [' init ']'
        init break(':')                                	:s(set.new.keyval)
        set.new = set(table(i))                         :(return)

set.new.keyval
        
        set.new = set(table(128))

set.new.keyval.next

        init break(':') . key ':' break(' ') . val ' ' =	:f(return)
        set.put(set.new,key,val)                        :(set.new.keyval.next)

set.new.end

        define('set.next(set)')                         :(set.next.end)

*       _set.next_ returns the next entry in a set, or fails if no entries remain.

set.next

        le(set.index(set) = set.index(set) + 1, #set)	:f(freturn)
        set.next = entry(set.array[set.index(set),1],set.array[set.index(set),2]):(return)

set.next.end

        define('set.notin(x,s)')                      	:(set.notin.end)

*       Returns _true_ iff _x_ is is not element in _s_.

set.notin

        set.notin = (ident(set.table[x]) true, false)	:(return)

set.notin.end

	define('set.size(set)')				:(set.size.end)

*	Returns number of entries in set _set_.

set.size

	set.size = #set					:(return)

set.size.end

        define('set.union(a,b)elem')                   	:(set.union.end)

*       Returns union of sets _a_ and _b_.

set.union

*	Arrange so set a is the larger set.

	ge(#a,#b)					:s(set.union.a)
	set.union = a 
	a = b
	b = set.union

set.union.a

*	Make copy of a by making copy of a's table.

	set.union = set.new(,#a)
	set.table(set.union) = copy(set.table(a))

	set.loop(b)

set.union.b

	elem = set.next(b)					:f(return)
	set.add(set.union,elem)					:(set.union.b)
	
set.union.end

	define('setl4.size(s)dt')			:(setl4.size.end)

*	Return size of operand.

setl4.size
	output = 'enter setl4.size'
	
	dt = datatype(s)

	output = 'enter setl4.size ' dt
	setl4.size = ident(dt,'string') size(s)			:s(return)
	setl4.size = ident(dt,'set') set.count(s)		:s(return)
	setl4.size = ident(dt,'sequence') sequence.count(s)	:s(return)
	output = 'setl4.size unknown type ' dt :(end)

setl4.size.end

	define('show.value(v)i,ent,type')			:(show.value.end)

*	Show the value of an expression.

*SHOW*
show.value
	typ = dt(v)
						:($('show.value.type.' typ))

show.value.type.array

	show = show.array(v)				:(show.value.done)

show.value.type.integer

	show = convert(v,'string')			:(show.value.done)

show.value.type.move

	show = show.move(v)				:(show.value.done)

show.value.type.pair

	show = show.pair(v)				:(show.value.done)

show.value.type.table

	show = show.table(v)				:(show.value.done)

show.value.type.string

	v break('"')					:s(show.value.string.quote)

	show.value = "'" string "'"			:(show.value.done)

show.value.string.quote

	show.value = '"'  v '"'			:(show.value.done)

show.value.done
							:(return)
show.value.end

	define('show.array(ara)i,first,proto,second')	:(show.array.end)

*	Show an array. Fribble uses only one and two dimensional arrays

show.array

	out('show.array dt(ara)',dt(ara))
	proto = prototype(ara)
	out('show.array prototype ' proto)
	proto break(',')				:s(show.array.2)

*	Here for one dimensional array.

show.array.1
	first = ara[add1(.i)]				:f(show.array.done)
	out(lpad(i,3) tab first)			:(show.array.1)

show.array.2
	first = ara[add1(.i),1]		       	  :f(show.array.done)
	out(lpad(i,3) tab show(first) tab show(ara[i,2])) :(show.array.2)

show.array.done

	out()						:(return)

show.array.end

	define('show.line(line)')			:(show.line.end)

*	Show a line with spaces replaced by '.'

*SHOW.LINE*
show.line

	show.line = replace(line,' ','.')		:(return)

show.line.end

	define('show.lines(lines,title)i,line,titled')	:(show.lines.end)

*	Show the lines that are not empty in an array of lines

*SHOW.LINES*
show.lines

	title  = 'lines' (differ(title) ' ' title, '')
	out(itle)

show.lines.n

	line = lines[add1(.i)]			:f(return)
	empty(line)				:s(show.lines.n)
	differ(titled)				:s(show.lines.titled)

*	Don not list header unless at least one non-empty line

	out('    123456789012345')


	titled = 1

show.lines.titled

	out(lpad(lineid(i),2) ' ' replace(line,' ','.')) :(show.lines.n)

show.lines.end

	define('show.pair(pair)')			:(show.pair.end)

*	Show paired item.

*SHOW.PAIR*
show.pair

	show.pair = '{' lineid(num(pair)) ',' "'"
.			replace(line(pair),' ','.') "'" '}'	:(return)

show.pair.end


	define('show.table(tbl,col)ara,i,key')		:(show.table.end)

*	Show a table.

*SHOW.TABLE*
show.table

	ara = sort(tbl,col)

show.table.next

*	loop:	Get the next tbl key.

	key = ara[add1(.i),1]				:f(show.table.done)

*	Show the entry and continue back to loop.

	out(lpad(show(key),8) ' -> ' show(ara[i,2]))
							:(show.table.next)
show.table.done
	out()						:(return)

show.table.end


	define('show.words(words)i,pos')		:(show.words.end)

*	Show results of words() call.

show.words

	pos = words[add1(.i),1]			:f(return)
	out('words ' lpad(pos,2) ' ' words[i,2])	:(show.words)

show.words.end

	define('signature(word)')	:(signature.end)

*	The signature of a consists of all the characters
*	that occur in the word sorted into alphabetical order
*	with each character followed by an integer giving the number
*	of times the character occurs in the word.

signature

	signature = string.frequency(word)	:(return)

	outut = 'dave, complete code for signature()'

	g.puzzle = 'spot'
	g.signature = string.frequency(g.puzzle)
	:(return)
signature.end


        define('stack.new()')                           :(stack.new.end)

*       _stack_ returns a new empty stack.

stack

        stack = stack(table(16))                        :(return)

stack.new.end

        define('stack.empty(stack)')                    :(stack.empty.end)

*       _stack.empty_ tests if the stack is empty.

stack.empty

        ne(stack.size(stack))                             :s(return)f(freturn)

stack.empty.end

	define('stack.peek(stack,i)val')		:(stack.peek.end)

*	Returns value of entry at offset _i_ from the top of the
*	stack, of fails if _i_ is not a valid stack index.
*	The top of the stack has index 0, the entry below it has offset 1,
*	and so forth.

stack.peek
	
	lt(i,0) gt(i,stack.size(stack))			:s(freturn)
	stack.peek = stack.table(stack)[stack.size(stack) = i] :(return)

stack.peek.end

	define('stack.poke(stack,val)')			:(stack.poke.end)

*	Sets value of entry at offset _i_ from the top of the
*	stack to have vaulue _val_, of fails if _i_ is not a valid stack index.
*	The top of the stack has index 0, the entry below it has offset 1,
*	and so forth.
*	_Stack.poke_ returns _val_.

stack.poke
	
	lt(i,0) gt(i,stack.size(stack))			:s(freturn)
        eq(stack.size(stack))                        	:s(freturn)
	stack.table[stack.size(stack) - i] =  val;	:(return)

stack.poke.end

        define('stack.pop(stack)')                      :(stack.pop.end)

*       _stack.pop_ pops the top of the stack and returns its value,
*       unless the stack is empty in which case stack.pop fails.

stack.pop

	stack.pop = stack.table(stack)[stack.size(stack)]
        stack.put(stack,stack.size(stack),'')
        stack.size(stack) = stack.size(stack) - 1           :(return)

stack.pop.end

        define('stack.push(stack,val)')                  :(stack.push.end)

*       _stack.push' pushes _val_ on to the stack.

stack.push

        stack.add(stack,val)                              :(return)

stack.push.end

        define('stack.top(stack)')                      :(stack.top.end)

*       _stack.top_ returns the top entry in the stack.

stack.top

        stack.top = stack.get(stack,stack.size(stack))      :(return)

stack.top.end

*       Each token is represented as an instance of the datatype _token_ as follows:

        data('token(lineno,ndx,type,text)')

*       where:
*               _lineno_        is the line number within the file;
*               _ndx_           is the ndxition of the first character of the token in the line;
*               _type_          is the token's type, as described below; and
*               _text_          is the text of the token.

*       The type is represented by a single character, as follows:

*               'c'             comment, indicated by asterisk (*) in the first column.
*                               The text consists of the entire line.

*               'i'             integer, consisting of one or more digits ('0123456789')

*               'l'             left opener, one of '(<[{'

*               'p'             punctation, one of '.;,?!', or single quote ('), or double quote ("),

*               'o'             other printable character, one of '~@#$%^&*_-+=`'.

*                'q'            quoted string, starting witn '"', and continuing 
*				to the next instance of the opening quote character.

*               'r'             right closer, one of ')>]}'

*               's'             space, consistine of one or more spaces (spaces)

*               't'             tab character

*               'u'             unprintable character, for example control-k

*               'w'             word, consisting of one of more letters in 
*				upper or lower case or "'" or "_".

*       The longest possible string meeting the rules is used when building a token.
*       For example, 'abc' is just the word 'abc', not 'a' followed by 'bc', and so forth.

*       It is recommended that the tab character NOT be used as an 
*	abbreviation for one or more spaces in the input file. If tabs 
*	are used, then _pos_ is ill-defined. If tabs are not used, then 
*	_pos_ indicates the true position in the line of the first character 
*	of the token, and so error messages and references to the 
*	token will be exact.  For example, _pos_ could be used to indicate 
*	where to give emphasis to a token by underlining it, or enclosing 
*	it in '_' to generate markdown format, and so forth.


        define('tokens(line)type,pos,text,lineno')                     :(tokens.end)


*       Tokens scans _line_ and returns a table of the tokens in the line.
*       The table has keys from 1..n, where _n_ is the number of tokens found. The
*       key '#' gives the number of entries in the table, and is used for no other purpose.
*       For example, a scan of an empty line results in tokens['#'] having the value zero.

*       This function is an instance of what is called a tokensical scanner, or tokenizer,
*        which is the first stage in a programming language compiler, or for any program 
*       that processes text files with a specified structure.

*TOKENS*
tokens  

        tokens = map.sequence()
        line '*'                                        :f(tokens.next)
        type = 'c'
        text = line                                                             
        line =                                          :(tokens.new)

tokens.next

        line ' '                                        :s(tokens.space)
        line any('0123456789')                          :s(tokens.integer)
        line any('(<[{')                                :s(tokens.left)
        line any('.;,?!')                               :s(tokens.punctuation)
        line '"'                                        :s(tokens.quote)
        line any('~@#$%^&*_-+=')                                        :s(tokens.other)
        line any(')>]}')                                :s(tokens.right)
        line char(9)                                    :s(tokens.tab)
        line any(&lcase &ucase)                         :s(tokens.word)

*       Here for unprintable
                                                        :(tokens.unprintable)

tokens.integer

        type = 'i'
        line span('0123456789') . text =                :(tokens.new)

tokens.punctuation 

        type = 'p'                                       :(tokens.character)

tokens.other

        type = 'o'                                      :(tokens.character)

*tokens.other

        type = 'o'                                      :(tokens.character)

tokens.quote

        type = 'q'
        line '"' break('"') . text '"' =        
        text = '"' text '"'                             :(tokens.new)

tokens.right

        type = 'r'                                      :(tokens.character)

tokens.space

        type = 's'
        line span(' ')  . text =                        :(tokens.new)

tokens.tab

        type = 't'                                      :(tokens.character)

tokens.word

*FIX*
        type = 'w'
        line span(&ucase &lcase "_" "'") . text =      :(tokens.new)

tokens.character

*       Here if token is single character.

        line len(1) . text                              :(tokens.new)

tokens.new

        map.add(tokens,token(lineno,pos,type,text))     :(tokens.next)

tokens.end


        define('traceoff()')                            :(traceoff.end)

*       Initiate tracing.

*TRACEOFF*
traceoff
        &ftrace = &trace =

        g.scoring = g.tracing = 0
        out('stop TRACING ')

traceoff.end

        define('traceon()')                             :(traceon.end)

*       Initiate tracing.

*TRACEON*
traceon

        out('start TRACING')
*       &ftrace = &trace = 1500000
        g.scoring = g.tracing = 1
                                                        :(return)
traceon.end

        define('words(line)word')                        :(words.end)

*       Return sequence of the words in line, fail if no words.

*WORDS*
words

        words = map()
        line =  line ' '

words.next

        line break(' ') . word ' ' =                     :f(return)
        map.add(words,word)                             :(words.next)

words.end

       define('writer(lines)'       )                  :(writer.end)

*       Writes a sequence of the lines in the sequence _lines_
*	to standard output.

writer

	lines = copy(lines)
	map.loop(lines)

writer.next
	
	output = map.next(lines)				:f(return)s(writer.next)

writer.end

        :(error.end)
error
        output = 'error lastno ' &lastno
        output = 'ERROR'
        output = 'Fatal error: stopping the madness.'
*       &dump = 3
                                                        :(end)
error.end

*	Define '#' as unary operator that returns size of its operand.

	output = 'calling opsyn '
	opsyn('#','setl4.size',1)

