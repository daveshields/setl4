-include  "../setl4.stl"

    &stlimit = 100000000

    define('list(set)elem,this')                  :(list.end)


*   List elements of set, one per line

list

    out = '{'
    loop(set)

list.next

    this = next(set)                                :f(return)
    out('  ',this)                                  :(list.next)

list.end

    define('Value(str)tmp')                         :(Value.end)

*   Evaluate argument _str_ after replacing instance of 'a=b' with 'ab'

Value

*   March through _str_,putting spaces around binary operators, and doing concatenation as needed.
*   First, expand str so that '+' and '-' have space before and after operator symbol, and do 
*   concatenation implied by '.'.


Value.next

    str len(1) . ch =                               :f(Value.eval)
    tmp = ident(ch,'+') first ' + '               :s(Value.next)
    tmp = ident(ch,'-') first ' - '               :s(Value.next)
    ident(ch,'=')                                   :s(Value.next)
    tmp = first ch                                :(Value.next)

Value.eval

    out('Value.in',tmp)
    Value = eval(tmp)                               
    out('Value.out',Value)
                                                   :(return)

Value.end

    define('expand(line)ch')                            :(expand.end)

*   Expand one value in product set.

expand

    line len(1) . ch =                              :f(return)
    expand = ident(ch,'+') expand ' + '             :s(expand)
    expand = ident(ch,'-') expand ' - '             :s(expand)
    ident(ch,'.')                                   :s(expand)
    expand = expand ch                              :(expand)

expand.ch

*   Here if digit

    expand = expand ch                                  :(expand)

expand.end

    define('main()seq,ops,prod')                         :(main.end)

main

    seq = new('seq')
    ops = new('set')
    add(ops,'+')
    add(ops,'-')
    add(ops,'.')
*   add(ops,' ')
    show(ops)
    iter = new('iter 1 8')

main.next.init

    this = next(iter)                               :f(main.init.done)
    push(seq,new('set ' this))
    push(seq,ops)                                   :(main.next.init)

main.init.done

    push(seq,new('set 9'))
    show(seq)
    Out('computing product.')
    prod = product(seq,'TRUE')
    Out('dt prod',datatype(prod))
    Out('showing PROD')
    show(prod)

    xprod = new('set')
    loop(prod)

main.x.next

    this = next(prod)                              :f(main.x.done)
    add(xprod,expand(this))                          :(main.x.next)
main.x.done
    Out('XPROD')
    show(xprod)
    yprod = filter(xprod,"eq(eval(this),100)")
    out("strings with value 100")
    visit(yprod,"show(this)") 

*   Map each solution string to number of words in it.

    omap = new('map')
*   visit(yprod,"put(omap,this,set.size(words(this)))")
    visit(yprod,"put(omap,this,words(this))")
    show(omap)

    
                                                    :(return)

main.end

    main()

end
