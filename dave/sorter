    define('sorter(set,type)ara,entry,i,key,index.table,map,n,seq,str,tbl,value.table,value'):(sorter.end)

*   _Sorter_ sorts the index table of _set_ according to _type_ to reflect
*   a desired sort of the elements of set, keys or maps, or values of map.
*   _Sorter_ doesn't create a new set, but just updates the index table so that,
*   going forward, entries will be visited in the order specified by _type_.

*   _Sorter_ can also be used to put a string in normal form by converting the string
*   into a sequence of the characters in the string and then sorting the range
*   of the sequence.

*   The argument _type_ specifies the ordering to be used:

*       '+index'    increasing order of when entry created (oldest first)

*       '-index'    decreasing order of when entry created (most recent first)

*       '+key'      increasing order of the values in the domain

*       '-key'      decreasing order of the values in the domain

*       '+value'    increasing order of the values in the range

*       '-value'    decreasing order of the values in the range

*   Types for keys and values may be abbreviated: "+key" may be written
*   as "+k" or "+ke", "+value" as "+v" or +"val", and so forth.

sorter

    ident(type) error('sorter null type.')
    ident(type,'no')                                   :s(return)

*   Use _setl4.string.sorter_ if input is a string.

    sorter = ident(datatype(set),'string') setl4.string.sorter(set):s(return)

    n = set.size(set)
    index.table = set.index(set)

*   Here to detect cases for which sort has no meaning, in which case
*   return immediately. This includes the case 'int' which, though possible
*   to sort as desired, requires a complicated algorithm that has yet to be
*   thought through.

    type = get(setl4.sorter.types,type)

    differ(datatype(set),'set') error('sorter - unsupported input type ' datatype(set) )
    ident(datatype(set),'set') ident(set.kind(set),'int'):s(return)
    ident(datatype(set),'set') ident(set.kind(set),'iter'):s(return)

*   Nothing to do if set is empty or only has one element.

    le(n,1)                                            :s(return)
    differ(datatype(set),'set') error('sorter bad datatype ' datatype(set))
    ident(type) error('sorter null type')

    ident(type,'+v')                                   :s(sorter.value)
    ident(type,'-v')                                   :s(sorter.value)

    tbl = setl4.set.sorter(set,type)
    differ(datatype(tbl),'table') error('sorter result not table')
                                                       :(sorter.finis)
    i = 0

sorter.index.next

    error('why did we reach here')
    le(i = i + 1,n)                                    :f(sorter.finis)
    tbl[i] = set.index(set)[ara[i,1]]                  :(sorter.index.next)

sorter.value

*   Here to  sort by value: build table mapping index numbers into
*   the values associated with their keys, and sort that.

    tbl = compose(set.index(set),set.key(set))
    type = ident(type,'+v') '+k'
    type = ident(type,'-v') '-k'
    value.table = setl4.table.sorter(set,type,tbl)
    i = 0

*   The table is in proper order, so replace values with the keys
*   associated with that value.

sorter.value.next

    le(i = i + 1,n)                                    :f(sorter.finis)
    tbl[i] = value.table[i]                            :(sorter.value.next)

sorter.finis

    set.index(set) = tbl                               :(return)

sorter.end

