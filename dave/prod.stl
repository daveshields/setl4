
*   Copyright 2017, David Shields
*   Licensed under the MIT license.
-include "../setl4.stl"

*   &dump = 3
    &stlimit = 200000

    define('product(seq,strings)partial,t1,slice1,set1,set2,this1,this2,tup,tmp,p1,p2'):(product.end)

*   _Product_ returns the Cartesian product.set of a sequence of strings or sets.

*   The product of an empty set is the empty set; the product
*   of a single set is itself; the product of more than two sets
*   is defined recursively; and we compute the product of
*   set twos explicitly.

*   Argument _strings_ if not null then _sets_ is a sequence of strings.

product

    out('enter product',strings)
*   show(seq)
*   out()

    product = new('set')
    product = eq(set.size(seq))                         :s(return)
    product = eq(set.size(seq),1) copy(seq)             :s(return)

    set1 = get(seq,1)
    set2 = get(seq,2)
    eq(set.size(seq),2)                                 :s(product.two)

*   Here to compute the product of three or more sets. First,
*   compute the partial product of all the sets except the last one,
*   and then compute the product of that partial product and the last set.

    set1 = product(slice(seq,1,set.size(seq) - 1),strings)
    set2 = top(seq)

*   Merge below to compute final produce.

product.two

*   Here to compute the product of two sets.
*   Loop over the first set. If an element is a tuple, then we are extending a
*   partial product. Otherwise we are interating over the first set in a product
*   and need to create a tuple from the element.
*   Then loop over the second set. For each element in the second set, add a new
*   element to the output that extends the tuples of the current element in the
*   first set.

    product = new('set')
    loop(set1,.this1)

product.set.next1

    next(set1)                                          :f(return)
    this1 = ident(strings) differ(datatype(this1),'set')  push(new('seq'),this1)

    loop(set2,.this2)

product.set.next2

    next(set2)                                          :f(product.set.next1)
    add(product,join(this1,this2))                      :s(product.set.next2)

product.end

    define('test(seq,strings)')                         :(test.end)

test

    out()
    out('test input')
    out('strings',strings)
    show(seq)
    test = product(seq,strings)
    out('test output')
    show(test)
    out('end test')
    out()
                                                        :(return)
test.end

*tst.str

    out('testing product of non-strings')

    seq = new('seq')
    s1 = new('set x y')
    push(seq,s1)
    test(seq)

    s2 = new('set O R')
    push(seq,s2)
    test(seq)
    out('FINIS')
    s3 = new('set X L C')
    push(seq,s3)
    test(seq)

    out('testing product on strings')
    seq = new('seq')
    s1 = new('set x y')
    push(seq,s1)
    test(seq,'TRUE')

    s2 = new('set O R')
    push(seq,s2)
    test(seq,'TRUE')

    s3 = new('set X L C')
    push(seq,s3)
    test(seq,'TRUE')

end
