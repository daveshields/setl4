
*   Copyright 2017, David Shields
*   Licensed under the MIT license.
-include "../setl4.stl"

    &stlimit = 200000

    define('product(seq,strings)partial,t1,slice1,set1,set2,this1,this2,tup,tmp,p1,p2'):(product.end)

*   _Product_ returns the Cartesian product.set of a sequence of strings or sets.

*   The product of an empty set is the empty set; the product
*   of a single set is itself; the product of more than two sets
*   is defined recursively; and we compute the product of
*   set twos explicitly.

*   Argument _strings_ if not null then _sets_ is a sequence of strings.

product

    out('enter product',strings)
*   show(seq)
*   out()

    product = new('set')
    product = eq(set.size(seq))                        :s(return)
    product = eq(set.size(seq),1) copy(seq)            :s(return)

    eq(set.size(seq),2)                                :s(product.two)

*   Here to compute the product of three or more sets. First,
*   compute the partial product of all the sets except the last one,
*   and then compute the product of that partial product and the last set.

    Out('enter product three')
    partial = product(slice(seq,1,set.size(seq) - 1),strings)
    push(partial,top(seq))
    product = product(partial,strings)                 :(return)

product.two

*   Here to compute the product of two sets.
*   Loop over the first set. If an element is a tuple, then we are extending a 
*   partial product. Otherwise we are interating over the first set in a product
*   and need to create a tuple from the element.
*   Then loop over the second set. For each element in the second set, add a new
*   element to the output that extends the tuples of the current element in the
*   first set.

    differ(strings)                                    :s(product.str.two)
    product = new('set')
    loop(set1 = get(seq,1),.this1)

product.set.next1

    next(set1)                                         :f(return)
    this1 = differ(datatype(this1),'set')  push(new('seq'),this1)
    Out('set.next1 this1')
    show(this1)
    Out('this1 shown')
    tup = copy(this1)
*   Out('tup',set.kind(tup))
*   show(tup)

    loop(set2 = get(seq,2),.this2)

product.set.next2

    next(set2)                              :f(product.set.next1)
    Out('set.next2')
    Out('product size',set.size(product))
    show(tup)
    show(this2)
    out()

    p1 = copy(tup)
    push(p1,this2)
    Out('p1')
    show(p1)
    Out('p1 shown')
*HERE
    Out('COUNT',count = count + 1)
    Out('adding p1 dt',datatype(p1))
    show(p1)
    add(product,p1)
    Out('result of add')
    show(product)
                                            :(product.set.next2)

product.str

    error('reached product.str')
    lt(set.size(seq),3)                                :s(product.str.two)

*   Compute the partial product of all the sets except the last one.

    push(partial = new('seq'),product(slice(seq,1,set.size(seq) - 1),'TRUE'))

*   Compute the product of the partial product and the last set.

    push(partial,top(seq))
    product = product(partial,'TRUE')                  :(return)

product.str.two

*   Here to compute the product of two sets of strings.

    product = new('set')
    loop(set1 = get(seq,1),.this1)

product.str.next1

    next(set1)                                         :f(return)
    loop(set2 = get(seq,2),.this2)

product.str.next2

    next(set2)                                         :f(product.str.next1)
    add(product, this1 this2)                          :(product.str.next2)

product.end

    define('test(seq,strings)')                        :(test.end)

test
    out()
    out('test input')
    out('strings',strings)
    show(seq)
    test = product(seq,strings)
    out('test output')
    show(test)
    out('end test')
    out()
                                                       :(return)
test.end

*   s = new('seq 10')
*   push(s,20)
*   show(s)
*end

    out('START')
    out('DAVE')
    out('testing product of non-strings')

    seq = new('seq')
    s1 = new('set x y')
    push(seq,s1)
    test(seq)
    s2 = new('set O R')
    push(seq,s2)
    test(seq)
    out('FINIS')
end

end
    s3 = new('set X L C')
    push(seq,s3)
    test(seq)
end
tst.str
    out('testing product on strings')
    seq = new('seq')
    s1 = new('set x y')
    push(seq,s1)
    test(seq,'TRUE')

    s2 = new('set O R')
    push(seq,s2)
    test(seq,'TRUE')

    s3 = new('set X L C')
    push(seq,s3)
    test(seq,'TRUE')

end
    out('start test')
    s1 = new('seq')
    out('showing empty seq')
    out('Done')
    show(s1)
    push(s1,'x')
    push(s1,'y')
    show(s1)
    show('more')
    setl4.show(s1)
    s2 = new('seq 20')
*   show(s2)
end
