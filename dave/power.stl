    define('power(set)i,j,n,N,s,this')      :(power.end)

*   Return the powerset of _set_, defined as the set of all subsets of a set.

power

    power = new('set')

*   Let _n_ be the size of _set_.
*   The powerset of the empty set is the empty set.

    n = set.size(set)
    eq(n)                                   :s(return)

*   Compute _N_ = 2 to the power _n_.

    N = 1
    i = 0

power.N

    le(i = i + 1,n)                         :f(power.N.done)
    N = N * 2                               :(power.N)

power.N.done

*   Compute the powerset as follows:

*   Loop for i = 0 ... N - 1:
*       Let _b_ be the string containing the binary value of _i_, padded to length _n_.
*       Set _this_ to the empty set.
*       Loop for _j_ = _size(b)_ ... _1_
*           If the _j_-th character of _b_ is '1' then add
*           the _j_-th element of _set_ to _this_.
*       Add _this_ to _power_.

    i = -1

power.next.i

    lt(i = i + 1,N)                             :f(return)
    b = binary(i,n)
    this = new('set')
    j = size(b) + 1

power.next.j

    gt(j = j - 1)                               :f(power.j.done)
    s = substr(b,j,1)
    ident(s,'1') add(this,set.index(set)[j])
                                                :(power.next.j)

power.j.done

    add(power,this)                             :(power.next.i)
    
power.end

    define('test(set)')                         :(test.end)

test

    out('enter test')
    show(set)
    show(power(set))
    out('exit  test')
    out()
                                            :(return)

test.end

    test(new('set'))
    test(new('set a'))
    test(new('set a b'))
    test(new('set a b c'))

end

    
