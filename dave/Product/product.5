
*   Copyright 2017, David Shields
*   Licensed under the MIT license.

-include "../setl4.stl"

    define('product(sets)set.in,set.out,this,n,n.all,set.i,seq') :(product.end)

*   _Product_ returns the Cartesian product of a sequence of sets.

*   Compute the Cartesian product as follows.
*   If the input is the empty set, return the empty set.
*   If there is just one input, return a copy of it.

*   Otherwise compute the product in steps, with the output
*   from one step serving as input to the next.
*   For each element in the first set, build a sequence consisting
*   of the element and add it to the output set.
*   For each element in the remaining sets, iterate the input set.
*   Get the existing sequence of the element, add the element from
*   the remaining set to the sequence, and continue.
*   Return as the product the last output set computed.

product

    product = new('set')
    set.out = new('set')
    set.in = new('set')

*   Cartesian product of empty set is an empty sequence.

    sets.n = set.size(sets)
    eq(sets.n)                                       :s(return)

*   Size of result is product of sizes of the sets. Use this
*   value for the size of the output sets.
*   Estimate size of each new sequence as _n_.

    loop(sets)
    n.all = 1

product.size

    n.all = n.all * set.size(next(sets))    :(product.size
    out('n.all',n.all)

*   Loop over the input sets.

    loop(sets,.sets.this)

product.next

    next(sets)                                  :f(return)
    set.out = new('set #' n.all)
    set.i = set.i + 1
    gt(set.i,1)                             :s(product.remain)

*   Here for first set, so just add stack with entry for each element in the set.

    loop(sets.this)

product.first.next

    next(sets.this)                         :f(product.first.done)
    seq = new('seq #' n)
    push(seq,this)
    add(set.out,seq)                        :(product.first.next)

product.first.done

    product = set.out
    set.in = set.out                        :(product.next)

product.remain

*   Here for a set after the first.

    loop(sets.this)

product.remain.next

    loop(set.in,.this.in)                   :f(product.remain.done)
    set.out = new('set #' n.all)

product.remain.in.next

    seq = next(set.in)                      :(product.remain.done)
    push(seq,this)                          :(product.remain.in.next)

product.remain.done

    product = set.out
    set.in = set.out                        :(product.next)

product.end
    

    define('test(sets)')                    :(test.end)

test

    out()
    out('enter test')
    out('number of sets',set.size(sets))
    show(sets)
    p = product(sets)
    show(p)
    out()
    out()
                                            :(return)
test.end

    s1 = new('set a b')
    s2 = new('set 1 2 3')
    q1 = new('seq')
    push(q1,s1)
    push(q1,s2)
    test(q1)
    out('end test')

end
