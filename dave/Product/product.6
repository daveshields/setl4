
*   Copyright 2017, David Shields
*   Licensed under the MIT license.

-include "../setl4.stl"

    define('product(sets)set.in,set.out,this,n,n.all,set.i,seq') :(product.end)

*   _Product_ returns the Cartesian product of a sequence of sets.

*   Compute the Cartesian product as follows.
*   If the input is the empty set, return the empty set.
*   If there is just one input, return a copy of it.

*   Otherwise compute the product in steps, with the output
*   from one step serving as input to the next.
*   For each element in the first set, build a sequence consisting
*   of the element and add it to the output set.
*   For each element in the remaining sets, iterate the input set.
*   Get the existing sequence of the element, add the element from
*   the remaining set to the sequence, and continue.
*   Return as the product the last output set computed.

product

    product = new('set')
    set.out = new('set')

*   Set the initial value of _set.in_ to be a set of _n_ empty sequences

    set.in = new('set')
    set.i = 0

*   Cartesian product of empty set is an empty sequence.

    sets.n = set.size(sets)
    eq(sets.n)                                       :s(return)

*   Size of result is product of sizes of the sets. Use this
*   value for the size of the output sets.
*   Estimate size of each new sequence as _n_.

    loop(sets)
    n.all = 1

product.get.size

    n.all = n.all * set.size(next(sets))    :s(product.get.size)
    out('n.all',n.all)

product.init.next
    
    le(set.i = set.i + 1,n)                 :f(product.init.done)
    add(set.out,new('seq'))                 :(product.init.next)

product.init.done

*   Loop over the input sets.

    loop(sets)

product.next

    next.set = next(sets)                                  :f(return)
    set.out = new('set #' n.all)
    loop(next.set)

product.next

    this = next(next.set)

    loop(set.in)

product.next.in

    seq = next(set.in)                      :f(product.next.done)
    push(seq,this)                        
    add(set.out,seq)                        :(product.next.in)

product.next.done

    product = set.out
    set.in = set.out                        :(product.next)

product.end
    
    define('test(sets)')                    :(test.end)

test

    out()
    out('enter test')
    out('number of sets',set.size(sets))
    show(sets)
    p = product(sets)
    show(p)
    out()
    out()
                                            :(return)
test.end

    s1 = new('set a b')
    s2 = new('set 1 2 3')
    q1 = new('seq')
    push(q1,s1)
    push(q1,s2)
    test(q1)
    out('end test')

end
