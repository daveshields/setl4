    define('product(sets)')                         :(product.end)                      :f(product.finis)

*   _Product_ returns the Cartesian product of a sequence of sets.

product

    product = new('set')
    set.out = new('set')

*   Cartesian product of empty set is an empty sequence.

    sets.n = set.size(sets)
    eq(sets.n)                                       :s(return)

*   Size of result is product of sizes of the sets.

    loop(sets)
    n.all = 1

product.size

    n.all = n.all * set.size(next(sets))    :(product.size

    loop(sets,.sets.this)                       :f(product.finis)

product.next

    next(sets)                                  :f(product.finis)
    set.out = new('set #' n.all)
    set.i = set.i + 1
    gt(set.i,1)                             :s(product.rest)

*   Here for first set, so just add stack with entry for each element in the set.

    loop(sets.this)

product.first.next

    next(sets.this)                         :f(product.first.done)
    seq = new('seq #' n)
    push(seq,this)
    add(set.out,seq)                        :(product.first.next)

product.first.done

    product = set.out
    set.out = new('set #' n.all)
                                            :(product.next)

product.rest

*   Here when see a set after the first, where stacks ...


    set.i = set.i + 1

*   Here for set following the first.

    loop(set.in,.this.in)

product.rest.in

    seq = next(set.in)                      :f(product.rest.finis)

    loop(sets.this)

product.rest.sets.next

    this = next(sets.this)                  :f(product.rest.in)
    push(copy(seq),this)                    :(product.rest.sets.next)

product.rest.done

    product = set.out
    set.out = new('set #' n.all)
                                            :(product.next)

product.next

    

