
*   Copyright 2017, David Shields
*   Licensed under the MIT license.

-include "../setl4.stl"

    &stlimit = 10000
    define('product(sets)strings,elem,set.in,set.out,this,n,n.all,seq,dt,t') :(product.end)

*   _Product_ returns the Cartesian product of a sequence of strings or sets.
*   For a sequence of strings, _product_ returns the string obtained
*   by concatenating the strings in the sequence.
*
*   Compute the Cartesian product as follows.
*   If the input is the empty set, return the empty set.
*   If there is just one input, return a copy of it.

*   Otherwise compute the product in steps, with the output
*   from one step serving as input to the next.
*   For each element in the first set, build a sequence consisting
*   of the element and add it to the output set.
*   For each element in the remaining sets, iterate the input set.
*   Get the existing sequence of the element, add the element from
*   the remaining set to the sequence, and continue.
*   Return as the product the last output set computed.

product

*   Cartesian product of empty set is an empty sequence.

    sets.n = set.size(sets)
    eq(sets.n)                                       :s(return)

    out('enter product')
    product = new('set')
    set.out = new('set')
    set.in = new('set')

*   Size of result is product of sizes of the sets. Use this
*   value for the size of the output sets.
*   Estimate size of each new sequence as _n_.

    loop(sets,.sets.this)
    n.all = 1

product.get.size

    n.all = n.all * set.size(next(sets))    :s(product.get.size)
    out('n.all',n.all)

*   Loop over the sets.

    loop(sets,.sets.this) 

*   Set the initial value of _set.in_ from the first element of _sets_

    next(sets)                                          :f(product.init.done)
    strings = ident(strings) ident(datatype(set.this),'string') 'TRUE'
    out('strings',strings)
    set.in = differ(strings) new('set ' set.this)       :s(product.init.done)

*   Here if inputs are sequences, so set _set.in_ to a set of the
*   same size as the first input, with each new element an empty sequence.



    le(i = i + 1,sets.n) add(set.in, new('seq #' n))    :s(product.init.seq)

product.init.done

*   Loop over the remaining input sets.

product.next.set

    next(sets)                                  :f(product.done)
    out('product.next.set')
    show(sets.this)
    out()
    set.out = new('set #' n.all)

    loop(sets.this,.set.this)

product.next

    next(sets.this)                             :f(product.next.set)

    out('product.next',set.this)
    show(set.this)

*   Let this.n be the size of the _in.this_. Create a new entry for
*   each entry in _set.in_, the first for the first element in _set.this_,
*   the second for the second elekeng in _set.this_, and so forth.

*   Loop over set.in, 

    loop(set.in,.in.this)

product.next.in

    elem = next(set.in)                            :f(product.next.done)
    ident(elem)                                    :s(product.next.in)
    out('product.next.in dt elem',datatype(elem))
    out('product.next.in elem',elem)
    ident(strings) add(set.out,join(set.this,elem))
    differ(strings) push(set.this,elem)
                                                    :(product.next.in)

product.next.done

    out('product.next.done product')
    product = set.out
    show(product)
    out('product.next.done updated set.in')
    set.in = set.out                    
    show(set.in)
                                            :(product.next.set)
product.don
            :(return)

product.end
    
    define('test(sets)')                    :(test.end)

test

    out()
    out('enter test')
    out('number of sets',set.size(sets))
    show(sets)
    p = product(sets)
    show(p)
    out()
    out()
                                            :(return)
test.end

    s1 = new('set a b')
    s2 = new('set 1 2 3')
    q1 = new('seq')
    push(q1,s1)
    push(q1,s2)
    test(q1)
    out('end test')

end
