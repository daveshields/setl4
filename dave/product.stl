

*   Copyright 2017, David Shields
*   Licensed under the MIT license.

-include "../setl4.stl"

    &stlimit = 25000

  define('product(sets,strings)set.in,set.out,this,i,seq,set.i,dt,t'):(product.end)

*   _Product_ returns the Cartesian product of a sequence of strings or sets.

*   Argument _strings_ if not null then _sets_ is a sequence of strings.
*
*   Compute the Cartesian product as follows.
*   If the input is the empty set, return the empty set.
*   If there is just one input, return a copy of it.

*   Otherwise compute the product in steps, with the output
*   from one step serving as input to the next. For each element
*   in the first set, build a sequence consisting of the element
*   and add it to the output set. For each element in the remaining sets,
*   iterate the input set. Get the existing sequence of the element,
*   add the element from the remaining set to the sequence, and continue.

*   Return as the product the last output set computed.

product

    out('enter product')
    Out('strings',strings)

    product = new('set')
    set.out = new('set')

*   The product of an empty set is the empty set.

    eq(set.size(sets))                                 :s(return)

*   The product of a single set is the set itself.

    gt(set.size(sets),1)                                :s(product.several)

    product = copy(sets)                                :(return)

product.several

*   Loop over the input sets, knowing there are least two sets.

    loop(sets,.sets.this)

*   Initialize set.out from the first set.

    next(sets)

    Out('product.several',datatype(sets.this))
    sets.this = value(sets.this)
    show(sets.this)

    Out('strings',strings)
    differ(strings)                                      :s(product.init.strings)
    

    Out('product of sets')

*   Here to built sequence for each element in the first set consisting of a sequence
*   with that element as its only member

    loop(sets.this,.set.this)

product.init.seq.next

    Out('product.init.seq.next',datatype(set.this))
    next(sets.this)                                     :f(product.init.seq.done)
    seq = new('seq')
    push(seq,set.this)
    add(set.out,seq)                                    :(product.init.seq.next)

product.init.seq.done

    Out('product.init.seq.done')
    show(set.out)
                                                        :(product.next)

product.init.strings 
    Out('product of strings')

    set.out = copy(sets.this)

product.init.done
    Out('product.init.done')
    show(set.out)

product.next

    next(sets)                                         :f(product.done)
    set.in = set.out
    set.out = product1(set.in,sets.this,strings)       :(product.next)

product.done

    product = set.out                                  :(return)

product.end

    define('product1(in,set,strings)in.this,set.out,s,seq,set.this'):(product1.end)

product1

    Out('ENTER PRODUCT1')
    Out('dt in',datatype(in))
    show(in)
    Out('dt set',datatype(set))
    show(set)

    set.out = new('set')

*   Loop over input set.

    loop(in,.in.this)

product1.set.next

    next(in)                                           :f(product1.done)

*   Here with new element in _set_. Generate a new element in _out_ using _in_ and this element.

    loop(set,.set.this)

product1.next

    next(set)                                          :f(product1.set.next)


    Out('dt in.this',datatype(in.this))
    Out('dt set.this',datatype(set.this))
    output  = differ(strings) '[' join(in.this,set.this) ']'
    differ(strings) add(set.out,join(in.this,convert(set.this,'string')))
*HERE
    ident(strings)  add(set.out,join(in.this,push(new('seq'),set.this)))
                                                       :(product1.next)

product1.done

    Out('EXIT PRODUCT1')
    product1 = set.out                                 :(return)

product1.end

    define('test(sets,strings)')                               :(test.end)

test

    out()
    out('enter test')
    Out('show strings')
    out('showing sets')
    show(sets)
    :(return)
    p = product(sets,strings)
    out('computed')
    show(p)
    out()
    out()
                                                       :(return)
test.end


    out('testing sequence of sets')
    s1 = new("set 10 20")
    seq = new("seq")
    push(seq,s1)
    out('showing set 1')
    show(seq)
    s2 = new("set I V C")
    out('showing  set')
    push(seq,s2)
    show(s2)
    out('showing seq')
    show(seq)
    p = product(seq)
    out('done')
end
