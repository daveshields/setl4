
*   Copyright 2017, David Shields
*   Licensed under the MIT license.

-include "../setl4.stl"

    define('product(sets,strings)set.in,set.out,this,i,seq,set.i,dt,t') :(product.end)

*   _Product_ returns the Cartesian product of a sequence of strings or sets.

*   Argument _strings_ if not null then _sets_ is a sequence of strings.
*
*   Compute the Cartesian product as follows.
*   If the input is the empty set, return the empty set.
*   If there is just one input, return a copy of it.

*   Otherwise compute the product in steps, with the output
*   from one step serving as input to the next.
*   For each element in the first set, build a sequence consisting
*   of the element and add it to the output set.
*   For each element in the remaining sets, iterate the input set.
*   Get the existing sequence of the element, add the element from
*   the remaining set to the sequence, and continue.

*   Return as the product the last output set computed.

product

    product = new('set')
    set.out = new('set')

*   The product of an empty set is the empty set.

    eq(set.size(sets))                              :s(return)

*   The product of a single set is the set itself.

*   Loop over the input sets

    loop(sets,.sets.this)

*   Initialize set.in from the first set.

    next(sets)
    set.in = copy(sets.this)              
    show(set.in)

product.next

    next(sets)                                  :f(product.done)
    out('product.next.set')
    product1(set.out,set.in,sets.this,strings) 

                                     :(product.next)

product.done

    product = set.out                       :(return)

product.end
    
    define('product1(out,in,set,strings)s,seq,set.this') :(product1.end)

product1
 
    out("ENTER 1")
    show(in)
    out('strings',strings)
    show(set)
    out()
    loop(set,.set.this)

product1.set.next

    next(set)                           :f(product1.done)
    out('ct1 set.this')

    out('product1.set.next')
    show(set.this)

    loop(in,in.this)

product1.next

    next(in)                            :f(product1.set.next)
    out('product1.next')
    show(in.this)
    differ(strings) add(out,join(in.this,convert(set.this,'string')))
    ident(strings)  add(out,join(in.this,set.this))
    out('updated out')
    show(out)
                                        :(product1.next)

product1.done

    out("EXIT 1")
    show(out)
    out()

product1.end

    define('test(sets)')                    :(test.end)

test

    out()
    out('enter test')
    show(sets)
    p = product(sets,'TRUE')
    out('computed')
    show(p)
    out()
    out()
                                            :(return)
test.end

    s1 = new('set a b')
    s2 = new('set 1 2 3')
    q1 = new('seq')
    push(q1,s1)
    push(q1,s2)
    test(q1)
    out('end test')

end
 
