

*   Copyright 2017, David Shields
*   Licensed under the MIT license.

-include "../setl4.stl"

    &stlimit = 250000

  define('product(sets,strings)pseq,p1,p1.this,seq1,seq2,set1,set2,set.this'):(product.end)

*   _Product_ returns the Cartesian product of a sequence of strings or sets.

*   Argument _strings_ if not null then _sets_ is a sequence of strings.
				 
*   Compute the Cartesian product as follows. If the input is the empty set,
*   return the empty set. Compute the product of a single set or of two
*   sets directly. Otherwise compute the product recursively.

product

    Out('enter product')
    Out('sets dt',datatype(sets))
    show(sets)
    Out('strings',strings)
    
    product = new('set')

*   The product of an empty set is the empty set.

    eq(set.size(sets))                                 :s(product.done)
    gt(set.size(sets),1)                               :s(product.recurse)

*   Here to compute the product of a single set.

    set1 = get(sets,1)

    product = differ(strings) copy(set1)                 :s(return)

    loop(set1)

product.next.one

    next(set1)                                          :f(product1.done)
    add(product,push(new('seq'),this))  
                                                       :(product1.next.one)
product1.done
    Out('product1 result')  
    show(product)
 :(return)

product.recurse

    Out('recurse')
    set2 = top(sets)
*   Out('recurse')
*   show(top(sets))
*   Out('slice')
    seq1 = new('seq')
    set1 = slice(sets,1,set.size(sets) - 1)
    push(seq1,set1)
    push(seq1,push(new('seq'),top(sets)))
    product = product(product(pseq,strings),set2)
    :(return)
                            
product.end


    s1 = new('set x y')
    s2 = new('set 1 2')
    q = new('seq')
    push(q,s1)
    push(q,s2)
    p = product(q,'TRUE')
    show(p)

end
