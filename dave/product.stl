

*   Copyright 2017, David Shields
*   Licensed under the MIT license.

-include "../setl4.stl"

    &stlimit = 25000

  define('product(sets,strings)prior,product,this,i,seq,set.i,dt,t'):(product.end)

*   _Product_ returns the Cartesian product of a sequence of strings or sets.

*   Argument _strings_ if not null then _sets_ is a sequence of strings.
*
*   Compute the Cartesian product as follows. If the input is the empty set,
*   return the empty set. If there is just one input, return a copy of it.
*   Otherwise compute the product recursively.


product

    out('enter product')
    Out('strings',strings)

    product = new('set')

*   The product of an empty set is the empty set.

    eq(set.size(sets))                                 :s(return)
    gt(set.size(sets),1)                               :s(product.recurse)

*   Here to compute the product of a single set.

    ident(strings)  visit(set.add,"add(product, push(new('seq'),this))")
    differ(strings) visit(set.add,"add(product, this)")
                                                       :(return)

product.recurse

    product
*HERE

    odent(strings)  visit(set.add,"add(product, push(new('seq'),this))")
    differ(strings) visit(set.add,"add(product, this)")
    product = 

*   The product of a single set is the set itself.

*   Loop over the input sets

    loop(sets,.set.add)

*   Initialize product from the first set.


    product = new('set')
    next(sets)
    set.add = value(set.add)



product.next.sets

*   Get the next set in the input sequence, so we can extend every entry in
*   the current state of _product_ by adding a new element in the output
*   for each entry in the next set.

    next(sets)                                         :f(product.done)
    set.add = value(set.add)

*   Save the current state of the product in _prior_, which will be extended when
*   iterating over the next set in the input sequence.

    prior = product

    loop(prior)

product.next.prior

*   Get next set

    next(sets)                                          :f(product.next.sets)
    
    set.add = value(set.add)

    product = new('set')

*   Loop over input set.

    loop(prev,.prev.this)

product.next.set

    next(prev)                                           :f(product.next.prior)

*   Here with new element in _in_.

    loop(set.add)

product.next.set.add

    next(set)                                          :f(product.set.next)
    differ(strings) add(product,join(prev.this,convert(this,'string')))
    ident(strings)  add(product,join(prev.this,this))
                                                       :(product.sets.next)

product.end

    define('test(sets,strings)')                               :(test.end)

test

    out()
    out('enter test')
    Out('show strings')
    out('showing sets')
    show(sets)
    :(return)
    p = product(sets,strings)
    out('computed')
    show(p)
    out()
    out()
                                                       :(return)
test.end


    out('testing sequence of sets')
    s1 = new("set 10 20")
    seq = new("seq")
    push(seq,s1)
    out('showing set 1')
    show(seq)
    s2 = new("set I V C")
    out('showing  set')
    push(seq,s2)
    show(s2)
    out('showing seq')
    show(seq)
    p = product(seq)
    out('done')
end
