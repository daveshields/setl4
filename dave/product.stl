    define('product(sets)')                         :(product.end)                      :f(product.finis)

*   _Product_ returns the Cartesian product of a sequence of sets.

product

    product = new('set')
    set.out = new('set')

*   Cartesian product of empty set is an empty sequence.

    sets.n = set.size(sets)
    eq(sets.n)                                       :s(return)

*   Size of result is product of sizes of the sets.

    loop(sets)
    n.all = 1

product.size

    n.all = n.all * set.size(next(sets))    :(product.size

    loop(sets,.sets.this)                       :f(product.finis)

product.next

    next(sets)                                  :f(product.finis)
    set.out = new('set #' n.all)
    set.i = set.i + 1
    gt(set.i,1)                             :s(product.rest)

*   Here for first set, so just add stack with entry for each element in the set.

    loop(sets.this)

product.first.next

    next(sets.this)                         :f(product.first.done)
    seq = new('seq #' n)
    push(seq,this)
    add(set.out,seq)                        :(product.first.next)

product.first.done

    product = set.out
    set.out = new('set #' n.all)
                                            :(product.next)

product.rest

*   Here when see a set after the first, where stacks ...












product.first.next

    elem = next(
    set.in = next(sets)                      :f(product.done)
    set.i = set.i + 1
    gt(i,1)                                 :sw(product.add)


    loop(set.s)
    seq = new('seq #' n)
    add(seq,this)
    add(set.out,seq)
                                            :s(product.first.next)
    loop(set.s)
    first = new('set')
    seq = new('seq')
    push(seq
    gt(i,1)                                 :s(product.even)

    loop(set.s,.this.s)

product.set.next

    next(set.s)                      :f(...
    loop(set.old,.this.old)

product.next.old

    add(set.new,push(new('seq #' n),.this.old))
    visit(product,"add(set.new,push(new('seq #' n),
product.first

    elem = 

*   Add sequence for each element in the first set.

    loop(seq)

product.first.next

    next(seq)                                   :f(product.first.done)
    push(this,new('seq #' n'))
    add(product,this)                           :(product.first.next)

product.first.done


    iter = new('iter 2 ' n)

product.next.set

    set = get(sets,i)
*   For remaining sets, iterate over the set. Add each element to every sequence in
*   the product.

product.p

    next(product)                               :f(product.p.done)
    i = i + 1
    tmp = (eq(i,1) copy(this.p) 
    eq(i,1) push(this.p
    seq = 
    seq = (eq(i,1)  
    j = set
    le(i = i + 1,n)                              :f(return)
    seq = this.seq

*   Add sequence for each element in the first set.

    loop(seq,.this.seq)
    k = 0

product.first.next


    next(seq)                                 :f(product.first.done)
    k = k + 1
    eq(k,1) push(
    s = new('seq #' n')
    push(s,this)                                
    add(product,s)
                                                :(product.first.next)

product.first.done



product.next

    

