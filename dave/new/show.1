    define('show(v,type,limit,within)ara,i,kind,elem,entry,key,line,hdr,n,this,str,value'):(show.end)

*   _Show_ displays the value of its first argument in a form that is hopefully both
*   readable and pleasing to the eye.

*   If _type_ is not null, sets and maps are ranked in order given by _type_.
*   Otherwise sets and maps are increased in ascending value of members (set)
*   or keys (map).

*   _within is non-zero when called to list element of a compound object.

*   If _limit_ is not null, at most _limit_ elements of compount object _v_ are listed.

show

*   limit = differ(limit) +limit
    ident(v)                                            :s(return)

*   Show nothing by writing out nothing.

    ident(v)                                            :s(return)

    ident(datatype(v),'array')                          :s(show.array)
    ident(datatype(v),'table')                          :s(show.table)
    ident(datatype(v),'iterator') show.simple(v,within) :s(return)
    differ(datatype(v),'set') show.simple(v,within)     :s(return)
    

    type = ident(type) '+k'

    kind = set.kind(v)
    ident(kind,'int')                                  :s(show.int)
    ident(kind,'iter')                                 :s(show.iter)
    ident(kind,'map')                                  :s(show.map)
    ident(kind,'seq')                                  :s(show.seq)
    ident(kind,'set')                                  :s(show.set)
    error('show unknown set kind',kind,' quitting.')

show.array

    proto = prototype(ara)
    proto break(',')                                   :s(show.array.2)

*   Here for one dimensional array.

show.array.1
    first = ara[add1(.i)]                              :f(show.array.done)
    out(lpad(i,3) tab first)                           :(show.array.1)

show.array.2
    first = ara[add1(.i),1]                            :f(show.array.done)
    out(lpad(i,3) tab show(first,type) tab show(ara[i,2],type)):(show.array.2)

show.entry

    show = show ' ' show(key(v),type,,within)
.               ':' show(value(v,type),type,,within)
    differ(within)                                      :s(show.within)f(show.done)

show.int

    show = '{ int'
    sorter(v,'+k')
    setl4.save(v)
    loop(v)

show.int.next

    elem = next(v)                                     :f(show.int.done)
    show = show ' ' show(elem,type,'TRUE')
    lt(size(show),72)                                  :s(show.int.next)
    out(show)
    show =                                             :(show.int.next)

show.int.done

    setl4.restore(v)
    show = show ' }'                                   :(show.done)

show.iter

    show = 'iter{ '
    loop(v)

show.iter.next

    elem = next(v)                                     :f(show.iter.done)
    show = show ' ' show(elem,type,'TRUE')
    lt(size(show),72)                                  :s(show.iter.next)
    out(show)
    show =                                             :(show.iter.next)

show.iter.done

    show = show ' }'                                   :(show.done)

show.map

    setl4.save(v)
    show = '{'
    sorter(v,type)
    loop(v)
    within = 'TRUE'

show.map.next

    entry = next(v)                                    :f(show.map.done)
*   lt(limit = limit -1)                               :s(show.map.done)

*   Here to show entry. Look for datatypes _line_ and _token_, showing
*   them directly. Otherwise, show key and value separated by ':' (colon).

*   show = ident(datatype(value(entry),'token'))
*               show  show.token(v,,'TRUE')            :s(show.map.check)

*   show = show ' ' show(entry,type,,'TRUE') ' '
    show = show show(entry,type,,'TRUE')

show.map.check

    lt(size(show),72)                                  :s(show.map.next)
    out(show)
    show =                                             :(show.map.next)

show.map.done

    setl4.restore(v)
    show = show ' }'
    differ(within)                                      :s(show.within)f(show.done)

show.pair

    show = show ' ' show(first(v),type,,'TRUE')  ':' show(second(v,type,,'TRUE')) ' ':(show.done)

show.seq
*HERE*

*   If the sequence has more than ten elements, list as map.

    gt(set.size(v),10)                                  :s(show.map)
    Out('showing short sequence')
    setl4.save(v)
    show = '['
    sorter(v,type)
    loop(v)
    within = 'TRUE'

show.seq.next

    entry = next(v)                                    :f(show.seq.done)
    Out('show.seq.next dt entry',datatype(entry))
    Out('show.seq.next dt value entry',datatype(value(entry)))
    Out('show.seq.next value',value(entry))
*   lt(limit = limit -1)                               :s(show.seq.done)
    show = show ' ' show(value(entry),type,,within)

show.seq.check

    lt(size(show),72)                                  :s(show.seq.next)
    out(show)
    show =                                             :(show.seq.next)

show.seq.done

    setl4.restore(v)
    show = show ' ]'                                   
    differ(within)                                      :s(show.within)f(show.done)
                                                        :(show.done)

show.set

    setl4.save(v)
    show = '{'
    sorter(v,type)
    loop(v)
    within = 'TRUE'

show.set.next

    elem = next(v)                                     :f(show.set.done)
*   lt(limit = limit -1)                               :s(show.set.done)
    show = show ' ' show(elem,type,,'TRUE')
    lt(size(show),72)                                  :s(show.set.next)
    out(show)
    show =                                             :(show.set.next)

show.set.done

    setl4.restore(v)
    show = show ' }'
    differ(within)                                      :s(show.within)f(show.done)

show.string

*   Don't quote string that is an integer.

    show.out((integer(v) +v, show.q(v)))                :(return)

show.table

    within = 'TRUE'
    show = 'table ['
    ara = convert(v,'array')                           :f(show.table.error)
    i = 0
    prototype(ara) break(',') . n                      :(show.table.next)

show.table.error

    error('error converting table to array')

show.table.next

    le(i = i + 1,n)                                    :f(show.table.done)
    show = show ' ' show(ara[i,1],type,,'TRUE') '       :' show(ara[i,2],type,,'TRUE')
    lt(size(show),72)                                  :s(show.table.next)
    out(show)
    show =                                             :(show.table.next)

show.table.done

    show = show ' ]'                                   :(show.done)

show.string.quote

    show = '"'  v '"'                                  :(show.within)

show.done

    differ(show)    out(show)                           :(return)

show.within

*   Here when showing member of composite object.

                                :(return)
    differ(show) out(show)                              :(return)

show.end

    define('show.simple(v)')                            :(show.simple.end)

*   Show the value of an object that has no members.

show.simple

    integer(v) show.out(+v)                             :s(return)

*   Show a string by enclosing it in quotes.


    ident(datatype(v),'string') show.q(v)               :s(return(
    ident(datatype,'real') show.out(v)                  :s(return)
    error('show.simple unsupported type ' datatype(v))
                                                        :(return)

show.simple.end

show.integer

    show.out(v)                                         :(return)

show.simple.iterator

    show.out('{iterator') 
    ne(+iter.start(v))  show.out(' start:'  iter.start(v))
    ne(+iter.finis(v))  show.out(' finis:'  iter.finis(v))
    ne(+iter.step(v))   show.out(' step:'   iter.step(v))
    show.out('} ')
    show.done(within)                                   :(return)

show.simple.end
