*    Copyright 2017, David Shields
*   Licensed under the MIT license.

*   TODO
*       Find out why sanity test is not listing set members in sorted order.
*       extend loop(set) to loop(set,name) to allow user to provide alternative to 'this'.

*## SETL4 is an implementation of SETL written in SPITBOL.


*## What is SPITBOL?

*   SNOBOL is a general programming language with special emphasis on processing 
*   strings and text that was  developed at Bell Labs in the 1960's by a team 
*   led by Ralph Griswold. The final version was called SNOBOL4.

*   Macro SPITBOL, or SPITBOL, is a very efficient implementation of SNOBOL4.
*   Created by Robert B. K. Dewar and Ken Belcher in 1969, SPITBOL/360 
*   was written in IBM/360 assembly language, in what Dewar called
*   "aggressive assembly."
*
*   For example, SNOBOL4 requires maintaining a count of the number of 
*   statements executed and the ability to stop execution when a specified 
*   number of statements have been executed.  SPITBOL/360 does this by
*   computing an unnormalized floating point constant such that successive 
*   increments result in floating point overflow when the limit is reached.

*   Dewar and Belcher also wrote Realia COBOL, a COBOL compiler for Intel/x86 
*   written in COBOL. It produced very efficient code, better
*   code than, for example, that produced by IBM's product COBOL compiler.

*   Dewar ported SPITBOL/360 to several machines. Dewar joined the CIMS faculty
*   as a Professor in the early 1970's. In 1973, while working
*   with Anthony P. "Tony" McCann of Leeds University, he developed
*   Minimal, a portable assembly language. Dewar and McCann then rewrote
*   SPITBOL in Minimal, producing Macro SPITBOL, or SPITBOL. 
*   The implementation has proved very stable, with few changes in
*   several decades.

*   Macro SPITBOL is remarkably small. The code consists of about 28,000
*   lines: 2000 lines of comments defining Minimal, 5000 lines of constant/data 
*   declarations, and 21,000 lines of code.  Every line has a comment.
*   The executable for x86 Linux is 144 kilobytes.

*   SPITBOL was implemented for many machines and operating systems by
*   a small team that included Steve Duff, Mark Emmer, Bob Goldberg, and Dave Shields:
*   ICL 1900, Univac, CDC 6600, IBM PC, Apple Macintosh, SUN Solaris Sparc, 
*   Microsoft (DOS/NT/Windows), Intel x86_64 (Unix/Linux), and x86_64 Apple iOS.  
*   Special credit is due Mark Emmer, who led the project from the mid 1980's
*   to 2009. Dave Shieldsl has maintained SPITBOL since then.

*   SETL4 requires a modified version of standard SPITBOL called BOL4.
*   BOL4 differs from standard SPITBOL as follows:
*
*-  There is no automatic case folding. In standard SPITBOL the names 'x' and 'X' are the same.
*   In BOL4 they are different.
*-  The default case is lower case.
*-  The function _set()_ has been renamed to _zet_, so that _set_ can be used as an identifier.
*-  The default value of _&anchor_ is 1. The default value of _&trim_ is 1.

*   The file `bin/setl4' is the executable for _bol4_.

*## What is SETL?

*   SETL (SET Language)  is  a programming language with  finite sets as 
*   the fundamental data type. It was created by Jacob T. "Jack" Schwartz 
*   of the Courant Institute of Mathematical Sciences (CIMS) of New York 
*   University (NYU).

*   Jack founded the SETL project in 1970. It was later funded by two 
*   five-year grants from the Office of Naval Research.

*   SETL was used to write NYU Ada/Ed, the first validated Ada compiler.
*   Devloped on the DEC Vax 11/780, Ada/Ed was ported to the IBM PC (DOS)
*   by a team led by Dave Shields.


*## Why the name SETL4?

*   The SETL Project produced three implementations of SETL. The first was
*   written by Dave Shields in BALM, a language developed by Prof. Malcom 
*   Harrison of CIMS, the second by Henry S. "Hank" Warren in PL/I while on 
*   leave from IBM, and the third by Robert B. K. Dewar and Art Grand in LITTLE,
*   a low-level implementation language developed at CIMS.

*   SETL4 is the fourth implementation of SETL produced by a member 
*   (Dave Shields) of the NYU SETL project, hence the name SETL4.


*## Brief Introduction to SETL4

*   SETL4 extends SPITBOL by adding the datatype _set_ to represent
*   finite sets. 

*   A set is a collection of distinct elements: for example,  _{a,b,c}_ is a set,
*   as is _{a,b,c,a}_; however, _{a,b,c,a}_ has only three elements, and is 
*   equal to _{a,b,c}_.

*   For example, the folowing SETL4 expression determines if the integer _P_ is prime:

*           !exists(|'int 2 P' @ 'multiple(P,this)')

*   where _multiple(a,b) is true if and only if _a_ is a multiple of _b_.

*## Sets in SETL4

*   SETL4 provides several kinds of sets.

*   Sets of kind 'set' are a collection of distinct members.

*   Sets of kind 'map' consist of a series or ordered pairs,
*   called entries. The first element of an entry is the key,
*   and the second is the value.  No two entries in the map can 
*   have the same key but different values.

*   Sets of kind 'iterator' consist of  integers of the form
*```
*   low, low + step, ... high
*```

*   or

*```
*   high, high - step ... low
*```

*   If only _low_ is specified, then the iteator is interpreted as 'iterator 1 low'.
*   For example, 'iterator 100' is the set 1, 2, ... 100.
*   and 'iterator 5 25 5' is the set {5 10 15 20 25}; where
*   iteration over the iterator will go in order 5, 10 ... 25.
*   'iterator 25 5 -5' is the same set; but iteration will
*   go in the order 25,20 ... 5.
*
*   If _high_ is less than _low_, then a negative step is undersood,
*   even if it is given as a positive value. For example, both
*   `iter 25 5 -5` and `iter 25 5 5' go in order "25, 20 ... 1"
    
*   Iterators support efficient iteration, but they provide only
*   the operations of iteration and membership; you cannot
*   add or remove an element from an iterator.

*   Sets of kind 'integer' are intended or sets of integers
*   containing many elements. See below for more details.

*   A sequence is a map defined on a set of consecutive positive integers.
*   For example 'sequence 5' is a map defined on 1, 2, ... 5.

*   Sequences are represented in the same way as a map. They differ from a map only
*   in that iteration over a sequence returns the values of the sequence, not the
*   instances of _entry_ that are returned when iterating over a map.

*   Sets of kind 'string' consists of a map from integers to characters.

*   By convention, the kinds are writtten 'int', 'iter', 'map', 'seq', and 'set'.


*## Set Data Type

*   A set is a collection unequall objects, and is represented in SETL4 by the datatype _set_:

    data('set(set.kind,set.iter,set.index,set.key,set.kind,set.size,set.this,'
.        'set.block,set.blocks,set.offset,set.str)')

*   where

*- _set.index_         SPITBOL table used to map the integer
*id assigned each element to the value of the element.
*It is needed to support iteration.

*- _set.iter_ iterator for controlling iteration over the set.

*- _set.key_  SPITBOL table mapping set elements to index entries.

*- _set.kind_ 
*is the kind of the set, one of 'int', 'iter', 'map', 'seq', or 'set.'
*The kind is  specified when the set is created. 
*The default kind is 'set'.

*- _set.size_ the current number of members.

*- _set.str_           is used for sets of kind 'int'

*- _set.this_          the most recent value returned by the set's iterator


*   The following fields are used only for sets of kind 'int':

*- _set.block_         block 

*- _set.blocks_        number of blocks

*- _set.offset_        offset within block corresponding to a given integer

* _set.str_           used to update the current block's membersip string


*   New elements in the set are assigned an integer id.
*   The table _set.index_ maps the id to a key;
*   it is used to iterate over the set.
*   The table _set.key_ maps a key to its associated value;
*   it is used to retrieve element values.

*## Sets of integers

*   SETL4 sets of kind _integers' provide an efficient implementation of a set with
*   many non-negative integers, such as  a set with more than a million integers.
*
*   The set is represented by a table of strings, each with  _setl4.config.int_ characters,
*   so that the first block represents the integers `0 .. _setl4_config.int_ -1 and so forth.
*   Addition to  the set is done by setting the appropriate character in a block to '+'.
*   New blocks are allocated only when necesary.

*   The SPITBOL function BREAK is used to find the next element 
*   in the set when iterating over the set.

*## Ordered Pairs

*   In set theory, sets are not ordered. The set _{a,b}_ is the same as (equal to)
*   the set _{b,a}_.

*   Although sets are not ordered, sets can be used to define an ordered pair:

    data('pair(first,second)')

*   by defining _pair(a,b)_ to be
*
*       _{a,{a,b}}_
*
*   It is easy to prove that, given this definition, _pair(a,b)_ is equal
*   to _pair(c,d)_ if and only if _a_ is equal to _c_ and _b_ is equal to _d_.


*## Maps

*   A map defined on a finite set is a set of ordered pairs,
*   or entries, that define a relation between the first element of an entry,
*   its _key_, and the second element of the entry, the value of the map for _key_.

    data('entry(key,value)')

*   A set of ordered pairs is a map if and only if there do not exist two entries
*   _entry(a,b)_ and _entry(c,d)_ such that _a_ is equal to _c_ and _b_ is not equal to _d_.
*   For example, the map defined by the set _{[one,1],[2,two],[one,1]}_ is valid, but
*   one cannot define a map based on the set _{[one,1],[2,two],[one,3]}_.

*   However, SETL4 does allow the use of a set of pairs that would not 
*   be allowed in stanard set theory to define a map. If two of more pairs
*   have the same first value, the the last such pair encountered defines the
*   value to be used. For exampe, the set _{entry(one,1),entry(2,two),entry(one,3)}_ produces
*   the same map as _{entry(one,3),entry(2,two)}_.

*   Though you can use _entry to give a key and its associated value, the
*   preferred convention is separate a key and its value with a ':'
*   allows you to write "key:value," so that 
*```
*       new('map' one:1 two:2 three:3')

*```
*   instead of

*```
*       new('map' entry('one',1) ' ' entry('two',2) ' ' entry('three',3) )
*```

*   Though in set theory, maps are defined in terms of sets, in the SETL4
*   implementation, sets are represented are maps, by mapping each element
*   to itself. For example, the set _{a,b,c}_ is kept as the map: {a:a,b:b,c:c}.

*   SETL4 supports adding entries to a set of kind _map_ by using the
*   key and value in the entry to define the value of the map for _key(entry)_
*   to be _value(entry)_.

*   The SPITBOL datatype TABLE provides the machinery to implement maps.
*   SPITBOL provides no way to determine the number of entries in a table
*   other than converting the map to an array. This is the only way in 
*   SPITBOL to iterate over a SPITBOL table.

*   For this reason, maps are implemented using two tables: _index_ and _key_.
*   Each new entry added to a map is given an integer id, starting with one.  
*   The field _index_ maps the id's to the associated pairs.
*   The entries in _index_ allow efficient iteration over the  
*
*   The table _key_ maps keys in the map to the corresponding entry in the map.
*   The entries in _key_ permit efficient retrieval of the map's value for a given key.

*   SETL4 supports stacks by implementing them as a sequence. The fuction
*   _push()_ pushes a value on to the stack; the function _pop_ removes the
*   top value.


*## Loops, Iterators

*   Loops in SPITBOL have the form of a test followed by the loop body,
*   with the body with a branch back to the test.

*  For example, here is a loop that prints the first one hundred integers:

*```
*test
*       i = i + 1
*       le(i,100)                       :f(done)
*       output = i                      :(test)
*done
*```

*   This can also be written as:

*```
*test
*       output = le(i = i + 1,100) i    :s(test)
*```

*   SETL4 provides the datatype _iterator_ to control iteration over a 
*   range of integers, over a set, or over a map.

    data('iterator(iter.next,iter.start,iter.finis,iter.step,'
.                 'iter.block,iter.blocks,iter.offset,iter.str)')

*   where

*-  _iter.next last value returned by the iterator.

*-  The following fields are used to iterate over a range:

*-  _iter.start_ starting value for iteration

*-  _iter.finis_ finishing value for iteration

*-  _iter.step_  difference between values of an iteration

*   Loops in SETL4 are constructed using the _loop_ and _next_ statements. 
*   For example, the program to display the first one hundred integers can
*   be written as:

*```
*   set = integers(100)
*   loop(set)
*next
*   this = next(set)                  :f(done)
*   output = this                     :s(test)
*done
*```

*   The _loop_ statement creates an instance of _iterator_ to control the
*   iteration. The _next_ statement advances the iteration by producing the
*   next element or failing if no more elements remain.
*   The variable _this_ is set to the next element in an iteration if a call
*   to _next_ succeeds, so the loop can be written in SETL4 as:

*```
*   set = integers(100)
*   loop(set)
*test
*   output = next(set)                  :s(test)
*```

*   See the functions _prime_ and _primes_ defined below to see _loop_
*   and _next_ in action. See also the code for _exists_ and _forall_.

*## Additional Operations Provided as an Artifact of the Implementation
    
*   The use of the tables _set.index_ and _set.key_ to implement a set makes it
*   possible to provide some operations not available in in standard set theory. 
*   For example, it is possible to retrieve elements using the function _get_. 
*   _Get(s,i)_ retrieves the i-th element in the set.

*   The function _sorter can be used to determine the order in which the elements 
*   of a set are accessed during an iteration, or to 'sort' the tables implementing
*   the set. For example, _sorter(s,'+v')_ sorts a map in increasing order of the
*   values of the map. _sorter(s,'-v')_ sorts the values in descendng order, and
*   so forth. For example, here is the code to find the ten members with 
*   the largest values in a map:

*```
*       sorter(map,'-v')
*       largest = new('set')
*       iter = new('iter 1 10')
*       loop(set)
*   
*   largest.add
*   
*       add(largest,next(set))               :s(largest.add)
*```

*   _Rank_ is used by the _show_ function to display the values of a set or
*   map in a standard order. For example, if _s_ is a set with the elements
*   'a', 'b' and 'c', then _show(s)_ yields `set 'a' 'b' 'c' }`, not 
*   `set 'b' 'c' 'a' }`.

*## SETL4 Configuration Options

*   _setl4.config.channel.1_ is channel number for temporary files, that is,
*   files created on entry to a procedure and closed before returning from
*   the procedure.

    setl4.config.channel.1 = 3

*   Define initial sizes of tables when creating a set.

*   _setl4.config.set.table.size_ is default size for the _index_ and _key_ tables of a set.

    setl4.config.set.table.size = 1024

*   _setl4.config.int.table.size_ is size of index and key tables in set of kind 'int.' 

    setl4.config.int.table.size = 1000

*   _setl4.config.int_ is number of characters in the block for an integer set.
*   _setl4.config.int.init_ is string of spaces of size _setl4.config.int_.

    setl4.config.int = 1000
    setl4.config.int = 20
    setl4.config.int.init = dupl('-',setl4.config.int)

*## Additonal SETL4 data types

*   SETL4 provides the following data type in addtion to _set_: 

*       _token_

*   where 

*       token(lineno,ndx,type,text) is a lexeme, or lexical token.

*## Show

*   The function _show_ writes out the value of a SETL4 object in a readable 
*   form. Objects are shown in the order defined by the function _sorter.



*   '@'     s @ e   Eval            Evaluates _e_ at current element of set _s_
*   '#'     s # e   Filter          Returns subset of set _s_ for which _e_ is true
*   '~'     m ~ s   Membership      Tests if _m_ is member of set _s_


*## SETL4 Unary Operators:

*   '='     =s      Iteration       Returns 'this', the current element of an iteration
*   '|'     |str    Constructor     Returns set specified by string _str_
*   '!'     !expr   Not             True if and only if _expr_ is false
*   '#'     #s      Size            Number of elements in set _s_
*   '/'     /s      Split           Splits a string into a sequence of words

*   The following operator definitions are not yet in effect, due to a need
*   to change the underlying SPITBOL implementation.

*   '&'     a & b   And             True if and only if both _a_ and _b_ are true
*   '^'     a ^ b   Or              True if and only if _a_ or _b_ is true

*## SETL4 Functions
*
*-  add(set,elem)               Adds element to set.
*-  and(a,b)                    And: test if both operands are true.
*   append(str,w,ch)            Appends _ch_ (or space if _ch_ is null) to _str_, then _w_
*-  arbitrary(n)                Returns arbitary (randomly chosen) integer in 1 .. _n_.
*-  arbitrary(set)              Returns arbitary (randomly chosen) element of _set_.
*-  ascii(line)                 Returns the text of line with every ascii character identified
*-  assert(expr)                Tests that _expr_ is true, ends execution otherwise.
*-  assert.type(obj,type)       Tests that _obj_ has SPITBOL datatype _type_, ends execution otherwise.
*-  begins(str,sub)             Tests if string _key_ begins with string _sub_.
*-  checkout(filename)          Returns ('checks out') set or map defined by a file in the libary
*-  compare(a,b)                Compares two integers or strings, returning -1 (less), 0 (equal), or +1 (greater).
*-  compose(a,b)                Returns composition of two maps or tables.
*   datename(date)              Returns string based on current time suitable for use as filename
*-  defined(map,key)            Tests if a map is defined for a specified key.
*-  difference(a,b)             Returns set of members of set _a_ not in the set _b_.
*-  digits()                    Returns list of digits: '0 1 2 .. 9'
*-  domain(map)                 Returns set of elements in the domain of a map.
*-  equal(a,b)                  Tests if two SETL4 objects are equal.
*   even(n)                     Tests if _n_ is even
*-  exists(set,expr)            Tests if an expression is true for at least one element in a set.
*-  factorial(n)                Returns n!  = n * (n -1) * ... * 1
*-  from(set,elem)              Returns set consisting of the members of a set except a specified member.
*-  get(map,key)                Gets the value of map _map_ for _key_ for a map.
*-  get(set,i)                  Gets the i-th element in a set, or fails if no such element.
*-  false(e)                    Tests if argument is false.
*-  filter(set,expr)            Returns set of elements in _set_ for which _expr_ is true.
*-  forall(set,expr)            Tests if an expression is true for every element of a set.
*-  integers(n)                 Returns set of integers 1 ... n.
*-  intersection(a,b)           Returns set of elements common to two sets.
*-  is.integer(n)               Tests if _n_ is integer or string representing integer, returing its value if so, or else failing.
*-  is.string(s)                Tests if _s_ is a string, returning its value if so, or else failing.
*-  letters()                   Returns list of letters : 'a b c ... z A B ... Z''
*-  join(a,b)                   Joins two strings into a single string by concatenating them.
*-  less(str,sub)               Removes the first instance of each character in _sub_ from _str_,
*-  loop(set)                   Set up iteration over _set_ using _next_.
*-  lower.case(s)               Returns _s_ with upper case letters replaced by lower case equivalent
*-  multiple(n,m)               Tests if _n_ is a multiple of _m_
*-  odd(n)                      Tests if _n_ is odd
*-  out(text1,text2,text3)      Outputs _text1_, then _text2_ enclosed in '[]' if _text2_ not null
*-  prefix(str,pre)             Takes a list of space-separated words in _str_, prefixes each with _pre_
*-  member(elem,set)            Tests if _elem_ is a member of _set_
*-  new(str)                    Returns a new set specified by _str_
*-  next(set)                   Returns next element in iteration defined by prevous _loop_, fails if no more elements.
*-  not(expr)                   Tests if operand is false.
*-  number(s)                   Returns integer defined by _s_.
*-  or(a,b)                     Tests if either operand is true.
*-  push(stack,value)           Push value onto a stack
*-  pop(stack)                  Pop the top of a stack and return its value
*   prime(n)                    Tests if _n_ is prime
*   primes(n)                   Returns set of primes less than _n_
*-  put(map,key,val)            Defines the value of a map key.
*   quicksort(seq)              Use Hoare's quicksort algorithm to sort a sequence
*-  random(n)                   Returns random integer if _n_ is integer, elsel random element of set or map
*-  random.seed()               Sets random number seed to initialize _random_
*-  range(map)                  Returns set of elements in the range of a map
*   reader(filename,expr)       Returns sequence of lines in file _filename_, using _expr_ (if given)
*   reader(str,delim)           Like _reader(filename..)_ but reads lines from a string with lines
*-  remove(set,elem)            Removes arbitary element from set, or most recent entry from map
*-  set.size(set)               Returns number of elements in set _set_.
*-  show(v,within)              Shows value of _v_, with _within_ set non-zero when listing member of set
*-  show.b(e)                   Shows value of _b_ as boolean
*-  show.lines(lines,number)    Shows a sequence of lines, with id if _number_ not null.
*-  show.q(str)                 Shows string enclosed in appropriate quote character (" or ') .
*   slice(str,first,last)       Same as SPITBOL _substr(str,first,last)_
*-  sorter(set,type)            Sorts a set, map or string according to _type_
*-  split.line(line)            Splits line of blank-separated words into sequence.
*-  split.string(str)           Splits string into sequence of characters.
*   square.root(n)              Returns integer square root on _n_
*-  subset(a,b)                 Tests if the set _b_  is a subset of set _a_
*-  this(set)                   Returns current iteration value for _set_.
*   thousands(s)                Returns _s_ with a comma every three spaces from the right
*-  top(s)                      Returns top element of sequence viewed as stack.
*-  traceon()                   Turns on tracing.
*-  traceoff()                  Turns off tracing
*   tokens(line)                Returns sequence of the tokens in _line_
*-  true(e)                     Tests if operand is true
*-  union(a,b)                  Returns set consisting of all the members in two sets.
*   upper.case(s)               Returns _s_ with lower case letters replaced by upper case equivalent
*-  visit(set,expr)             Visits each element of set _set_ and evaluates _expr_ for that element
*-  words(line,w)               Returns sequence of words (defined by _w_) in _line_.
*   writer(lines)               Writes sequence _lines_ to standard output


*   SETL4 Function Definitions

    define('add(set,elem)ara,i,n,str')              :(add.end)

*   _Add_ adds an element to a set if it not already a member.
*   If the set has kind _map_ and _elem_ has the data type _entry_
*   the map is updated using the key and value of the entry.

add

    elem = integer(elem) +elem
    ident(set.kind(set),'map')                      :s(add.map)
    ident(set.kind(set),'seq')                      :s(add.seq)
    differ(set.kind(set),'map')                     :s(add.set)

add.map

    differ(datatype(elem),'entry') error("can only add 'entry' elements to a map.")
    put(set,key(elem),value(elem))                  :(return)

add.seq

    error("Use 'put' or 'push', but not 'add', to add elements to a sequence.")

add.set
    member(set,elem)                                :s(return)
    set.size(set) = set.size(set) + 1
    set.index(set)[set.size(set)] = elem
    set.key(set)[elem] = elem                       :(return)
    
add.end

    define('and(a,b)')                              :(and.end)

*   _And_ tests if both operand are true (not null), only 
*   evaluating the second argument when necessary.

and

*   See if both operands are integers.

    and = integer(a) eq(a)                          :s(freturn)
    and = integer(a) integer(b) ne(a * b)           :s(return)f(freturn)

*   Here where at least one operand for 'and' is not integer, so
*   use ident/differ to evaluate.

    and = differ(a) differ(b)                       :s(return)f(freturn)

and.end

    define('append(str,w,ch)')                  :(append.end)

*   _Appends appends _ch_, or ' ' if _ch_ is null, to _str_ and then appends _w_.

append

    append = str (ident(str) w, (ident(ch) ' ' , ch) w):(return)

append.end

    define('arbitrary(set)iter,r')                  :(arbitrary.end)

*   _Arbtrary_ returns an arbitrary (randomly selected) element of a set, or
*   if the argument is an integer, then _arbitrary_ returns a random
*   integer in the range 1 .. _set_.

arbitrary

    arbitrary = integer(set) random(+set)           :s(return)
    r = random(set.size(set))
    ident(set.kind(set),'iter')                     :s(arbitrary.iter)
    arbitrary = set.key(set)[set.index(set)[r]]
                                                   :(return)

arbitrary.iter

    iter = set.iter(set)
    arbitrary = iter.starbitraryitrary(iter) + (r - 1) * iter.step(iter) :(return)

arbitrary.end

    define('ascii(line)c,n,name,nul,num,pos')   :(ascii.end)

*   _Ascii_ returns the text of its argument string with every ascii character identified.

ascii

    differ(ascii.initialized)                   :s(ascii.initialized)

*   Here to initialize the needed maps.
    
    ascii.init()
    ascii.initialized = 1

ascii.initialized

    nul = substr(&alphabet,1,1)

ascii.next

*   Add space after previous character if result not null.

    ascii = differ(ascii) ascii ' '
    c = substr(line,1,1)                        :f(ascii.done)
    ident(c,nul)                                :s(ascii.null)
    line any('0123456789')                      :s(ascii.integer)
    line any(&lcase &ucase)                     :s(ascii.letter)
    line ' '                                    :s(ascii.space)

*   Check for control character (code <=26)

    &alphabet break(c) . pos                    :f(ascii.other)
    pos = size(pos)
    gt(pos,26)                                  :s(ascii.other)
*TODO here fix g. usage
    ascii = ascii g.ascii.name[c] '(^'
               substr('ABCDEFGHIJKLMNOPQRSTUVWXYZ',pos,1) ')'
    line len(1) =                               :(ascii.next)

ascii.integer

    line span('0123456789') . text =
    ascii = ascii  text                         :(ascii.next)

asciiletter

    line span(&lcase &ucase) . text =
    ascii = ascii  text                         :(ascii.next)

ascii.null

    ascii = ascii 'NUL'                         :(ascii.next)

ascii.other

*   Here if none of the other cases apply, so just list the ascii name.

    ascii = ascii ascii.name[c]
    line = substr(line,2)                       :(ascii.next)

ascii.space

    line span(' ') . text =

    ascii =  ascii 'SPC'
    ascii = gt(size(text),1) ascii 'SPC*' size(text)
    ascii = ascii
                                                :(ascii.next)
ascii.done

    ascii = trim(ascii)                     :(return)

ascii.end

    define('ascii.init(init)entry,name,value') :(ascii.init.end)

*   _Ascii.init_ Initialize maps for use by _ascii_.
*   Since space (ascii 32) prints as space, use the name SPC for 32.

ascii.init


    ascii.init = new('map '
.      '0:NUL 16:DLE 32:SPC 48:0 64:@ 80:P  96:` 112:p '
.      '1:SOH 17:DC1 33:!   49:1 65:A 81:Q  97:a 113:q '
.      '2:STX 18:DC2 34:"   50:2 66:B 82:R  98:b 114:r '
.      '3:ETX 19:DC3 35:#   51:3 67:C 83:S  99:c 115:s '
.      '4:EOT 20 DC4 36:$   52:4 68:D 84:T 100:d 116:t '
.      '5:ENQ 21:NAK 37:%   53:5 69:E 85:U 101:e 117:u '
.      '6:ACK 22:SYN 38:&   54:6 70:F 86:V 102:f 118:v '
.      "7:BEL 23:ETB 39:'   55:7 71:G 87:W 103:g 119:w "
.      '8:BS  24:CAN 40:(   56:8 72:H 88:X 104:h 120:x '
.      '9:HT  25:EM  41:)   57:9 73:I 89:Y 105:i 121:y '
.      '10:LF 26:SUB 42:*   58:  74:J 90:Z 106:j 122:z '
.      '11:VT 27:ESC 43:+   59:; 75:K 91:[ 107:k 123:{ '
.      '12:FF 28:FS  44:,   60:< 76:L 92:\ 108:l 124:| '
.      '13:CR 29:GS  45:-   61:= 77:M 93:] 109:m 125:} '
.      '14:SO 30:RS  46:.   62:> 78:N 94:^ 110:n 126:~ '
.      '15:SI 31:US  47:/   63:? 79:O 95:_ 111:o 127:DEL ')

    ascii.name = .map(efault.size)
    ascii.value = .map(efault.size)
    loop(ascii.init)

ascii.init.next

    entry = setl4.l.next(ascii.init)                :(ascii.init.finis)
*   Correct entry for 0 to be NUL, the NUL character
    ascii.name[substr(&alphabet,+v + 1,1)] = name
    ascii.value[name] = +value                      :(ascii.init.next)
    ascii.name[] = 'NUL'
    ascii.value['NUL'] = 0
    ascii.name[' '] = 'SPC'
    ascii.value['SPC'] = 32                         :(return)

ascii.init.end

    define('assert(expr)')                          :(assert.end)

*   _Assert_ tests that its argument expression is non null, ending execution otherwise.

assert

    true(expr)                                      :s(return)
    error('assertion failed, quitting') 

assert.end

    define('assert.type(obj,typ)')                  :(assert.type.end)

*   _Assert.type_ tests that _obj_ has datatype _typ_, and ends execution if not.

assert.type

    assert(ident(datatype(obj),typ))                :s(return)
    error('assertion on datatype failed ' typ )
    

assert.type.end

    define('begins(str,init)')                      :(begins.end)

*   _Begin_ tests if string _str_ begins with string _init_.
*   It returns _str_ on success, fails otherwise.

begins

    ident(str)                                      :s(freturn)
    ident(init)                                     :s(freturn)
    begins = str
    ident(str,init)                                 :s(return)
    gt(size(init),size(str))                        :s(freturn)
    ident(substr(str,1,size(init)),init)            :s(return)f(freturn)

begins.end

	define('checkout(filename)file,fullname,line,word')	    :(checkout.end)

*	_Checkout_ checks out (retrieves)  a file from the library as a sequence of lines
*   or a set of words. _Checkout_ lists the available files if _filename_ is null.

*   Dictionary has one word per line, with upper case 'S' at end denoting
*   that both singular and plural form are words in the dictionary.

*   When checking out text files, skip blank lines and lines that start with '*'.


checkout

    differ(filename)                                :s(checkout.check)

checkout.list

    out('available texts in the checkout:')
	out('dictionary')
	out('genesis')
	out('hamlet')
	out('new-testament')
	out('old-testament')
	out('romeo-and-juliet')
	out('shakespeare')
	out('sonnets')
                                                    :(return)

checkout.check

*   See if _filename_ matches one of the available texts.


	filename = begins('dictionary',filename)        :s(checkout.open)
	filename = begins('enable1',filename)		    :s(checkout.open)
	filename = begins('genesis',filename)		    :s(checkout.open)
	filename = begins('hamlet',filename)		    :s(checkout.open)
	filename = begins('new-testament',filename)	    :s(checkout.open)
	filename = begins('old-testament',filename)	    :s(checkout.open)
	filename = begins('romeo-and-juliet',filename)  :s(checkout.open)
	filename = begins('shakespeare',filename)	    :s(checkout.open)
	filename = begins('sonnets',filename)		    :s(checkout.open)

    out('sorry, that text is not available.')
    out('here is a list of the available texts')    :(checkout.list)

checkout.open

	fullname = '../library/' filename '.txt'
	input(.file,3,fullname)		                    :s(checkout.opened)
	error('unable to open file ',filename)	        :(freturn)

checkout.opened

*   Dictionary requires special handling.

    ident(filename,'dictionary')                    :s(checkout.dictionary)
    checkout = set('seq',iterator(),table(2000),table(2000))

checkout.next

	line = file					                    :f(checkout.finis)
    lines = lines + 1
    ident(line)                                     :s(checkout.next)
    line '*'                                        :s(checkout.next)
    push(checkout,line)                             :(checkout.next)

checkout.dictionary

    checkout = set('set',iterator(),table(40000),table(40000))

checkout.dictionary.add

    add(checkout,word)

checkout.dictionary.next

    word = file                                     :f(checkout.finis)
    ident(substr(word,size(word),1),'S')            :f(checkout.dictionary.add)

*   Here if plural. Add plural form and them merge to add singular form.

    word = substr(word,1, size(word) - 1)
    add(checkout, word 's')                         :(checkout.dictionary.add)

checkout.finis

	endfile(3)				                        :(return)

checkout.end

    define('compare(a,b)')                                          :(compare.end)

*   _Compare_ compares two integers or strings, returning -1 if the _a_ is
*   less than _b_ , 0 if both have the seq.eq value, and +1 if the _a_ is greater than _b_.

compare

    a = integer(a) +a
    b = integer(b) +b
*   out('compare ' datatype(a) ' ' datatype(b))
    differ(datatype(a),datatype(b)) error("compare argument types differ " datatype(a) " " datatype(b))
    ident(datatype(a),'string')                                     :s(compare.strings)

*   Here to numerically compare integers.

    compare = lt(a,b) -1                                            :s(return)
    compare = eq(a,b) 0                                             :s(return)
    compare = 1                                                     :(return)

compare.strings

*   Here to lexically compare strings.
    compare = llt(a,b) -1
    compare = leq(a,b) 0
    compare = lgt(a,b) 1
*   out('compare ' show(a) ' ' show(b) ' ' compare)
                                                                :(return)

compare.end

    define('compose(a,b)ara,i,key,value')               :(compose.end)

*   _Compose_ returns the composition of two maps or tables.

compose

    ident(datatype(a),'table')                      :s(compose.table)

*   Here to compose two maps.

    out('compose dt a',datatype(a))
    n = set.size(a)
    compose = eq(n) new('map')                      :s(return)
    compose = new('map #' n)
    set.size(compose) = n

compose.map.next

    le(i = i + 1,set.size(a))                       :f(return)
    key = set.index(compose)[i] = set.index(a)[i]
    value = set.key(b)[set.key(a)[key]]
    set.key(compose)[key] = value                   :(compose.map.next)

compose.table

    ara = convert(a,'array')                        :f(show.table.error)
    prototype(ara) break(',') . n
    compose = table(n)
    i = 0

compose.table.next

    le(i = i + 1,n)                                 :f(return)
    compose[i] = b[a[i]]                            :(compose.table.next)

compose.end

    define('datename()s')                           :(datename.end)

*   _Datename_ converts the current date in a form with no spaces,
*   just dashes, that is suitable for use as part of a file name.

datename

    datename = replace(date(),' :/','---')
    datename = substr(datename,12,8) '-' substr(datename,1,10)
                                                    :(return)
datename.end

    define('defined(map,key)entry')                 :(defined.end)

*   _Defined_ tests if the map _map_ has an entry for _key_.

defined
    key = integer(key) +key
    defined = set.key(map)[key]                     
    differ(defined)                                  :s(return)f(freturn)

defined.end

    define('difference(a,b)this')                   :(difference.end)

*   _Difference_ returns the set defined by the set of elements of _a_ that are not in _b_.

difference

    difference = new()
    loop(a)

diference.next

    this = next(a)                                  :f(return)
    member(b,this)                                  :s(difference.next)
    add(difference,this)                            :(difference.next)

difference.end

    define('digits()str,ch')                        :(digits.end)

*   _Digits_ returns the string consisting of the digits 0 .. 9 separated by a space.

digits

    digits = 
    str = '0123456789'
    
digits.next

    str len(1) . ch =                               :f(return)
    digits = append(digits,ch)                      :(digits.next)

digits.end

    define('domain(map)elem)')                      :(domain.end)

*   _Domain_ returns the domain of map, which is the set of the keys in _map_.

domain

    domain = new()
    loop(map)

domain.next

    entry = next(map)                               :f(return)
    differ(entry) add(domain,key(entry))            :(domain.next)

domain.end

    define('equal(a,b)entry,i,key,value')                        :(equal.end)

*   _Equals_ tests if two objects are equal. Use DIFFER unless both are sets, in
*   which case use equality tests specified below.

equal
  
    ident(datatype(a),'set') ident(datatype(b),'set'):s(equal.sets)
    ident(a,b)                                      :s(return)f(freturn)

equal.setl4

*   Here for equality test of two SETL4 objects.

    ident(set.kind(a),set.kind(b))                  :f(freturn)
    eq(set.size(a),set.size(b))                     :f(freturn)
            :($('equal.' set.kind(a)))

equal.int

    eq(iter.start(a),iter.start(b))                       :f(freturn)
    eq(iter.finis(a),iter.finis(b))                     :f(freturn)
    eq(iter.step(a),iter.step(b))                     :f(freturn)s(return)

equal.map

*   Two maps are equal if they have the same vaue at every element in the domain.

    gt(i = i + 1, set.size(a))                      :s(equal.true)
    entry = set.index(a)[i]
    ident(value(entry),get(b,key(entry)))           :f(freturn)s(equal.map)

equal.seq

*   Two sequences are equal if they have the same vaue at every element in the domain.

    gt(i = i + 1, set.size(a))                      :s(equal.true)
    ident(set.seq(a)[i], set.seq(b)[i])             :s(equal.seq)f(freturn)

equal.sets
   
   
    lt(set.size(a),set.size(b))                     :s(freturn)
    ident(set.kind(a),set.kind(b))                  :f(freturn)
    ident(set.kind(set),'int')                      :s(equal.int)
    ident(set.kind(set),'iter')                     :s(equal.iter)
    ident(set.kind(set),'map')                      :s(equal.map)
    ident(set.kind(set),'seq')                      :s(equal.seq)
    ident(set.kind(set),'set')                      :s(equal.set)
    error('equal mismatched kinds')             


equal.set

*   Two sets are equal if and only if each is a subset of the other.
    subset(a,b)                                     :f(freturn)
    subset(b,a)                                     :f(freturn)
                                                    :(return)
    equal = and(subset(a,b),subset(b,a))            :f(freturn)s(return)

equal.end

    define('even(n)')                           :(even.end)

*   _Even_ tests if its argument is even.

even

    eq(remdr(n,2))                              :s(return)f(freturn)

even.end

    define('error(str)')                            :(error.end)

*   _Error_ writes out its argument string and ends execution.

error

    &dump = 2
    &dump = 3
    out('&dump',&dump)

*   Clear variables that need not appear in &dump output

    setl4.clear()
    out('Fatal error: ' str)                        :(end)

error.end

    define('exists(set,expr)this,e')                :(exists.end)

*   _Exists_ tests if there is an element in _set such that _expr_ is true.

exists

    loop(set)

exists.loop

    this = next(set)                                :f(freturn)
    exists = eval(expr)                             :f(exists.loop)s(return)

exists.done

    output = 'exists loop ended, failing' :(freturn)

exists.end

    define('factorial(n)')                      :(factorial.end)

*   _Factorial_ computes the value of the factorial function of its argument.

factorial

    factorial = (eq(n,1) 1, n * factorial(n -1))    :(return)

factorial.end

    define('false(e)')                              :(false.end)

*   _False_ tests if its argument is false (null).

false

    e = integer(e) +e
    false = integer(e)  eq(e)                       :s(freturn)
    false = ident(e)                                :s(return)f(freturn)

false.end

    define('filter(set,expr)e,this')                :(filter.end)

*   According to Paul Halmos, in his book "Naive Set Theory,"
*   a major principle of set theory, often referred to by its
*   German name _Aussonderungsaxiom_, is the Axiom of Specification:

*   To every set _A_ and every condition _S(x)_ there corresponds
*   a set _B_ whose elements are exactly those elements _x_ of _A_
*   for which _S(x)_ holds.

*   In SETL4 we say that the expression '_A_ @ _S_' "filters"
*   _A_ by _S_. This can also be read as
*           "the subset of _A_ such that _S_ is true"

*   Returns the subset of set, map or sequence _set_ for which _expr_ is true.

filter

    out('filter dt seq',datatype(set))
    out('filter set.kind',set.kind(set))
    ident(set.kind(set),'map')                      :s(filter.map)
    ident(set.kind(set),'seq')                      :s(filter.seq)
    out('filtering set')
    filter = new('set')
    loop(set)

filter.set.next

    this = next(set)                                :f(return)
    eval(expr) out('filter.set.next adding ',this)
    eval(expr) add(filter,this)    :(filter.set.next)

filter.map

    filter = new('map')
    loop(set)

filter.map.loop

    this = next(set)                                :f(return)
    out('at filter.map.loop')
*   out('filter this',this)
    eval(expr) push(filter,value(this))             :(filter.map.loop)

filter.seq

    filter = new('seq')
    loop(set)

filter.seq.loop

    this = next(set)                                :f(return)
*   out('at filter.seq.loop')
    out('filter this',this)
    eval(expr) push(filter,this)                    :(filter.seq.loop)

filter.end

    define('forall(set,expr)e')                     :(forall.end)

*   _Forall_ tests if _expr_ is true for all elements of _set_.

forall

    loop(set)

forall.loop

    next(set)                                       :f(return)
    e = eval(expr)                                  :f(freturn)s(forall.loop)

forall.end

    define('from(set,elem)this')                    :(from.end)

*   _From_ removes an (existing) element from a set.

from

    from = new()
    loop(set)

from.next

    this = next(set)                                :f(return)
    differ(this,elem) add(from,this)                :(from.next)

from.end

    define('get(map,key)val,entry')                 :(get.end)

*   _Get_ gets the value of the key _key_ in the map _map_, or gets
*   element _key_ in a set, failing if no such element.

get

    key = integer(key) +key
    ident(set.kind(map),'int')                      :s(get.int)
    ident(set.kind(map),'map')                      :s(get.map)
    ident(set.kind(map),'seq')                      :s(get.map)
    ident(set.kind(map),'set')                      :s(get.set)
    error('get on unsupported kind of set: ' set.kind(map))

get.int

    error("get on set of kind 'int' not yet supported.")

get.map

    get = set.key(map)[key]                         :(return)

get.set

    ident(set.kind(map),'iter')                     :s(get.int)
    get = set.index(map)[key]
    ident(get)                                      :s(freturn)f(freturn)
    get = set.key(map)[entry]                       :(return)

get.end

    define('int(n)')                                :(int.end)

*   _Int_ Returns _n_ if _n_ is an integer, or returns _n_ converted to an
*   integer if _n_ is real, or returns the value of a string written in exponential 
*   (scientific) notation converted to its integer value.

int

    int = integer(n) n                              :s(return)
    int = ident(datatype(n),'real') convert(n,'integer') :s(return)
    int = n
    n break('e')                                    :f(return)
    n break('e') . int 'e' =
    int = int * +('1' dupl('0',n))                  
    int = +int
                                                    :(return)

int.end

    define('integers(n)')                           :(integers.end)

*   _Integers_ returns the set containing the integers 1 .. _n_

integers

    integers = set('set',iterator(),table(n),table(n))

integers.next

    le(i = i + 1,n) add(integers,i)                 :s(integers.next)f(return)

integers.end

    define('intersection(a,b)this')                 :(intersection.end)

*   _Intersection_ returns the intersection of its argument sets.

intersection

*   Make _a_ the smaller 

    le(set.size(a),set.size(b))                     :s(intersection.next)
    a = b
    b = intersection
    intersection = new()
    loop(a)

intersection.next

    this = next(a)                                  :f(return)
    member(b,this) add(intersection,this)           :(intersection.next)

intersection.end

    define('is.integer(n)')                          :(is.integer.end)

*   Test if _n_ is a string with integer value or integer, return its
*   value if so, fail otherwise.

is.integer

    is.integer = integer(n) +n                       :s(return)f(freturn)

is.integer.end

    define('is.string(s)')                          :(is.string.end)

*   _Is.string_ tests if _s_ is a string , returning its value if so, or else failing.

is.string

    is.string = ident(datatype(s),'string') s        :s(return)f(freturn)

is.string.end

    define('join(a,b,c)i')                             :(join.end)

*   _Join_ joins strings by concatenating them, and sequences
*   by returning a new sequence consisting of all the elements of
*   the first followed by all the elements of the second, and then
*   by the elements of the third.

*   If called with three arguments, the result returned is the same as join(join(a,b),c)`

join

    ident(a)                                        :s(return)
    ident(datatype(a),'string')                     :s(join.string)
    join = new('seq')
    loop(a)

join.a

    push(join,next(a))                              :s(join.a)
    loop(b)

join.b

    push(join,next(b))                              :s(join.b)
    loop(c)

join.c

    push(join,next(c))                              :s(join.c)f(return)

join.string

*   Here to join strings.

    join = a (differ(b) b, '') (differ(c) c,'')     :(return)

join.end

    define('loop(set)iter')                         :(loop.end)
*   _Loop_ creates or updates the iterator of _set_ so that,
*   on first call to _next()_,  _iter.next_  will be 
*   advanced to select the first element in the iteration.

loop

    ident(set.kind(set),'iter')                     :s(loop.iter)
    ident(set.kind(set),'int')                      :s(loop.int)
    ident(set.kind(set),'map')                      :s(loop.map)
    ident(set.kind(set),'seq')                      :s(loop.map)
    ident(set.kind(set),'set')                      :s(loop.set)
    error('unknown kind of iterator: ' set.kind(set))

loop.int

    iter = iterator()
    iter.next(set) = set.block(iter) = set.offset(iter) = 0 
    set.iter(set) = iter                            :(return)

loop.iter

*   When iterating over a set of kind 'iter', use the iterator
*   created when the set was created.

    iter = set.iter(set)
    differ(set.kind(set),'iter') error("loop.iter requires kind 'iter'")
    iter.next(iter) = gt(iter.step(iter)) iter.start(iter) - iter.step(iter)
    iter.next(iter) = lt(iter.step(iter)) iter.start(iter) - iter.step(iter)
                                                    :(return)

loop.map
loop.seq

    set.iter(set) = iterator()                     :(return)

loop.set

    set.iter(set) = iterator()                     :(return)

loop.end

    define('member(set,elem)kind,entry,i,iter,key,this,value,block)') :(member.end)

*   _Member_ tests if _elem_ is member of _set_.

member

*   Branch according to whether _set_ is set, map, or sequence.

    eq(set.size(set))                               :s(freturn)
    elem = integer(elem) +elem
    ident(datatype(elem),'entry')                   :s(member.map)
    ident(set.kind(set),'int')                      :s(member.int)
    ident(set.kind(set),'iter')                     :s(member.iter)
    ident(set.kind(set),'set')                      :s(member.set)
    error('member: unexpected kind ' kind )

member.int

*   To test for membership in set of kind _int_ get the block
*   for the element. If it is null then fail since element not
*   in the set. Otherwise see if character corresponding to the
*   value of _elem_ is '+'.

    block = elem / setl4.config.int
    this = +(remdr(elem,setl4.config.int) + 1)
    value = set.key(set)[block]
    ident(value)                                    :s(freturn)
    ident(substr(value,this,1),'+')                 :s(return)f(freturn)

member.iter

    integer(elem)                                   :f(freturn)
    iter = set.iter(set)
    lt(iter.step(iter)) lt(elem,iter.finis(iter))    :s(freturn)
    gt(iter.step(iter)) eq(remdr(elem - iter.start(iter),iter.step(iter))):s(return)
    lt(iter.step(iter)) eq(remdr(iter.start(iter) - elem,iter.step(iter))):s(return)
                                                    :(freturn)

member.map

    differ(set.key(set)[key(elem)])                      :s(return)f(freturn)

member.set

    differ(set.key(set)[elem])                      :s(return)f(freturn)

member.end

    define('new(init)kind,i,index,iter,len,n,key,seq,val,values,words)'):(new.end)

*   _New_ constructs a new set with initial values determined by string _init_.

*   The first three characters in _init_ give the kind of the set:
*
*       'iter'          iterator, followed by iterator specification
*       'map'           map, followed by list of key/value pairs separated by colon
*       'set'           set, followed by list of initial members
*       'seq'           sequence, followed by list of initial values.

*   The set kind may optionally be followed by a number sign (#) followed by an integer, to
*   indiate an estimate of the number of elements in a set or map. Ihe number need not be
*   accurate. Values that are too high will cause the program to expend space to save some time;
*   numbers that are too low will expend some time to save space.

new

    ident(init)                                     :s(new.set)
    init = init ' '
    init span(' ') =
    init break(' ') . kind span(' ') =
    kind = (gt,size(kind),3) substr(kind,1,3)
    begins('integers',kind)                          :s(new.kind)
    begins('iterator',kind)                          :s(new.kind)
    begins('map',kind)                               :s(new.kind)
    begins('seq',kind)                               :s(new.kind)
    begins('set',kind)                               :s(new.kind)
    begins('string',kind)                            :s(new.kind)
    error('bad kind to new ' kind )

new.kind

    kind = gt(size(kind),3) substr(kind,1,3)
    n = 0
    init span(' ') =
    n = setl4.config.table.int.table.size
    init '# ' span('0123456789') . n =              :s(new.sized)
    init '#' span('0123456789') . n =

new.sized 

*   Branch on kind to finish initialization of new set.

                                                    :($('new.' kind))
new.int
    
    new = set('set',iterator(),table(n),table(n))
    set.kind(new) = 'int'
    set.index(new) = table(1000)
    set.key(new) = table(1000)

new.int.next

    init break(' ') . key span(' ') =              :f(return)
    add(new,int(key))                              :(new.int.next)

new.ite
new.iter

    iter = iterator()
    iter.step(iter) = 1
    seq = new('seq ' init)

*   Ignore extra arguments to iterator constructor.

    set.size(seq) = gt(set.size(seq),3) 
    eq(set.size(seq),1)                             :s(new.iter.1)
    eq(set.size(seq),2)                             :s(new.iter.2)
    eq(set.size(seq),3)                             :s(new.iter.3)

new.iter.1

    iter.start(iter) =  1
    iter.finis(iter) = get(seq,1)
    iter.step(iter) = 1                             :(new.iter.step)

new.iter.2

    iter.start(iter) =  get(seq,1)
    iter.finis(iter) = get(seq,2)
    iter.step(iter) = 1                             :(new.iter.step)

new.iter.3

    iter.start(iter) =  get(seq,1)
    iter.finis(iter) = get(seq,2)
    iter.step(iter) = get(seq,3) 

new.iter.step

*   Make sure step negative if first argument to iter is greater than the second.

    lt(iter.step) out('new -step',iter.step(iter))
    iter.step(iter) = gt(iter.start(iter),iter.finis(iter))  gt(iter.step(iter)) - iter.step(iter)
    new = set('iter',iter)
    set.size(new) = ((iter.finis(iter) - iter.start(iter)) / iter.step(iter)) + 1 

new.map
    
    new = set('map',iterator(),table(n),table(n))

*   If present, _init_ is a list consisting of a list of key/value pairs,

*   with a colon (:) separating the key and value.

    init = init ' '
    init span(' ') =
    ident(init)                                     :s(return)

new.map.next

    init break(':') . key ':' break(' ') . val span(' ') =  :f(return)
    put(new,key,val)                                
                :(new.map.next)

new.seq

    new = set('seq',iterator(),table(n),table(n))
    init span(' ') =
    ident(init)                                     :s(return)
    init = init ' '

new.seq.next

    init span(' ') =
    init break(' ') . val ' ' =                     :f(return)
    out('New.SEQ.next',val)
    push(new,val)                                   :(new.seq.next)

new.set

    new = set('set',iterator(),table(n),table(n))
    set.kind(new) = 'set'
    ident(init)                                     :s(return)

new.iter.next

    init break(' ') . key span(' ') =               :f(return)
    add(new,key)                                    :(new.iter.next)

new.set.done

    iter.next(new) =                                 :(return)

new.end

    define('new.stack()')                           :(new.stack.end)

*   _New.stack_ returns a new stack.

new.stack

*   Don't allocate stack table when creating stack. Do that
*   when first add value to stack.

    new.stack = stack(,0)                           :(return)

new.stack.end

    define('next(set)iter,key,next,str,value')    :(next.end)

*   _Next_ advances an iteration by setting field _next_ to the next item
*   to be visisted, or fails if no more elements remain.

next

*   Branch on kind to find next iteration value.

    iter = set.iter(set)
    iter = set.iter(set)

        :($('next.' set.kind(set)))

next.int

*   Iteration over a set    of kind 'int' makes use of the following fields:
*
*       set.block      is current block for iteration
*       set.offset     is zero if this block not search, or else index of an
                       element of the set in this block
*       set.str        is set to the string of a block when advance to it.

*   Branch to get first block if _set.str_ is null.

    ident(set.str(set))                             :s(next.int.block)

next.int.test

*   See if any members remain in this block, branching to _next.int.block_ if none.

next.int.block

*   Here to advance to next block, ending iteration if no more remain.

    set.block(set) = set.block(set) + 1
    gt(set.block(set),set.blocks(set))              :s(freturn)
    set.str(set) = set.key(set)[set.index(set)[set.block(set)]]
    str = set.str(set)
    str break('+') . key                            :f(next.int.block)

*   Here when member found. Clear the membership character and return.

    set.str(set) = set.key(set)[block]
    set.str(set) = ne(set.offset(set)) 
.           substr(set.str(set),1,set.offset(set) - 1,'-','+')
.          '+' 
.          substr(str,set.offset(set) + 1)
    set.str(set) = str
    next = (set.block(set) * setl4.config.int) + size(key)
    this = set.this(set) =  next                    :(return)

next.iter

*   Here to find next element in iterator.

    next = iter.next(iter) = iter.next(iter) + iter.step(iter)
    gt(iter.step(iter)) gt(next,iter.finis(iter))   :s(freturn)
    lt(iter.step(iter)) lt(next,iter.finis(iter))   :s(freturn)
    this = set.this(set) = next                     :(return)

next.map

    iter = set.iter(set)
    next = iter.next(iter) = iter.next(iter) + 1
    le(next,set.size(set))                          :f(freturn)
    key = set.index(set)[next]
    next = entry(key,set.key(set)[key])
    this = set.this(set) = next                     :(return)

next.seq

    iter = set.iter(set)
    next = iter.next(iter) = iter.next(iter) + 1
    le(next,set.size(set))                          :f(freturn)
    key = set.index(set)[next]
    next = set.key(set)[next]
    this = set.this(set) = next                     :(return)

next.set
    
    iter = set.iter(set)
    next = iter.next(iter) = +iter.next(iter) + 1
    le(next,set.size(set))                          :f(freturn)
    next = set.index(set)[next]
    this = set.this(set) = next                     
                                                    :(return)

next.end

    define('not(expr)')                             :(not.end)

*   _Not_ returns the negation of a boolean expression.

not

    not = integer(expr) (eq(expr) 1, '')            :s(return)f(freturn)
    not = ident(expr) 1                             :s(return)f(freturn)

not.end

    define('number(n)')                          :(number.end)

*   Test if _n_ is a string with integer value or integer, returning its
*   value if so, or failing otherwise.

number

    number = integer(n) +n                      :s(return)f(freturn)

number.end

    define('or(a,b)')                               :(or.end)

*   _Or_ tests if either operand is true, fails otherwise, only evaluating
*   its second argument if necessary

or
    or = integer(a) ne(a)                           :s(return)
    or = integer(b) ne(b)                           :s(return)

*   Here if operands not both integers, so use ident/differ.

    or = differ(a)                                  :s(return)
    or = differ(b)                                  :s(return)f(freturn)

or.end

    define('out(text1,text2,text3)type1,type2')     :(out.end)

*   _Out_ writes a line to standard output  conisting of _text1_, 
*   then _text2_ enclosed in brackets if _text2_ is not null, followed
*   by _text3_ if _text3_ is not null.

out

    out = setl4.simple.type(text1)
    out = differ(setl4.simple.type(text2)) out '[' setl4.simple.type(text2) ']'
    out = differ(setl4.simple.type(text3)) out  setl4.simple.type(text2)
    output = out                                    :(return)

out.end

    define('pop(stack)')                            :(pop.end)

*   _Pop_ removes (pops)  the top item from stack, or fails if the stack is empty.

pop

    eq(set.size(stack))                             :s(freturn)
    pop = set.key(stack)[set.index(stack)[set.size(stack)]]
    set.size(stack) = set.size(stack) - 1           :(return)

pop.end

    define('push(stack,value)')                     :(push.end)

*   _Push_ adds a new value to a stack (implemented as a sequence).

push

    ident(stack) error('push() first argument is null.')
    differ(datatype(stack),'set')
.       error('push() first argument is not a set, but instance of ' datatype(stack))
    ident(set.kind(stack),'map')                    :s(push.value)
    ident(set.kind(stack),'seq')                    :s(push.value)
    error('first argument to push() must be set or map, is ' datatype(stack))

push.value

    put(stack,set.size(stack) + 1, value)           :(return)

push.end

    define('put(map,key,value)v')                   :(put.end)

*   _Put_ sets the value of the entry for key _key_ in map _map_ to be _val_,

put

    key = integer(key) +key
    value = integer(value) +value
    differ(set.key(map)[key])                       :s(put.value)

*   Here to create new entry in map, and then merge to set new value.

    set.size(map) = set.size(map) + 1
    set.index(map)[set.size(map)] = key

put.value

    set.key(map)[key] = value                       :(return)

put.end

    define('range(map)elem)')                       :(range.end)

*   _Range_ returns the range of map, which is the set of the values in _map_.

range

    range = new()
    loop(map)

range.next

    entry = next(map)                               :f(return)
    add(range,value(key(entry)))                    :(range.next)

range.end

	define('random(n)')				:(random.end)

*	Return integer uniformly distributed in 1,2,...,n. 
*	If n=0 returns real uniformly distributed in the interval [0,1].
*	The Algorithm is based on that in section 16.1 of "Algorithms in SNOBOL4,"
*	James F. Gimpel, John Wiley and Sons, 1976.

random

    ident(setl4.random.initialized) random.seed()
	setl4.random.value = remdr(setl4.random.value * 4676, 414971)
	random  = setl4.random.value / 414971.0
	random = ne(n) convert(random * n,'integer') + 1

*   Make sure random of integer never returns zero.

    random = integer(random) eq(random) 1
							:(return)
random.end

	define('random.seed()s,c')			:(random.seed.end)

*	Compute seed for random number generator from date and time.

random.seed
    differ(setl4.random.initialized)                    :s(return)
    setl4.random.initialized = 'TRUE'
	setl4.random.value = 
	s = date()
	s = replace(s,'/:-','123')

*	Get all the digits in s.

random.seed.loop

	s len(1) . c =					:f(random.seed.done)
	ident(c,' ')					:s(random.seed.loop)
	setl4.random.value = setl4.random.value c			:(random.seed.loop)

random.seed.done

*	Reverse the seed so digits depending on time come first.

	setl4.random.value = +reverse(setl4.random.value)	
							:(return)
random.seed.end

    define('remove(set,elem)i,iter,this')           :(remove.end)

*   _Remove_ removes the element _elem_  from the set _set_. _Remove_
*   does nothing if _elem_ is not a member of the set.

*   If _elem_ is new, remove the most recently added element of a set or map.
*   If _set_ is a set, then remove _elem_ from _set_ if it is a member.
*   If _set_ is a map, remove the entry with key _value_.
*   Return the element removed.

remove

    eq(set.size(set))                               :s(freturn)
    ident(elem)                                     :s(remove.last)
    remove = elem
    ident(set.kind(set),'int')                      :s(remove.int)
    ident(set.kind(set),'map')                      :s(remove.map)
    ident(set.kind(set),'set')                      :s(remove.set)
    error('remove not defined for set of kind ' set.kind(set))

remove.int

    error("remove from set of kind 'int' not yet implemented.")

remove.last

    remove = set.index(set)[set.size(set)]
    set.size(set) = set.size(set) - 1               :(return)
 
remove.map
remove.set

    ident(set.key(set)[elem])                       :s(return)

*   Find the entry with key _elem_, assuming it's more likely
*   to be a newer addition than one of the older elements.

    iter = new('iter ' set.size(set) ' 1')
    i = set.size(set) + 1

remove.find

    gt(i = i - 1)                                   :f(remove.error)
    ident(set.index(set)[i],elem)                   :f(remove.find)

*   Delete _elem_ from the key table, then move the entries
*   in the index table following this one down one position.
*   Nothing remains to be done if the set had only one element, or
*   if the element was the last in the index table.

    set.key(set)[elem] =
    set.size(set) = set.size(set) - 1
    eq(set.size(set))                               :s(return)

remove.next

    eq(i,set.size(set))                             :s(return)
    set.index(set)[i] = set.index(set)[i + 1]
    i = i + 1                                       :(remove.next)

remove.error

    error('remove.set unable to locate member')

remove.end

    define('show(v,type,within)ara,i,kind,elem,entry,key,line,hdr,n,set.this,value') :(show.end)

*   _Show_ displays the value of its first argument in a form that is hopefully both
*   readable and pleasing to the eye.

*   If _type_ is not null, sets and maps are ranked in order given by _type_.
*   Otherwise sets and maps are increased in ascending value of members (set)
*   or keys (map).

*   _within is non-zero when called to list element of a compound object.

show

    ident(v)                                        :s(return)
    ident(datatype(set),'line')                     :s(show.line)
    differ(datatype(v),'set')                       :s($('show.' datatype(v)))

*   Make a copy of the argument to avoid disrupting a possible 
*   existing iteration over the argument.
    
    v = copy(v)
    
    kind = set.kind(v)
    ident(kind,'int')                               :s(show.int)
    ident(kind,'iter')                              :s(show.iter)
    ident(kind,'map')                               :s(show.map)
    ident(kind,'seq')                               :s(show.seq)
    ident(kind,'set')                               :s(show.set)
    error('show unknown set kind',kind,' quitting.')

show.array

    proto = prototype(ara)
    proto break(',')                                :s(show.array.2)

*   Here for one dimensional array.

show.array.1
    first = ara[add1(.i)]                           :f(show.array.done)
    out(lpad(i,3) tab first)                        :(show.array.1)

show.array.2
    first = ara[add1(.i),1]                         :f(show.array.done)
    out(lpad(i,3) tab show(first) tab show(ara[i,2])) :(show.array.2)

show.entry

    show = show ' ' show(key(v),,within)  ':' show(value(v),,within) :(show.done)

show.int

    show = '{ int'
    sorter(v,'+k')
    setl4.save(v)
    loop(v)

show.int.next

    elem = next(v)                                  :f(show.int.done)
    show = show ' ' show(elem,,within)
    lt(size(show),80)                               :s(show.int.next)
    out(show)
    show =                                          :(show.int.next)

show.int.done

    setl4.restore(v)
    show = show ' }'                                :(show.done)

show.iter

    show = 'iter{ '
    loop(v) 

show.iter.next

    elem = next(v)                                  :f(show.iter.done)
    show = show ' ' show(elem,,within)
    lt(size(show),80)                               :s(show.iter.next)
    out(show)
    show =                                          :(show.iter.next)

show.iter.done

    show = show ' }'                                :(show.done)

show.iterator

    show = '{iterator'
.           (ne(+iter.start(v))  ' start:'   iter.start(v) ,'')
.           (ne(+iter.finis(v))  ' finis:'   iter.finis(v),'')
.           (ne(+iter.step(v))   ' step:'    iter.step(v),'')  '} ' :(show.done)

show.integer

    show = v                                        :(show.done)

show.map

    show = 'map{'
    setl4.save(v)
    within = 1
*SORTER*
*   sorter(v,differ(type) type, '+k')
    loop(v)

show.map.next

    entry = next(v)                                 :f(show.map.done)

*   Here to show entry. Look for datatypes _line_ and _token_, showing
*   them directly. Otherwise, show key and value separated by ':' (colon).
    
    show = ident(datatype(value(entry),'token'))
.               show  show.token(v,,within)         :s(show.map.check)

*   show = show ' ' show(entry,,within) ' '
    show = show show(entry,,within) 

show.map.check

    lt(size(show),80)                               :s(show.map.next)
    out(show)
    show =                                          :(show.map.next)

show.map.done

    within = 
    setl4.restore(v)
    show = show ' }'                                :(show.done)

show.pair

    show = show ' ' show(first(v),,within)  ':' show(second(v,,within)) ' ' :(show.done)

show.seq

    show = 'seq{'
    setl4.save(v)
    within = 1
*SORTER*
*   sorter(v,differ(type) type, '+k')
    loop(v)

show.seq.next

    entry = next(v)                                :f(show.seq.done)
    show = show ' ' show(entry,,within) 

show.seq.check

    lt(size(show),80)                               :s(show.seq.next)
    out(show)
    show =                                          :(show.seq.next)

show.seq.done

    within = 
    setl4.restore(v)
    show = show ' }'                                :(show.done)

show.set

    show = 'set{'
    within = 1
*SORTER*
*   sorter(v,differ(type) type, '+k')
    setl4.save(v)
    loop(v)

show.set.next

    elem = next(v)                                :f(show.set.done)
    show = show ' ' show(elem,,within)
    lt(size(show),80)                             :s(show.set.next)
    out(show)
    show =                                        :(show.set.next)

show.set.done

    within = 
    setl4.restore(v)
    show = show ' }'                                :(show.done)

show.string

*   Don't quote string that is an integer.

    show = integer(v) v                             :s(show.done)

    show = show.q(v)                                :(show.done)

show.table

    within = 1
    show = 'table ['
    ara = convert(v,'array')                        :f(show.table.error)
    i = 0
    prototype(ara) break(',') . n                   :(show.table.next)

show.table.error

    error('error converting table to array')

show.table.next

    le(i = i + 1,n)                                 :f(show.table.done)
    show = show ' ' show(ara[i,1],,within) ':' show(ara[i,2],,within)    
    lt(size(show),80)                              :s(show.table.next)
    out(show)
    show =                                          :(show.table.next)

show.table.done

    within = 
    show = show ' ]'                                :(show.done)
 
show.string.quote

    show = '"'  v '"'                               :(show.done)

show.done

*   Write out result unless listing elements of compound object.

    ident(within) out(show)                            :(return)

show.end

    define('show.b(e)')                             :(show.b.end)

*   _Show.b_ shows the value if its argument as a boolean value: TRUE or FALSE

show.b

    integer(e) out((ne(e) 'TRUE', 'FALSE'))         :s(return)
    out((differ(e) 'TRUE', 'FALSE'))                :(return)

show.b.end

    define('show.eval(expr)e')                      :(show.eval.end)

*   _Show.eval_ evaluates its argument and returns 'success' if
*   the evaluation succeeded, or 'failure' if not.

show.eval

    eval(expr)                                      :s(show.eval.success)
    show.eval = 'failure'                           :(show.eval.finis)

show.eval.success
   
    show.eval = 'success'

show.eval.finis

    out('eval ' expr ' ' show.eval)                 :(return)

show.eval.end

    define('show.lines(lines,number)i,line')        :(show.lines.end)

*   Show a sequence of lines, including the line number if _number_ not null.

show.lines

    loop(lines)

show.lines.next

    line = next(lines)                              :f(return)
    i = i + 1
    gt(i,100) error('i too big')
    ident(number)    out(line)                      :s(show.lines.next)
    differ(number)   out(lpad(i,6) '  ' line)       :(show.lines.next)

show.lines.end

    define('show.q(str)')                           :(show.q.end)

*   _Show.q_ shows its argument string _str_ enclosed in quotes

show.q

    str break("'")                                  :s(show.q.double)

*   Here if string does not contain a single quote, so use single quotes around it.

    show.q = "'" str "'"                            :(return)

show.q.double

*   Here if string contains single quote, so use double quotes around it.

    show.q = '"' str '"'                            :(return)

show.q.end

    define('sorter(set,type)ara,entry,i,key,index.table,map,n,seq,str,tbl,value.table,value') :(sorter.end)

*   _Sorter_ sorts the index table of _set_ according to _type_ to reflect
*   a desired sort of the elements of set, keys or maps, or values of map.
*   _Sorter_ doesn't create a new set, but just updates the index table so that,
*   going forward, entries will be visited in the order specified by _type_.

*   _Sorter_ can also be used to put a string in normal form by converting the string
*   into a sequence of the characters in the string and then sorting the range
*   of the sequence.

*   The argument _type_ specifies the ordering to be used:

*       '+index'    increasing order of when entry created (oldest first)

*       '-index'    decreasing order of when entry created (most recent first)

*       '+key'      increasing order of the values in the domain

*       '-key'      decreasing order of the values in the domain

*       '+value'    increasing order of the values in the range

*       '-value'    decreasing order of the values in the range

*   Types for keys and values may be abbreviated: "+key" may be written
*   as "+k" or "+ke", "+value" as "+v" or +"val", and so forth.

sorter

*   Use _setl4.string.sorter_ if input is a string.

    sorter = ident(datatype(set),'string') setl4.string.sorter(set) :s(return)

    n = set.size(set)
    index.table = set.index(set)
    out('sorter index table')
    show(index.table)

*   Here to detect cases for which sort has no meaning, in which case
*   return immediately. This includes the case 'int' which, though possible
*   to sort as desired, requires a complicated algorithm that has yet to be
*   thought through.

    type = get(setl4.sorter.types,type) 
    ident(datatype(set),'set') ident(set.kind(set),'int')   :s(return)
    ident(datatype(set),'set') ident(set.kind(set),'iter')  :s(return)
    ident(datatype(set),'set')                              :s(sorter.set)
    error('sorter - unsupported input type ' datatype(set) )
    
sorter.set

*   Nothing to do if set is empty or only has one element.

    le(n,1)                                         :s(return)
    differ(datatype(set),'set') error('sorter bad datatype ' datatype(set))
    ident(type) error('sorter null type')

    ident(type,'+v')                                :s(sorter.value)
    ident(type,'-v')                                :s(sorter.value)

*   Here to sort index table.

    tbl = setl4.set.sorter(set,type)            
    differ(datatype(tbl),'table') error('sorter result not table')
                                                    :(sorter.finis)
    i = 0

sorter.index.next

    le(i = i + 1,n)                                 :f(sorter.finis)
    out('sorter.index.next',i)
    tbl[i] = index.table[ara[i,1]]                  :(sorter.index.next)
    
sorter.value

*   Here to  sort by value: build table mapping index numbers into
*   the values associated with their keys, and sort that.

    tbl = compose(set.index(set),set.key(set))
    type = ident(type,'+v') '+k'
    type = ident(type,'-v') '-k'
    value.table = setl4.table.sorter(set,type,tbl)
    i = 0

*   The table is in proper order, so replace values with the keys
*   associated with that value.

sorter.value.next
    
    le(i = i + 1,n)                                 :f(sorter.finis)
    tbl[i] = value.table[ara[i,1]]                  :(sorter.value.next)
    
sorter.finis

    out('sorter.finis')
    show(tbl)
    set.index(set) = tbl                             
    show(set)
    out('exit sorter')
                                                    :(return)

sorter.end

    define('subset(a,b)elem')                       :(subset.end)

*   _Subset_ tests if its second argument is a subset of the first.

subset

    gt(set.size(b),set.size(a))                     :s(freturn)
    loop(b)

subset.next

    elem = next(b)                                  :f(return)
    member(a,elem)                                  :s(subset.next)f(freturn)

subset.end

    define('this(set)')                             :(this.end)

*   _This_ returns the value determined in the most recent call to next.

this

    this = set.this(set)                            :(return)

this.end

    define('top(stack)')                            :(top.end)

*   _Top_ returns the top element of the stack, or fails if the stack is empty.

top

    differ(datatype(stack),'set') error('argument to top() is not a stack.')
    eq(size(stack))                                 :s(freturn)
    top = get(stack,set.size(stack))                :(return)

top.end

    define('true(e)')                               :(true.end)

*   _True_ Tests if its operand is true

true

    e = integer(e) +e
    integer(e) ne(e)                                :s(return)
    differ(e)                                       :s(return)f(freturn)

true.end

    define('union(a,b)elem')                        :(union.end)

*   _Union_ returns the union of sets _a_ and _b_.

union

*   Arrange so set _a_ is the larger 

    ge(set.size(a),set.size(b))                     :s(union.a)
    union = a
    a = b
    b = union

union.a

*   Make copy of _a_ to start things off.

    union = copy(a)
    loop(b)

union.b

    elem = next(b)                                  :f(return)
    add(union,elem)                                 :(union.b)

union.end

    define('visit(set,expr)this')                   :(visit.end)

*   _Visit_ loops over _set and calls _eval_ with argument
*   _expr_  for each of member of the set.

visit

    loop(set)

visit.next

    this = next(set)                                :f(return)
    eval(expr)                                      :(visit.next)

visit.end

    define('words(line,w)word')                      :(words.end)

*   _Words_ returns a sequence of the words in _line_, where _w_
*   is a string that defines the allowed characters in a word.

words

*   out('enter words',line)
*   out('enter words dt w',datatype(w))
*   out('w',show.q(w))
    words = new('seq #' size(line))

words.next

    line span(w) . word =                           :s(words.add)

*   No word begins at this character, so move on to the next one.

    line len(1) =                                   :f(return)s(words.next)

words.add

    push(words, word)                               :(words.next)

words.end


    define('traceoff()')                            :(traceoff.end)

*   _Traceoff_ ends tracing.

traceoff

    &ftrace = &trace =
    out('stop TRACING ')

traceoff.end

    define('traceon()')                             :(traceon.end)

*   _Traceon_ begins tracing.

traceon

    out('start TRACING')
*   &ftrace = &trace = 1500000
    g.scoring = g.tracing = 1
                                                    :(return)
traceon.end

*   SETL4 uses some of the undefined SPITBOL operators for SETL4 functions.

*   Characters available for use by 'opsyn' to associate the character
*   with a function.

*   binary  &  @  #  %  ~
*   unary:  !  %  /  #  =  | /

*   define('setl4.op(ch,proc,n)')                   :(setl4.op.end)
*
**  _Setl4.opsyn_ uses _opsyn_ to define a SETL4 operator.
*
*setl4.op
*
*   opsyn(ch,proc,n)                                :s(return)
*   error('fatal problem with opsyn for ' ch ')
*
*setl4.op.end

    :(opsyn.bypass)
    output = 'at opsyn'
*   SETL4 binary operators

*    opsyn('&','and',        2)
    opsyn('@','at',         2)
    opsyn('#','filter',     2)
    opsyn('~','member',     2)
*   opsyn('^','or',        2)

*   SETL4 unary operators:

    opsyn('=','this',       1)
    opsyn('|','new',        1)
    opsyn('!','not',        1)
    opsyn('#','setl4.size', 1)
    opsyn('/','split',      1)

*   Use of opsyn for 'and' and 'or' deferred since supporting them requires
*   mucking about with bol4.

opsyn.bypass

*   Utility Functions

*   In addition to set-theoretic functions SETL4 provides 
*   the following utility functions.


    define('less(str,sub)before,after')             :(less.end)

*   _Less_ removes the first instance of each character in _sub_ from _str_,
*   where _sub_ is a substr of _str_.

less

    ident(str)                                      :s(return)
    less = str

less.ch
    sub len(1) . ch =                               :f(return)
    less break(ch) . before  ch rem . after
    less = before after                             :(less.ch)

less.end

    define('letters(str)ch')                        :(letters.end)

*   _Letters_ returns a string consisting of the letters in string _str_ separated by a space.
*   Letters can be used to build a sequence of the non-blank letters in a string: _new('seq ' letters(str))_

letters

    str len(1) . ch =                               :f(return)
    ident(ch,' ')                                   :s(letters)
    letters = letters (differ(letters) ' ', '') ch  :(letters)

letters.end

    define('lower.case(s)')                         :(lower.case.end)

*   _Lower.case_ converts argument to lower case.

lower.case

    lower.case = replace(s,&ucase,&lcase)           :(return)

lower.case.end

    define('multiple(n,m)')                     :(multiple.end)

*   _Multiple_ Tests if _n_ is a multiple of _m_.

multiple

    multiple = eq(remdr(n,m))                   :s(return)f(freturn)

multiple.end

    define('odd(n)')                            :(odd.end)

*   _Odd_ tests if its argument is odd.

odd

    odd = ne(remdr(n,2))                        :s(return)f(freturn)

odd.end

    define('prefix(str,pre)word')               :(prefix.end)

*   _Prefix_ takes a list of space-separated words _str_ and prefixes each
*   with the str _pre_.

prefix

    str = str ' ';* so each word followed by space

prefix.1

    str break(' ') . word span(' ')  =          :f(return)
    add1(.prefixcount)
    prefix = append(prefix, pre word,'A')       :(prefix.1)

prefix.end

    define('prime(n)')                          :(prime.end)

*   _Prime_ tests if _n_ is a prime integer.

prime

    n = integer(n) +n
    eq(n,2)                                     :s(return)
    even(n)                                     :s(freturn)
    exists(new('iter 3 ' square.root(n) ' 2'), 'multiple(n,this)') :s(freturn)f(return)

prime.end

    define('primes(n)set.this')                 :(primes.end)

*   _Primes_ returns the set of primes less than _n_.

primes

    primes = filter(new('iter 2 ' (n - 1)),'prime(this)') :(return)
    primes = new('seq 2')
    iter = new('iter 2 ' (n - 1))
    loop(set)

primes.loop
   
    this = next(set)                           :f(return)
    prime(this) push(primes,this)              :(primes.loop)

primes.end


    define('quicksort(seq)c,seq.eq,set.gt,seq.lt,pivot,this') :(quicksort.end)

*   _Quicksort_ sorts the sequence _seq_ using Hoare's quicksort algorithm.
*   _Seq_ must be sequence of integers or sequence of strings.

*   This program is for demonstrating SETL4. 
*   Use the much more efficient _sorter_ for production use.

quicksort

    quicksort = le(set.size(seq),1) seq             :s(return)
    pivot = arbitrary(seq)
    number(pivot)                                   :f(quicksort.strings)

*   Here to sort sequence of integers.

    quicksort = join( quicksort(filter(seq,  'lt(value(this),pivot)')),
.                               filter(seq,  'eq(value(this),pivot)'),
.                     quicksort(filter(seq,  'gt(value(this),pivot)'))) :(return)


*   Here to sort sequence of strings.

    quicksort = join( quicksort(filter(seq,  'llt(value(this),pivot)')),
.                               filter(seq,  'leq(value(this),pivot)'),
.                     quicksort(filter(seq,  'lgt(value(this),pivot)'))) :(return)

quicksort.end

    define('reader(filename,undent)line')           :(reader.end)

*   _Reader_ returns a sequence of the lines in the file specified by _filename_.
*   Lines are read from standard input if _filename_ is null.
*   If _undent_ is not null, leading spaces in lines are eliminated.

reader

    differ(filename) input(.file,setl4.config.channel.1,filename):s(reader.opened)
    out('unable to open reader file ' filename '.') :(freturn)

reader.opened

    reader = new('seq')

reader.next

    line = (ident(filename) input, file)                :f(reader.eof)
    ident(line)                                         :s(reader.next)
    line '*'                                            :s(reader.next)
    ident(undent)                                       :s(reader.add)
    line span(' ') =

reader.add

    push(reader,line)                                   :(reader.next)

reader.eof

*   Here at end of file; close temporary file if one was needed.

    differ(filename) endfile(setl4.config.channel.1)    :(return)

reader.end

    define('reader.str(str,delim)line')             :(reader.str.end)

*   _Reader.str_ returns a sequence of the lines in _str_, where 
*   the character _delim_ is used to indicate end of line.
*   If _delim_ is  not given, then '/' is understood.

reader.str

    delim = ident(delim) '/'
    reader.str = new('seq')

reader.str.next

    str break(delim) . line delim =                 :f(return)
    push(reader.str,line)                           :(reader.str.next)

reader.str.end

    define('slice(str,first,last)')                 :(slice.end)

*   _Slice_ returns a slice of a string. It does the same operation as _substr),

slice

    slice = substr(str,first,last)                  :(return)

slice.end



    define('split.line(line)word')                  :(split.line.end)

*   _Split.lines_ splits a line into a sequence of words, where words are separated by one of more spaces.

split.line

    split.line = new('seq')
    line span(' ') =
    ident(line)                                         :s(return)
    line = line ' '

split.line.next

*   Here to split line into a sequence of its words.

    line break(' ') . word span(' ') =                  :f(return)
    push(split.line, word)                              :(split.line.next)

split.line.end

    define('split.string(str)c')                        :(split.string.end)

*   _Split.str_ returns a sequence of the characters in _str_. 

split.string

    split.string = new('seq')
    str span(' ') =
    ident(str)                                          :s(return)
    str break(' ')                                      :f(split.string)

split.string.next

*   Here to split.stringing into a sequence of its characters.

    str len(1) . c =                                    :f(split.string.done)
    put(split.string,i = i + 1, c)                      :(split.string.next)

split.string.end

    define('square.root(n)')                    :(square.root.end)

*   _Square.root_ returns the square root of its argument, rounded up.

square.root
   
    square.root = int(sqrt(n)) + 1              :(return)

square.root.end

    define('thousands(s)n')                     :(thousands.end)

*   _Thousands_ formats its argument by inserting comma's every three digits from right.

thousands

    n = size(s)
    thousands = le(n,3) s                       :s(return)
    thousands = thousands(substr(s,1,n - 3)) ',' substr(s, n - 2, 3):(return)

thousands.end

*#  Tokens: Lexical Scanning


*   A token is represented as an instance of the datatype _token_ as follows:

    data('token(lineno,col,type,text)')

*   where:
*           _lineno_        is the line number within the file;
*           _col_           is the index (column number) of the first character of the token in the line;
*           _type_          is the token's type, as described below; and
*           _text_          is the text of the token.

*   The type is represented by a single character, as follows:

*           'c'             comment, indicated by asterisk (*) in the first column.
*                           The text consists of the entire line.

*           'i'             integer, consisting of one or more digits ('0123456789')

*           'l'             left opener, one of '(<[{'

*           'p'             punctation, one of '.;,?!', or single quote (') or double quote ("),

*           'o'             other printable character, one of '~@#$%^&*_-+=`'.

*           'q'             quoted str, starting witn '"', and continuing to the next instance of the opening quote character.

*           'r'             right closer, one of ')>]}'

*           's'             space, consistine of one or more spaces (spaces)

*           't'             tab character

*           'u'             unprintable character, for example control-k

*           'w'             word, consisting of one of more letters in upper or lower case or "'" or "_".

*   The longest possible string meeting the rules is used when building a token.
*   For example, 'abc' is just the word 'abc', not 'a' followed by 'bc', and so forth.

*   It is recommended that the tab character NOT be used as an abbreviation for
*   one or more spaces in the input file. If tabs are used, then _col_ is ill-defined.
*   If tabs are not used, then _col_ indicates the true position in the line of
*   the first character of the token, and so error messages and references to the
*   token will be exact.  For example, _pos_ could be used to indicate where to give
*   emphasis to a token by underlining it, or enclosing it in '_' to generate
*   markdown format, and so forth.

    define('tokens(line)type,pos,text,lineno')  :(tokens.end)

*   _Tokens_ scans a line _line_ and returns a table of the tokens in the line.
*   The table has keys from 1..n, where _n_ is the number of tokens found.

*   This function is an instance of what is called a lexical scanner, or tokenizer.
*   This is the first stage in a programming language compiler, or for any program
*   that processes text files with a specified structure.

tokens

    tokens = new('seq')
    line '*'                                        :f(tokens.next)
    type = 'c'
    text = line
    line =                                          :(tokens.new)

tokens.next

    line ' '                                        :s(tokens.space)
    line any('0123456789')                          :s(tokens.integer)
    line any('(<[{')                                :s(tokens.left)
    line any('.;,?!')                               :s(tokens.punctuation)
    line '"'                                        :s(tokens.quote)
    line any('~@#$%^&*_-+=')                        :s(tokens.other)
    line any(')>]}')                                :s(tokens.right)
    line char(9)                                    :s(tokens.tab)
    line any(&lcase &ucase)                         :s(tokens.word)

*   Here for unprintable
    error('unprintable?? fix in tokens')

tokens.integer

    type = 'i'
    line span('0123456789') . text =                :(tokens.new)

tokens.punctuation

    type = 'p'                                      :(tokens.character)

tokens.other

    type = 'o'                                      :(tokens.character)

tokens.quote

    type = 'q'
    line '"' break('"') . text '"' =
    text = '"' text '"'                             :(token.new)

tokens.right

    type = 'r'                                      :(tokens.character)

tokens.space

    type = 's'
    line span(' ')  . text =                        :(tokens.new)

tokens.tab

    type = 't'                                      :(tokens.character)

tokens.word

*TODO*
    type = 'w'
    line span(&ucase &lcase "_" "'") . text =       :(tokens.new)

tokens.character

*   Here if token is single character.

    line len(1) . text                              :(tokens.new)

tokens.new

    setl4.add(tokens,token(lineno,pos,type,text))   :(tokens.next)

tokens.end

    define('upper.case(s)')                         :(upper.case.end)

*   _Upper.case_ converts its argument to upper case.

upper.case

    upper.case = replace(s,&lcase,&ucase)           :(return)

upper.case.end

    define('writer(lines)')                         :(writer.end)

*   _Writer_ writes the lines in the sequence _lines_ to standard output.

writer

    loop(lines)

writer.next

    output = next(lines)                            :f(return)s(writer.next)

writer.end

    define('setl4.clear()')                         :(setl4.clear.end)

*   _Setl4.clear) clearis the values of setl4 global variables. This reduces amount of &dump output.

setl4.clear

    setl4.config.set.table.size = setl4.config.stack = setl4.config.set.table.size = setl4.config.int =
.   setl4.stack = setl4.ascii.initialized = setl4.ascii.name = setl4.config.int.init =
.   setl4.ascii.value = setl4.random.initialized = setl4.any.digit = setl4.span.digits = 
.   setl4.break.digit = setl4.break.letter = setl4.any.letter =
.   setl4.span.letters = setl4.span.spaces = setl4.break.space =
.   setl4.any.word = setl4.span.word = setl.sorter.map = setl4.sorter.types = 
                                                    :(return)
setl4.clear.end

    define('setl4.restore(s)')                      :(setl4.restore.end)

*   _Setl4.restore_ restores the values saved by the most recent call to _setl4.push_.

setl4.restore

    set.this(s) = pop(setl4.stack)
    set.index(s) = pop(setl4.stack)                
                :(return)

setl4.restore.end

    define('setl4.save(s)')                         :(setl4.save.end)

*   _Setl4.save_ saves the _index and _this_ fields of its argument set.

setl4.save

    push(setl4.stack,set.index(s))
    push(setl4.stack,set.this(s))                   
                                                    :(return)

setl4.save.end

    define('setl4.set.sorter(set,type)ara,i,index') :(setl4.set.sorter.end)

*   _Setl4.table.sorter_ returns an index table derived from the
*   index table of _set_ that reflects the ordering given by _type_.

setl4.set.sorter

    le(set.size(set),1)                                         :s(return)
*   out('setl4.set.sorter index.table')
    ara = ident(type,'+i')    sort( set.index(set), 1)  :s(setl4.set.sorter.1)
    ara = ident(type,'-i')    rsort(set.index(set), 1)  :s(setl4.set.sorter.1)
    ara = ident(type,'+k')    sort( set.index(set), 2)  :s(setl4.set.sorter.1)
    ara = ident(type,'-k')    rsort(set.index(set), 2)  :s(setl4.set.sorter.1)

    error('setl4.set.sorter unsupported key type: ' type)

setl4.set.sorter.1

    differ(datatype(ara),'array') 
.               error('setl4.set.sorter sort result not array:' datatype(ara))

    setl4.table.sorter = table(n)
    index = 0

setl4.set.sorter.set.next

    le(i = i + 1,n)                                 :f(setl4.set.sorter.finis)
    index = ara[i,1]
    out('setl4.set.sorter.set i',i)
    out('setl4.set.sorter.set ara[i,1]',ara[i,1])
    out('setl4.set.sorter.set index',index)
    out('setl4.set.sorter.set index.table[index]',index.table[index])
    out('setl4.set.sorter.set setl4.table.sorter[i]',setl4.table.sorter[i])
    setl4.table.sorter[i] = index.table[index]            
                                                    :(setl4.set.sorter.set.next)
setl4.set.sorter.finis

    setl4.set.sorter = setl4.table.sorter               :(return)

setl4.set.sorter.end

    define('setl4.show(set)iter')                   :(setl4.show.end)

*   Setl4.show_ shows  the fields of an instance of _set_ or _iterator_.

setl4.show

    ident(datatype(set),'iterator')                 :s(setl4.show.iter)
    ident(datatype(set),'set')                      :s(setl4.show.set)
    error('setl4.show unsupported kind: ' set.kind(set))

setl4.show.iter

    setl4.show =  out('(iterator '
.            (ne(iter.start(set)) ' start:'     +iter.start(set), '') 
.            (ne(iter.finis(set)) ' finis:'     +iter.finis(set),'')
.            (ne(iter.step(set))  ' step:'      +iter.step(set),'') ')' )
                                                    :(return)

setl4.show.set

    iter = set.iter(set)
                                        out('{')
                                        out('  kind',     show.q(set.kind(set)))
    ne(set.size(set))                   out('  size',     set.size(set))

    differ(set.index(set)) differ(set.key(set))
.                                       out('  has index and key tables')

*   differ(set.index(set))              out('  has index table')
*   differ(set.key(set))                out('  has key table')

*   differ(iter)                        out('  has iterator')
    differ(set.this(set))               out('  this',     set.this(set))
    differ(iter) ne(iter.start(iter))   out('  start',    iter.start(iter))
    differ(iter) ne(iter.finis(iter))   out('  finis',    iter.finis(iter))
    differ(iter) ne(iter.step(iter))    out('  step',     iter.step(iter))
                                        out('}')
    differ(set.index(set)) differ(datatype(set.index(set)),'table') 
.           error(' set.index is not table')
    differ(set.key(set)) differ(datatype(set.key(set)),'table') 
.           error('set.key is not table')
                                                    :(return)
setl4.show.end

    define('setl4.simple.type(type)')               :(setl4.simple.type.end)

*   Tests if _v_ is a 'simple' type suitable for use in _out()_.
*   Simple types are 'integer','real', and 'string'.
*   Returns _v_ if _type_ is a simple type, null otherwise.

setl4.simple.type

    setl4.simple.type = type
    ident(datatype(type),'integer')                 :s(return)
    ident(datatype(type),'real')                    :s(return)
    ident(datatype(type),'string')                  :s(return)
    setl4.simple.type =                             :(return)

setl4.simple.type.end
    
    define('setl4.set.size(set)')                   :(setl4.size.end)

*   Setl4.set.size_ returns the  size of operand.

setl4.size

    setl4.size = ident(datatype(set),'string') size(set)    :s(return)
    setl4.size = differ(iter.step(set)) (iter.finis(set) - iter.start(set) / iter.step(set)) + 1 :s(return)
    setl4.size = set.size(set)                      :(return)

setl4.size.end

    define('setl4.string.sorter(str)ara,c,i,tbl')   :(setl4.string.sorter.end)

*   _Sorter_sorts a string into a string with all the characters
*   in lexical (alphabetic) order.

setl4.string.sorter

    tbl = table(size(str))

setl4.string.sorter.tbl

    c = substr(str,i = i + 1,1)                     :f(setl4.string.sorter.sort)
    tbl[i] = c                                      :(setl4.string.sorter.tbl)

setl4.string.sorter.sort

*   Sort the table and rebuild the string in sorter order.

    i = 0
    ara = sort(tbl,2)
    
setl4.string.sorter.next

    c = ara[i = i + 1,2]                            :f(return)
    setl4.string.sorter = setl4.string.sorter c     :(setl4.string.sorter.next)

setl4.string.sorter.end

    define('setl4.table.sorter(set,type,tbl)ara,i,index') :(setl4.table.sorter.end)

*   _Setl4.table.sorter_ returns an index table derived from the
*   index table of _set_ that reflects the ordering given by _type_.

setl4.table.sorter

    le(set.size(set),1)                                         :s(return)

    ara = ident(type,'+i')    sort(tbl,1)           :s(setl4.table.sorter.1)
    ara = ident(type,'-i')    rsort(tbl,1)          :s(setl4.table.sorter.1)
    ara = ident(type,'+k')    sort(tbl,2)           :s(setl4.table.sorter.1)
    ara = ident(type,'-k')    rsort(tbl,2)          :s(setl4.table.sorter.1)
    error('setl4.table.sorter unexpected type :' type)

setl4.table.sorter.1

    setl4.table.sorter = table(n)
    index = 0

setl4.table.sorter.table.next

    le(i = i + 1,set.size(set))                                 :f(return)
    index = ara[i,1]                                            :f(setl4.table.sorter.error)
    out('setl4.table.sorter.table i',i)
    out('setl4.table.sorter.table ara[i,1]',ara[i,1])
    out('setl4.table.sorter.table index',index)
    out('setl4.table.sorter.table index.table[index]',index.table[index])
    out('setl4.table.sorter.table setl4.table.sorter[i]',setl4.table.sorter[i])
    setl4.table.sorter[i] = index.table[index]
                                                    :(setl4.table.sorter.table.next)
setl4.table.sorter.error

    error('setl4.table.sorter error, array out of bounds reference.')

setl4.table.sorter.end


*## SETL4 Global variables

    setl4.ascii.initialized = 
    setl4.ascii.name = 
    setl4.ascii.value =  
    setl4.random.initialized =
    setl4.random.value = 2017

*   Useful patterns

    setl4.any.digit         =   any('0123456789')
    setl4.span.digits       =   span('0123456789')
    setl4.break.digit       =   break('0123456789')

    setl4.break.letter      =   break(&lcase &ucase)
    setl4.any.letter        =   any(&lcase &ucase)
    setl4.span.letters      =   span(&lcase &ucase)
    setl4.span.spaces       =   span(' ' char(9))
    setl4.break.space       =   break(' ' char(9))

    setl4.any.word          =   any(&lcase &ucase '0123456789')
    setl4.span.word         =   span(&lcase &ucase '0123456789')

    setl4.random.value      = 2017
*   setl4.sorter.types gives valid values for the argument _type_ in the function _sorter()_

    setl4.sorter.types = new('map '
.      '+:+k +k:+k +ke:+k +key:+k -:-k -k:-k -ke:-k -key:-k '
.      '+v:+v +va:+v +val:+v +valu:+v +value:+v -v:-v -va:-v -val:-v -valu:-v -value:-v '
.      '+i:+i +in:+i +ind:+ +inde:i+i +index:+i -i:-i -in:-i -ind:- -inde:i-i -index:-i')

*   SETL4 needs a stack

    setl4.stack = new('seq')

*   _setl4.config.library.texts_ is a set of the names of the available texts.

    setl4.config.library.texts = new('set dictionary genesis hamlet new-testament old-testament romeo-and-juliet shakespeare sonnets')

*   Here endeth the SETL4 code.
*   May you fare well using it.

